{- systemf -}

syntax:

  types              t ::= a | Int | t1 -> t2 | forall a. t | (t1,...,tn)
  terms              e ::= x | i | \(x:t). e | e1 e2 | /\a. e | e[t] | (e1,...,en) | proj_i(e)

  type contexts      D ::= empty | D,a
  value contexts     G ::= empty | G,(x:t)

typing:

  F-Var   D;G |- x : t                               if (x:t) in G
  F-Int   D;G |- i : Int
  F-Abs   D;G |- \(x:t1). e : t1 -> t2               if D;G,(x:t1) |- e : t2
  F-App   D;G |- e1 e2 : t2                          if D;G |- e1 : t1 -> t2    G |- e2 : t1
  F-TAbs  D;G |- /\a. e : forall a. t                if D,a;G |- e : t
  F-TApp  D;G |- e[t] : t'[t/a]                      if D;G |- e : forall a. t'
  F-Tup   D;G |- (e1,...,en) : (t1,...,tn)           if D;G |- e1 : t1, ... , D;G |- en : tn
  F-Proj  D;G |- proj_i(e) : ti                      if D;G |- e : (t1,...,tn)    1 <= i <= n

{- system f with intersection types -}

syntax:

  types              t ::= a | Int | t1 -> t2 | forall a. t | t1 & t2
  terms              e ::= x | i | \(x:t). e | e1 e2 | /\a. e | e[t] | e1 ,, e2

  type contexts      D (same)
  value contexts     G (same)

  normalized types   t ::= a | Int | t1 -> t2 | forall a. t | (t1,...,tn)
                     s ::= t | (s1 | s2) | (s1 & s2)

{- type-directed translation from system f to system f with intersection types -}

  E-Var      (x:t) in G
             -----------------
             D;G |- x : t ~> x

  E-Int      D;G |- i : Int ~> i

  E-Abs      D;G,(x:t) |- e : t' ~> e'
             ----------------------------------------
             D;G |- \(x:t). e : t -> t' ~> \(x:t). e'

  E-App      D;G |- e1 : t1 -> t2 ~> e1'    D;G |- e2 : t2 ~> e2'
             -----------------------------------------------------
             D;G |- e1 e2 : t2 ~> e1' e2'

  E-TAbs     D,a;G |- e : t ~> e'
             -------------------------------------------
             D;G |- /\a. e : forall a. t ~> /\a. e'

  E-TApp     D;G |- e : forall a. t' ~> e'
             ----------------------------
             D;G |- e[t] : t'[t/a] ~> e'[t/a]

  E-Merge_k  D;G |- e1 : t1 ~> e1'    D;G |- e2 : t2 ~> e2'
             ----------------------------------------------
             D;G |- e1 ,, e2 : tk ~> proj_k(e1', e2')

             D;G |- e : t1 ~> e1    D;G |- e : t2 ~> e2
  E-Intro    ------------------------------------------
             D;G |- e : t1 & t2 ~> (e1, e2)

             D;G |- e : t1 & t2 ~> e'
  E-Elim_k   ---------------------------
             D;G |- e : tk ~> proj_k(e')
