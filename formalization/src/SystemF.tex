%include lhs2TeX.fmt
%include polycode.fmt
%include forall.fmt
%include Rule.fmt

\section{Type-Inference for the Simply Typed Lambda Calculus}

The syntax of System F is as follows: 
{\small
  \[ \begin{array}{llrl}
    \text{Types} & T & ::= & \alpha \mid T \arrow T 
    \mid \forall \alpha. T \\ 
    \text{Expressions} & E & ::=  & x \mid y \mid \lambda (x:T) . E \mid E\;E
    \mid \Lambda \alpha . E \mid E\;T 
  \end{array} \]}

\newcommand{\typeSrc}{T}
\newcommand{\envSrc}{G}
\figtwocol{f:syntax}{System F}{
\small
\bda{l}

\ba{llrl}
    \textbf{Types} & \type & ::= & \alpha \mid \type \arrow \type 
    \mid \forall \alpha. \type \\ 
    \textbf{Expressions} & e & ::=  & x \mid \lambda (x:\type) . e \mid e\;e \mid {\bf fix}~y . \lambda (x : \type_1) : \type_2 . e 
    \mid \Lambda \alpha . e \mid e\;\type 
\ea
\\ \\

\ba{llrl} 
\textbf{Type Environments} & \Gamma & ::= & \epsilon \mid \Gamma, \relation{x}{\type} \\
%%\textbf{Fixpoint Environments} & \Theta & ::= & \epsilon \mid \relation{x}{\type} 
\ea 
\\ \\

\textbf{Type System}
\\ \\

\ba{lc}
\multicolumn{2}{l}{\myruleform{\Gamma \turns  \relation{e}{\type}}} \\ \\

  (\texttt{F-Var}) & 
\myirule{
           (x : \type) \in \Gamma
 }{
            \Gamma \turns x : \type
} \\ \\

  (\texttt{F-Abs}) & 
\myirule{
 %%         \Gamma_1 \turns \Gamma_2 \\
          \Gamma_2, x : \type_1 \turns e : \type_2
 }{
          \Gamma_1 \turns \lambda (x:\type_1).e : \type_1 \rightarrow \type_2
} \\ \\

  (\texttt{F-App}) & 
\myirule{
  \Gamma \turns e_1 : \type_2 \rightarrow \type_1 \\
           \Gamma \turns e_2 : \type_2
          }{
           \Gamma \turns e_1 \, e_2 : \type_1
} \\ \\

%%  (\texttt{F-Fix2}) & 
%%\myirule{
%%           (x:\type); \Gamma \turns e [y \mapsto x]: \type
%% }{
%%           (y:\type); \Gamma \turns {\bf fix} (x:\type).e : \type
%%} \\ \\

  (\texttt{F-TApp}) & 
\myirule{
  \Gamma \turns e : \forall \alpha. \type_2
           }{
            \Gamma \turns e \, \type_1 : \type_2[\type_1/\alpha]
} \\ \\

  (\texttt{F-TAbs}) & 
\myirule{
   \Gamma, \alpha \turns e : \type
            }{
             \Gamma \turns \Lambda \alpha.e : \forall \alpha. \type 
} \\ \\

  (\texttt{F-Fix}) & 
\myirule{
           \Gamma, (y : \type_1 \rightarrow \type_2) \turns \lambda (x : \type_1) . e : \type_1 \rightarrow \type_2
 }{
           \Gamma \turns {\bf fix}~y. \lambda (x : \type_1) : \type_2 . e : \type_1 \rightarrow \type_2
} \\ \\

%%\multicolumn{2}{l}{\myruleform{\Theta; \Gamma_1 \turns \Gamma_2}} \\ \\
%%
%%(\texttt{F-Nothing}) & 
%%\myirule{
%% }{
%%            \epsilon; \Gamma \turns \Gamma 
%%} \\ \\

%%(\texttt{F-Just}) & 
%%\myirule{
%% }{
%%            (x : \type); \Gamma \turns \Gamma, (x :\type) 
%%} \\ \\


\ea

\eda
}

\figtwocol{f:syntax}{Closure F}{
\small
\bda{l}

\ba{llrl}
    \textbf{Types} & T & ::= & \alpha \mid \forall \Delta. T \\ 
    \textbf{Expressions} & E & ::=  & x \mid \lambda \Delta . E \mid E\;E \mid E\;T \mid {\bf fix} (x : \forall \Delta . T) . E
\ea
\\ \\

\ba{llrl} 
\textbf{Type Environments} & \Delta & ::= & \epsilon \mid \Delta
(\relation{x}{T}) \mid \Delta [ x : T ] \mid \Delta \alpha \\
%%\textbf{Fixpoint Environments} & \Theta & ::= & \epsilon \mid \relation{x}{\type} 
\ea 
\\ \\

\textbf{Type System}
\\ \\

\ba{lc}
\multicolumn{2}{l}{\myruleform{\Theta; \Delta \turns  \relation{E}{T}}} \\ \\

  (\texttt{C-Var}) & 
\myirule{
           (x : T) \in \Delta
 }{
            \Delta \turns x : T
} \\ \\

  (\texttt{C-RVar}) & 
\myirule{
           [x : T] \in \Delta
 }{
            \Delta \turns x : T
} \\ \\

  (\texttt{C-Abs}) & 
\myirule{
           \Delta_1 \uplus \Delta_2 \turns E : T
 }{
           \Delta_1 \turns \lambda \Delta_2.E : \forall \Delta_2. T
} \\ \\

  (\texttt{C-App}) & 
\myirule{
  \Delta_1 \turns E_1 : \forall (\relation{x}{T_2}) \Delta_2. T_1 ~~~~~~~
           \Delta_1 \turns E_2 : T_2 ~~~~~~~
           \Delta_2; T_1 \Downarrow T_3
          }{
           \Delta_1 \turns E_1 \, E_2 : T_3
} \\ \\

  (\texttt{C-TApp}) & 
\myirule{
  \Delta_1 \turns E : \forall \alpha \Delta_2. T_2  ~~~~~~~
           \Delta_2; T_2 \Downarrow T_3
           }{
            \Delta_1 \turns E \, T_1 : T_2[T_1/\alpha]
} \\ \\

  (\texttt{C-Fix}) & 
\myirule{
  \Delta_1 [x : \forall \Delta_2 . T] \turns \lambda \Delta_2 . E : \forall \Delta_2 . T  ~~~~~~~
           }{
            \Delta_1 \turns {\bf fix} (x : \forall \Delta_2 . T) . E : \forall \Delta_2 . T
} \\ \\

\multicolumn{2}{l}{\myruleform{\Delta; T_1 \Downarrow  T_2}} \\ \\

  (\texttt{D-Empty}) & 
\myirule{}{
           \epsilon; T \Downarrow T
} \\ \\

  (\texttt{D-NonEmpty}) & 
\myirule{}{
           \Delta; T \Downarrow \forall \Delta. T
} \\ \\

\ea

\eda
}


\figtwocol{f:syntax}{Syntax-Directed Translation from System F to
  Closure F}{
\small
\bda{l}
\ba{lc}
\multicolumn{2}{l}{\myruleform{e \leadsto  E}} \\ \\

  (\texttt{FC-Var}) & 
\myirule{}{
            x \leadsto x
} \\ \\

  (\texttt{FC-App}) & 
\myirule{
  e_1 \leadsto  E_1 ~~~~~~~~~~
           e_2 \leadsto E_2
          }{
           e_1 \, e_2 \leadsto E_1 \, E_2
} \\ \\

  (\texttt{FC-TApp}) & 
\myirule{
  e \leadsto E 
           }{
            e \, \type \leadsto E \, |T|
} \\ \\

  (\texttt{FC-Fix}) & 
\myirule{
  \epsilon \turns \lambda (x : \type_1) . e \leadsto \lambda \Delta . E \\
  T = adjust(\Delta,\type_2) 
           }{
            {\bf fix}~y . \lambda (x : \type_1) : \type_2 . e  \leadsto {\bf fix} (y : \forall \Delta . T) . E
} \\ \\

  (\texttt{FC-Rest}) & 
\myirule{
  \epsilon \turns e \leadsto E 
           }{
            e \leadsto E 
} \\ \\

\multicolumn{2}{l}{\myruleform{\Delta \turns e \leadsto  E}} \\ \\

  (\texttt{FC-Abs}) & 
\myirule{
           \Delta (x : |\type_1|) \turns e \leadsto E
 }{
           \Delta \turns \lambda x:\type_1.e \leadsto E
} \\ \\

  (\texttt{FC-TAbs}) & 
\myirule{
   \Delta \alpha \turns e \leadsto E
            }{
             \Delta \turns \Lambda \alpha.e \leadsto E 
} \\ \\

  (\texttt{FC-Rest2}) & 
\myirule{
  e \leadsto E 
           }{
            \Delta \turns e \leadsto \lambda \Delta. E 
} \\ \\

%%\multicolumn{2}{l}{\myruleform{\Delta \turns \type \leadsto  T}} \\ \\



\ea \\ \\

%%\ba{lcl}
%%|\alpha| & = & \alpha \\
%%|\tyint| & = & \tyint \\
%%|\type_1 \arrow \type_2| & = & |\rulet_1| \arrow |\rulet_2| \\
%%|\forall \alpha. \rulet| & = & \forall \alpha. |\rulet| \\
%%|\rulet_1 \iarrow \rulet_2| & = & |\rulet_1| \arrow |\rulet_2| %\\
%%\ea


\eda
}


\figtwocol{f:syntax}{Type-Directed Translation from Closure F to Java}{
\small
\bda{l}

\ba{lc}
\multicolumn{2}{l}{\myruleform{\Delta \turns  E : T \leadsto J \textbf{~in~} S}} \\ \\

  (\texttt{CJ-Var}) & 
\myirule{
           (x : T) \in \Delta
 }{
            \Delta \turns x : T \leadsto x.a \textbf{~in~} \{\}
} \\ \\

  (\texttt{CJ-RVar}) & 
\myirule{
           [x : T] \in \Delta
 }{
            \Delta \turns x : T \leadsto x \textbf{~in~} \{\}
} \\ \\

  (\texttt{CJ-Abs}) & 
\myirule{
           \epsilon ;\Delta_1 \uplus \Delta_2; \Delta_2 \turns E : T \leadsto J \textbf{~in~} S
 }{
           \Delta_1 \turns \lambda \Delta_2.E : \forall \Delta_2. T \leadsto J \textbf{~in~} S
} \\ \\


  (\texttt{CJ-App}) & 
\myirule{
  \Delta_1 \turns E_1 : \forall (\relation{x}{T_2}) \Delta_2. T_1
  \leadsto J_1 \textbf{~in~} S_1 ~~~~~~~
           \Delta_1 \turns E_2 : T_2 \leadsto J_2 \textbf{~in~} S_2 ~~~~~~~
           \Delta_2; T_1 \Downarrow T_3
          }{
           \Delta_1 \turns E_1 \, E_2 : T_3 \leadsto e_l\textbf{~in~}
           S_1 \uplus S_2 \uplus \{Closure~f = ((Closure)~J_1).clone(); f.a =
           J_2; f.apply(); T_3~e_l = f.out;\}
} \\ \\

  (\texttt{CJ-TApp}) & 
\myirule{
  \Delta_1 \turns E : \forall \alpha \Delta_2. T_2  \leadsto J
  \textbf{~in~} S ~~~~~~~
           \Delta_2; T_2 \Downarrow T_3 
           }{
            \Delta_1 \turns E \, T_1 : T_3[T_1/\alpha] \leadsto J
            \textbf{~in~} S
} \\ \\

  (\texttt{CJ-Fix}) & 
\myirule{
  [x : \forall \Delta_2 . T]; \Delta_1 [x : \forall \Delta_2 . T] \uplus \Delta_2; \Delta_2 \turns E : \forall \Delta_2 . T \leadsto J \textbf{~in~} S  ~~~~~~~
           }{
            \Delta_1 \turns {\bf fix} (x : \forall \Delta_2 . T) . E : \forall \Delta_2 . T \leadsto J \textbf{~in~} S
} \\ \\

\multicolumn{2}{l}{\myruleform{\Theta; \Delta_1; \Delta_2 \turns  E : T \leadsto J \textbf{~in~} S}} \\ \\

  (\texttt{CJD-Empty}) & 
\myirule{
           \Delta \turns \relation{E}{T} \leadsto  J \textbf{~in~} S
}{
           \Theta; \Delta; \epsilon \turns \relation{E}{T} \leadsto  J \textbf{~in~} S
} \\ \\

  (\texttt{CJD-Bind1}) & 
\myirule{
           %nolambda(\Delta_2) \\
           (x,E_2) = update(\Theta,y,E_1) \\
           \epsilon; \Delta_1; \Delta_2 \turns \relation{E_2}{T} \leadsto  J \textbf{~in~} S
}{
           \Theta_1; \Delta_1; (\relation{y}{T_1})\; \Delta_2 \turns
           \relation{E}{T} \leadsto  f \textbf{~in~} \{\\
              \textbf{class}~FUN~\textbf{extends}~Closure \{ \\
                   Closure~x = \textbf{this}; \\
                   \textbf{void}~apply() \{S; out = J;\} \\
                   \textbf{Closure}~clone() \{Closure~c = new~FUN(); c.x = \textbf{this}.x; c.apply(); \textbf{return}~c;\}                     
              \};\\
              Closure~f = new~FUN(); \}
} \\ \\

  (\texttt{CJD-Bind2}) & 
\myirule{
           \Theta; \Delta_1; \Delta_2 \turns \relation{E}{T} \leadsto  J \textbf{~in~} S
}{
           \Theta; \Delta_1; \alpha\; \Delta_2 \turns \relation{E}{T} \leadsto  J \textbf{~in~} S
} \\ \\

&
update(\epsilon,y,E) = (y,E) \\ &
update([x : \forall \Delta_2 . T],y,E) = (x, E[y \mapsto x])\\ \\

\ea


\eda


}


\figtwocol{f:syntax}{Optimized Type-Directed Translation from Closure
  F to Java (Different rules and additional rules only)}{
\small
\bda{l}

\ba{lc}

  (\texttt{CJ-App}) & 
\myirule{
  \Delta_1 \turns E_1 : \forall (\relation{x}{T_2}) \Delta_2. T_1
  \leadsto J_1 \textbf{~in~} S_1 ~~~~~~~
           \Delta_1 \turns E_2 : T_2 \leadsto J_2 \textbf{~in~} S_2~~~~~~~
           \Delta_2; f; T_1 \Downarrow T_3 \leadsto S_3
          }{
           \Delta_1 \turns E_1 \, E_2 : T_3 \leadsto f.out \textbf{~in~}
           S_1 \uplus S_2 \uplus \{Closure~f = ((Closure)~J_1).clone(); f.a =
           J_2;\} \uplus S_3
} \\ \\

  (\texttt{CJ-TApp}) & 
\myirule{
  \Delta_1 \turns E : \forall \alpha \Delta_2. T_2  \leadsto J
  \textbf{~in~} S_1 ~~~~~~~
           \Delta_2; J; T_2 \Downarrow T_3 \leadsto S_2 
           }{
            \Delta_1 \turns E \, T_1 : T_2[T_1/\alpha] \leadsto J
            \textbf{~in~} S_1 \uplus S_2
} \\ \\


  (\texttt{CJD-Bind1Closure}) & 
\myirule{
           \Delta_1; \Delta_2 \turns \relation{E}{T} \leadsto f_1 \textbf{~in~} S
}{
           \Delta_1; (\relation{x}{T_1})\; \Delta_2 \turns
           \relation{E}{T} \leadsto  f_2 \textbf{~in~} \{\\
              \textbf{class}~FUN~\textbf{extends}~Closure \{ \\
                   Closure~x = \textbf{this}; \\
                   \textbf{void}~apply() \{S; out = J;\} \\
                   \textbf{Closure}~clone() \{Closure~c = new~FUN(); c.x = \textbf{this}.x; c.apply(); \textbf{return}~c;\}                     
              \};\\
              Closure~f_2 = new~FUN(); \}
} \\ \\

  (\texttt{CJD-Bind1Other}) & 
\myirule{
           \Delta_1; \Delta_2 \turns \relation{E}{T} \leadsto  J \textbf{~in~} S
}{
           \Delta_1; (\relation{x}{T_1})\; \Delta_2 \turns
           \relation{E}{T} \leadsto  f \textbf{~in~} \{\\
              \textbf{class}~FUN~\textbf{extends}~Closure \{ \\
                   Closure~x = \textbf{this}; \\
                   \textbf{void}~apply() \{S; out = J;\} \\
                   \textbf{Closure}~clone() \{Closure~c = new~FUN(); c.x = \textbf{this}.x; c.apply(); \textbf{return}~c;\}                     
              \};\\
              Closure~f = new~FUN(); \}
} \\ \\


\multicolumn{2}{l}{\myruleform{\Delta; J; T_1 \Downarrow  T_2 \leadsto
  S}} \\ \\

  (\texttt{D-Empty}) & 
\myirule{}{
           \epsilon; J; T \Downarrow T \leadsto \{J.apply(); e_l = J.out;\} 
} \\ \\

  (\texttt{D-NonEmpty}) & 
\myirule{}{
           \Delta; J; T \Downarrow \forall \Delta. T \leadsto \{\}
} \\ \\

\ea

\eda
}

\figtwocol{f:syntax}{Tail Call Optimization when Translating from Closure
  F to Java (Different rules and additional rules only)}{
\small
\bda{l}

\ba{lc}

  (\texttt{CJ-App}) & 
\myirule{
  \Delta \turns E_1\; E_2 : T
  \leadsto J \textbf{~in~} S_1; \Sigma ~~~~~~~ \Sigma \downarrow S_2
          }{
           \Delta \turns E_1\; E_2 : T \leadsto J \textbf{~in~}
           S_1 \uplus S_2 
} \\ \\

\multicolumn{2}{l}{\myruleform{\Delta \turns  E : T \leadsto J
    \textbf{~in~} S; \Sigma}} \\ \\

  (\texttt{CJ-App-$\Sigma$}) & 
\myirule{
  \Delta_1 \turns E_1 : \forall (\relation{x}{T_2}) \Delta_2. T_1
  \leadsto J_1 \textbf{~in~} S_1; \Sigma_1 \\
           \Delta_1 \turns E_2 : T_2 \leadsto J_2 \textbf{~in~} S_2;
           \Sigma_2 \\
           \Delta_2; f; T_1 \Downarrow T_3 \leadsto S_3 
          }{
           \Delta_1 \turns E_1 \, E_2 : T_3 \leadsto f.out \textbf{~in~}
           S_1 \uplus S_2; \Sigma_1 \uplus \Sigma_2; \{Closure~f = (Closure)~J_1; f.a =
           J_2;\}; S_3
} \\ \\

 (\texttt{CJ-Rest-$\Sigma$}) & 
\myirule{\Delta \turns E : T \leadsto J \textbf{~in~}
           S 
          }{
           \Delta \turns E : T \leadsto J \textbf{~in~}
           S; \epsilon
} \\ \\

\multicolumn{2}{l}{\myruleform{\Sigma \downarrow  S}} \\ \\

  (\texttt{$\Sigma$-Empty}) & 
\myirule{}{
           \epsilon \downarrow \{\}
} \\ \\

  (\texttt{$\Sigma$-One}) & 
\myirule{}{
           \epsilon; S_1; S_2 \downarrow S_1 \uplus S_2
} \\ \\

  (\texttt{$\Sigma$-Many1}) & 
\myirule{
          \Sigma \downarrow S_3
}{
           \Sigma; S_1; \{\} \downarrow S_1 \uplus S_3
} \\ \\

  (\texttt{$\Sigma$-Many2}) & 
\myirule{
          \Sigma \downarrow S_3
}{
           \Sigma; S_1; S_2 \downarrow S_1 \uplus \{Stack.push({\bf new}~
           Closure()\{{\bf void}~apply() \{S_3\}\});\} \uplus S_2
} \\ \\

\multicolumn{2}{l}{\myruleform{\Delta; J; T_1 \Downarrow  T_2 \leadsto
  S}} \\ \\

  (\texttt{D-Empty}) & 
\myirule{}{
           \epsilon; J; T \Downarrow T \leadsto \{Stack.push(J);\}
} \\ \\

  (\texttt{D-NonEmpty}) & 
\myirule{}{
           \Delta; J; T \Downarrow \forall \Delta. T \leadsto \{\}
} \\ \\

\ea

\eda
}

\figtwocol{f:syntax}{Unboxing Translation Rules from Closure F to Java}{
\small
\bda{l}

\ba{lc}

  (\texttt{CJ-UnboxAux1}) & 
\myirule{
           T_1 \Downarrow Int ~~~~~~~ T_2 \Downarrow Int
 }{
            T_1;T_2 \Downarrow ClosureIntInt
} \\ \\

  (\texttt{CJ-UnboxAux2}) & 
\myirule{
           T_1 \Downarrow Int
 }{
            T_1;T_2 \Downarrow ClosureIntA
} \\ \\

  (\texttt{CJ-UnboxAux3}) & 
\myirule{
           T_2 \Downarrow Int
 }{
            T_1;T_2 \Downarrow ClosureAInt
} \\ \\

  (\texttt{CJ-UnboxAux0}) & 
\myirule{}{
            T_1;T_2 \Downarrow Closure
} \\ \\


  (\texttt{CJ-TAppEnv}) & 
\myirule{
  \Delta_1, \Omega_1 \turns E : \forall \alpha \Delta_2. T_2  \leadsto J
  \textbf{~in~} S_1, \Omega_1' ~~~~~~~
           \Delta_2; J; T_2 \Downarrow T_3 \leadsto S_2 
           }{
            \Delta_1, \Omega_1 \turns E \, T_1 : T_2\leadsto J
            \textbf{~in~} S_1 \uplus S_2, \Omega_1' \cup \{ T_1 \mapsto \alpha \}
} \\ \\

  (\texttt{CJ-WrapFun}) & 
\myirule{
           \Delta_1, \Omega, T_2 \turns T_2 \Omega \Downarrow \forall (\relation{x}{T_{A}}) \Delta_2. T_{B}   \\
           T_{A};T_{b} \Downarrow CT \in \{ClosureIntInt, ClosureIntA, ClosureAInt\} \\
           \Delta_1, \Omega \turns E_2 : (T_2 \Omega)~~~~~~~\\
           \Delta_1, \Omega_1 \turns E_1 : \forall (\relation{x}{T_{2P}}) \Delta_2. T_1
 ~~~~~~~\\
           T_2 \Omega \neq T_{2P} ~~~~~~~
          }{
           \Delta_1, \Omega \turns (E_2 : T_{2P})\Omega  \leadsto new~Closure \{\\
              \textbf{void}~apply() \{\\
                exp2.a = (T_{A})~wrappedf.a;\\
                exp2.apply();\\
                wrappedf.out = exp2.out;
              \}
           \};
} \\ \\

  (\texttt{CJ-WrapId}) & 
\myirule{
           \Delta_1, \Omega \turns E_1 : \forall (\relation{x}{T_{2P}}) \Delta_2. T_1
   }{
            \Delta_1, \Omega \turns (E_2 : T_{2P})\Omega  \leadsto exp2
} \\ \\

  (\texttt{CJ-Unbox}) & 
\myirule{
       \Delta_1, \Omega_1 \turns E_1 : \forall (\relation{x}{T_2}) \Delta_2. T_1 \leadsto J_1 \textbf{~in~} S_1, \Omega_1' ~~~~~~~ T_1;T_2 \Downarrow CT1\\
       \Delta_1, \Omega_2 \turns E_2 : T_{2P} \leadsto J_2 \textbf{~in~} S_2, \Omega_2' ~~~~~~~\Omega = \Omega_1' \cup \Omega_2'\\
       T_{2P} \Downarrow T_{2P}' \turns TX = T_{2P}' \Omega~~~~~~~\\\Delta_1, \Omega \turns (E_2 : T_{2}) \Omega \leadsto WRAP~~~~~~~\\
       \Delta_2; f; T_1 \Downarrow T_3 \leadsto S_3
          }{
           \Delta_1, \Omega_1 \turns E_1 \, E_2 : T_{3} \Omega \leadsto f.out \textbf{~in~}
           S_1 \uplus S_2 \uplus \{CT1~f = (CT1)~J_1; \\
           TX exp2 = (TX) J_2; \\
           T_2 exp2wrap = (T_2) WRAP; \\
           f.a = exp2wrap; f.apply();\} \uplus S_3, \Omega
} \\ \\

  (\texttt{*}) & 

            {All~other~rules~preserve~\Omega}
 \\ \\

\ea

\eda
}


