A Calculus with Very Late Binding



Syntax:

Types s, t, u ::= B | t_1 -> t_2 | /\{ t }
Terms e, f, g ::= b | x | \x. e | e_1 e_2 | ,,{ e }
Values v      ::= b | \x. e | ,,{ v }

B          Base types
b          Literals of base types
[e/x] f    Capture-avoiding substitution of e for x in f

Remarks.

1. Singleton types and terms are regarded as unary-intersection of sets (order
is therefore irrelevant). For example, t_1 -> t_2 is regarded as /\{ t_1 ->
t_2 }.

2. Sets of sets, sets of sets of sets, ad infinitum, are regarded as
"flattened" "level-1" sets. For example, /\{{ Int }, Nat } is equivalent to
/\{ Int, Nat }.



Subtyping: t_1 <: t_2

(arr)
s_2 <: s_1    t_1 <: t_2
------------------------
s_1 -> t_1 <: s_2 -> t_2

(set)
forall t in { t_1, ..., t_n }.
  there exists s in { s_1, ..., s_m }.
  s <: t
------------------------------------------
/\{ s_1, ..., s_m } <: /\{ t_1, ..., t_n }

Examples:
In the following let us assume Nat <: Int.

(1) /\{ Int } <: /\{ Int } true
(2) (adding types on the *right* may break subtying)
    /\{ Int } <: /\{ Int, Nat } false
(3) (adding types on the *left* always preserves subtyping)
    /\{ Int, Nat } <: /\{ Int } true

Lemma. If s <: t, then for any type u, /\{ s, u } <: t.



Dynamics (call-by-value): e_1 --> e_2

Before we proceed, let us define the <:/= relation which will be used in the following.

Definition (proper subtyping). s <:/= t if s <: t but not t <: s.

(beta)
,,{ \x. e_1 : s_1 -> t_1, ..., \x. e_n : s_n -> t_n, ... (non-function values) ... } (v : t)
-->
,,{ [v `filter` s_j/x] e_j : t_j | j in J }
  where
    (conformance) I = { i | t <: t_i }
    (minimality)  J = { j | not (there exists i. i, j in I and i /= j and t_i <:/= t_j) }

Remark.
1. Conformance describes the functions that can accept the argument v.
2. Minimality describes the functions that can accept the argument v and has the most "precise" parameter types.
3. Reduction gets stuck if J is empty.

Lemma. I is nonempty if and only if J is.



"Filter":
,,{ e_1 : t_1, ..., e_n : t_n } `filter` t = { e_i : t_i | t_i <: t }



Metatheory:

Theorem (economy). If e is a program that is accepted both in a conventional
overloading calculus (such as Castagna's lambda&) and in this calculus, then
each time the (beta) rule is applied, no more than one function is actually
invoked.

Proof sketch.
We illustrate by considering the case of binary merges.

Assume
  f : s_1 -> s_2
  g : t_1 -> t_2
and consider the program p
p = (f ,, g) (e : u)

If both f and g are invoked in the (beta) rule, then J = { 1, 2 }.
Furthermore, I = J = { 1, 2 } since I is a superset of J. By the definition of
I (conformance), u <: s_1 and u <: t_1, which violates lambda&'s well-
formedness condition of types. Therefore, p is not accepted in lambda&.



Examples of the dynamics.

(1)

,,{ \x. 1 : Int -> Int, \x. True : Int -> Bool } (0 : Int)
-->
,,{ 1, True }

(2)

,,{ \x. 1 : Int -> Int, \x. 2 : Bool -> Int } (0 : Int)
-->
1

(3)

,,{ \x. 1 : Int -> Int, \x. 2 : Nat -> Int } (0 : Nat)
-->
2

Explanation:
/\{ Int -> Int, Nat -> Int }
Let us order the two types from left to right by 1 and 2.
Then in terms of the (beta) rule,
I = { 1, 2 }
J = { 2 }
Note that 1 is not in J since Nat <:/= Int.