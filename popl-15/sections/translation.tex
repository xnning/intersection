\section{Type-directed Translation to System $ F $}

In this section we define the dynamic semantics of the call-by-value \name by
means of a type-directed translation to a variant of System $F$. This
translation turns merges into usual pairs, similar to Dunfield's elaboration
approach~\cite{dunfield2014elaborating}. But in addition, our translation
removes labels of records and rewrites record operations as function
applications. In the end the translated expressions can be typed and interpreted
within System $F$. We add the blue-color part to our rules presented in the
previous section. Besides that, they stay the same. We also tacitly assume the
variables introduced in the blue part are generated from a unique name supply and
are always fresh.

\subsection{Informal Discussion}

This subsection presents the translation informally by explaining the major
ideas.

\paragraph{Turning merges into pairs.}
The first idea is turning merges into pairs. For example,
\[
1 \mergeOp \code{"one"}
\]
becomes \pair 1 {\code{"one"}}.
In usage, the pair will be coerced according to type information. For example,
consider the function application:
\[
\app {(\lam x \tystring x)} {(1 \mergeOp \code{"one"})}
\]
It will be translated to
\[
\app {(\lam x \tystring x)} {(\app {(\lam x {\pair \tyint \tystring} {\proj 2 x})} {\pair 1 {\code{"one"}}})}
\]
The coercion in this case is $(\lam x {\pair \tyint \tystring} {\proj 2 x})$.

\noindent It extracts the second item from the pair since the function expects a $\tystring$
but the translated argument is of type $\pair \tyint \tystring$.

\paragraph{Erasing labels.}
The second idea is erasing record labels. For example,
\begin{lstlisting}
{name = "Barbara"}
\end{lstlisting}
becomes just \lstinline{"Barbara"}.
To see how the this and the previous idea are used together, consider the following program:
\begin{lstlisting}
{distance = {inKilometers = 8, inMiles = 5}}
\end{lstlisting}
Since multi-field records are just merges, the record is desugared as
\begin{lstlisting}
{distance = {inKilometers = 8} ,, {inMiles = 5}}
\end{lstlisting}
and then translated to \lstinline{(8,5)}.

\paragraph{Record operations as functions.}
The third idea is translating record operations into normal functions. For
example, the source program
\begin{lstlisting}
{distance = {inKilometers = 8, inMiles = 5}}.distance.inMiles
\end{lstlisting}
becomes an \name expression
\[
\app {(\lam x {\pair \tyint \tyint} {\proj 2 x})} {\pair 8 5}
\]
where $\lam x {\pair \tyint \tyint} {\proj 2 x}$
extracts the desired item $5$.

\subsection{Target Language}

Our target language is System $F$ extended with pair and unit types. The syntax
and typing is completely standard. The syntax of the target language is shown in
Figure~\ref{fig:f-syntax} and the typing rules in the appendix.
% \bruno{fill!}
\begin{figure}[h]
  \input{rule_in_figures/f-syntax.tex}
  \caption{Target language syntax.}
  \label{fig:f-syntax}
\end{figure}

% \bruno{Why is this lemma placed here?}
% \bruno{Generaly Speaking this text seems out of place.Move to 5.4, maybe?}

% The main translation judgment is $ \hastype \gamma e \tau \yields E $ which
% states that with respect to the typing context $ \gamma $, the \name expression
% $e$ is of $\tau$ and its translation is a target expression $ E $.

\subsection{Type Translation}

\begin{figure}[h]
  \input{rule_in_figures/type-translation.tex}
  \input{rule_in_figures/context-translation.tex}
  \caption{Type and context translation.}
  \label{fig:type-and-context-translation}
\end{figure}

Figure~\ref{fig:type-and-context-translation} defines the type translation
function $\im \cdot$ from \name types $\tau$ to target language types $T$. The
notation $\im \cdot$ is also overloaded for context translation from \name
contexts $\gamma$ to target language contexts $\Gamma$.

% The rules given in this section are identical with those in
% Section~\ref{sec:fi}, except for the light blue part. The translation consists
% of four sets of rules, which are explained below:

\subsection{Coercive Subtyping}

Figure~\todo{fig:elab-subtyping} shows subtyping with coercions. The judgment
\[
\tau_1 \subtype \tau_2 \yields C
\]
extends the subtyping judgment in Figure~\ref{fig:fi-subtyping} with a coercion
on the right hand side of $ \yields {} $. A coercion $ C $ is just an expression
in the target language and is ensured to have type
$ \im {\tau_1} \to \im {\tau_2} $ (Lemma~\ref{lemma:sub})\bruno{ref
  now showing}. For example,
\[
\tyint \intersect \tybool \subtype \tybool \yields {\lam x {\im {\tyint \intersect \tybool}} {\proj 2 x}}
\]

\noindent generates a coercion function from $\tyint \intersect \tybool$ to $\tybool$.

In rules \rulelabel{SubVar}, \rulelabel{SubTop}, \rulelabel{SubForall},
coercions are just identity functions. In \rulelabel{SubFun}, we elaborate the
subtyping of parameter and return types by $\eta$-expanding $f$ to
$\lam x {\im {\tau_3}} {\app f x}$, applying $C_1$ to the argument and $C_2$ to
the result. Rules \rulelabel{SubAnd1}, \rulelabel{SubAnd2}, and
\rulelabel{SubAnd} elaborate with intersection types. \rulelabel{SubAnd} uses
both coercions to form a pair. Rules \rulelabel{SubAnd1} and
\rulelabel{SubAnd2} reuse the coercion from the premises and create new ones
that cater to the changes of the argument type in the conclusions. Note that the
two rules are syntatically the same and hence a program can be elaborated
differently, depending on which rule is used. But in the implementation one
usually applies the rules sequentially with pattern matching, essentially
defining a deterministic order of lookup.
\begin{comment}
if we know $\tau_1$ is a subtype of $\tau_3$ and $C$ is a coercion from $\tau_1$
to $\tau_3$, then we can conclude that $\tau_1 \intersect \tau_2$ is also a subtype
of $\tau_3$ and the new coercion is a function that takes a value $ x $ of type
$\tau_1\intersect \tau_2$, project $x$ on the first item, and apply $ C $ to it.
\end{comment}

\begin{restatable}[Subtyping rules produce type-correct coercion]{lemma}{lemmasub}
  \label{lemma:sub}
  If $ \tau_1 \subtype \tau_2 \yields C $, then $ \judgeTarget \epsilon C {\im {\tau_1} \to \im {\tau_2}} $.
\end{restatable}

\begin{proof}
  By a straighforward induction on the derivation\footnote{The proofs of major lemmata and theorems can be found in the appendix.}.
\end{proof}

\subsection{Main Translation}

\begin{comment}
In this subsection we now present formally the translation rules that convert
\name expressions into System $ F $ ones. This set of rules essentially extends
those in the previous section with the light-blue part for the translation.
\end{comment}

% \bruno{Badly structured. Don't mention Coercion here, as it was already
% explained in the previous section.}
% \bruno{Don't use itemize and items. Use paragraphs instead!}

\paragraph{Main translation judgment.} The main translation judgment
$\hastype \gamma e \tau \yields E$ extends the typing judgment with an elaborated
expression on the right hand side of $\yields {}$. The translation ensures
that $E$ has type $\im \tau$. In \name, one may pass more information to a
function than what is required; but not in System $F$. To account for this
difference, in \rulelabel{App}, the coercion $C$ from the subtyping relation is
applied to the argument. \rulelabel{Merge} straighforwardly translates merges
into pairs.

% Consider the source program:
% \begin{lstlisting}
%   ({ name = "Isaac", age = 10 }).name
% \end{lstlisting}

%   Multi-field records are desugared into merge of single-field records:
%   \begin{lstlisting}
%     ({ name = "Isaac"} ,, { age = 10 }).name
%   \end{lstlisting}

%   By $ \ruleLabelSelect $,
%   \[ \turnsGet (\recordType {name} {String}; {name}) : String \]

%   we have the coercion
%   \[ \lam x {\im {\recordType {name} {String}}} x \]

%   which is just $ \lam x {String} x $ according to type translation.

%   By $ \ruleLabelSelectLeft $,
%   \[ \turnsGet (\recordType {name} {String} \intersect \recordType {age} {Int}; {name}) : String \]

%   % we have the coercion
%   % \[ \abs {\rel x {\im {\recordType {name} {String} \intersect \recordType
%   %         {age} {Int}}}} \app {(\abs {\rel x {\im {\recordType {name} {String}}}} x)} {(\fst ~ x)} \]
%   % which is just $ \abs {\rel x {(String, Int)}} {\app {(\abs {\rel x {String}} x)} {(\fst ~ x)}} $ by type translation.

%   By typing rules, the translation of the program is
%   \[ ("Isaac", 10) \]. If we apply the coercion to it, we get
%   \[ "Isaac" \]

\begin{restatable}[Translation preserves well-typing]{theorem}{theorempreservation}
  \label{theorem:preservation}
  If $ \hastype \gamma e \tau \yields E $,
  then $ \judgeTarget {\im \gamma} E {\im \tau} $.
\end{restatable}
\begin{proof}
(Sketch) By structural induction on the expression and the corresponding
inference rule.
\end{proof}

\begin{theorem}[Type safety]
  If $e$ is a well-typed \name expression, then $e$ evaluates to some System $F$
  value $v$.
\end{theorem}
\begin{proof}
  Since we define the dynamic semantics of \name in terms of the composition of
  the type-directed translation and the dynamic semantics of System $F$, type safety follows immediately.
\end{proof}
