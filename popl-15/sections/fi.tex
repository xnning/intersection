\section{The \name calculus} \label{sec:fi}

This section presents the syntax, subtyping, and typing of \name, as well as the
additional judgements that are special in \name. The semantics of \name will be
defined by a type-directed translation to a simple variant of System $F$ in the
next section.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} shows the syntax of \name (with the addition to
System $F$ highlighted).
% As a convention in this paper, we will be using
% lowercase letters as meta-variables for sorts in \name, and uppercase letters
% for those in the target language.

% To System $ F $, we add two features: intersection types and single-field
% records.
% % ~\bruno{labelled types (single field records are fine too)}
% We include only single records because single record types as the multi-records
% can be desugared into the merge of multiple single records.

\begin{figure}
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B & \Coloneqq & \alpha                  & \\
        &      & \mid & \bot                         & \\
        &      & \mid & A \to B                      & \\
        &      & \mid & \for {\alpha \disjoint B} A  & \\
        &      & \mid & A \inter B               & \\

        \\
        \text{Terms}
        & e & \Coloneqq & x                        & \\
        &   & \mid & \lam x A e                    & \\
        &   & \mid & \app {e_1} {e_2}              & \\
        &   & \mid & \blam {\alpha \disjoint A} e  & \\
        &   & \mid & \tapp e A                     & \\
        &   & \mid & e_1 \mergeOp e_2              & \\

        \\
        \text{Contexts}
        & \Gamma & \Coloneqq & \cdot
                   \mid \Gamma, \alpha \disjoint A
                   \mid \Gamma, x \hast A  & \\

        \text{Syntactic sugar} & \blam {\alpha} e & \equiv & \blam {\alpha \disjoint \bot} e & \\
      \end{array}
    \end{array}
  \]

  \label{fig:fi-syntax}
  \caption{Syntax.}
\end{figure}

% \bruno{I am not sure if the highlighting will be
%   visible. Use gray?}\bruno{there is no \lstinline{with} anymore.
% Make sure the syntax is consistent with what is presented in the type rules!}

Meta-variables $A$, $B$ range over types. Types include System $F$ constructs:
type variables $\alpha$; function types $A \to B$; and type
abstraction $\for \alpha A$. The bottom type $\bot$ is not inhabited by any
term. $A \inter B$ denotes the intersection of types $A$ and
$B$. We omit type constants such as $\tyint$ and $\tystring$.

Terms include standard constructs in System $F$: variables $x$; abstraction of
terms over variables of a given type $\lam x A e$; application of terms to
terms $\app {e_1} {e_2}$; and application of terms to types $\tapp e A$.
``Big lambdas'' $\blam {\alpha \disjoint A} e$ abstracts a type variable
$\alpha$ over a term $e$ and constraints the instantiation of $\alpha$ to be
disjoint with a given type $A$. $e_1 \mergeOp e_2$ is the \emph{merge} of two
terms $e_1$ and $e_2$. It can be used as either $ e_1 $ or $ e_2 $. In
particular, if one regards $e_1$ and $e_2$ as objects, their merge will respond
to every method that one or both of them have. Merge of terms correspond to
intersection types $A \inter B$.

% Note that $ e $ does not
% need to be a record type in this case. For example, although the merge of two
% records
% \[
% x = \recordCon {l_1} {e_1} \mergeOp \recordCon {l_1} {e_2}
% \]
% is of an intersection type, $ x.{l_1} $ still gives $ e_1 $. On the other hand,
% $ x.{l_3} $ will be rejected by the type system.

In order to focus on the most essential features, we do not include other forms
such as fixpoints here, although they are supported in our implementation and
can be included in formalization in standard ways.

Typing contexts $ \Gamma $ track bound type variables with their disjointness
constraint, and variables with their type $A$. We use use $\subst {A} \alpha
{B}$ for the capture-avoiding substitution of $A$ for $\alpha$ inside $B$ and
$\ftv \cdot$ for sets of free variables.

% \paragraph{Discussion.} A natural question the reader might ask is that why we
% have excluded union types from the language. The answer is we found that
% intersection types alone are enough support extensible designs. To focus on the
% key features that make this language interesting, we also omit other common
% constructs. For example, fixpoints can be added in standard ways.
% Dunfield has described a language that includes a ``top'' type but it does not
% appear in our language. Our work differs from Dunfield in that ...

\subsection{Subtyping}

% In some calculi, the subtyping relation is external to the language: those
% calculi are indifferent to how the subtyping relation is defined. In \name, we
% take a syntatic approach, that is, subtyping is due to the syntax of types.
% However, this approach does not preclude integrating other forms of subtyping
% into our system. One is ``primitive'' subtyping relations such as natural
% numbers being a subtype of integers. The other is nominal subtyping relations
% that are explicitly declared by the programmer.

\begin{figure*}
  \begin{mathpar}
    \framebox{$ A \subtype B \yields F $} \\

    \subVar

    \subFun

    \subForall

    \subAnd

    \subAndleft

    \subAndright
  \end{mathpar}

  \footnote{miss a rule for $\bot$}

  \caption{Subtyping in \name.}
  \label{fig:fi-subtyping}
\end{figure*}

The subtyping rules of \name, shown in Figure~\ref{fig:fi-subtyping}, are
syntax-directed (different from the approach by Davies and
Pfenning~\cite{davies2000intersection}, and Frisch et.
al~\cite{frisch2008semantic}). The rule \rulelabel{SubFun} says that a function
is contravariant in its parameter type and covariant in its return type. A
universal quantifier ($\forall$) is covariant in its body. The three rules
dealing with intersection types are just what one would expect when interpreting
types as sets. Under this interpretation, for example, the rule
\rulelabel{SubAnd} says that if $A_1$ is both the subset of $A_2$ and the
subset of $A_3$, then $A_1$ is also the subset of the intersection of
$A_2$ and $A_3$. In order to achieve coherence, \rulelabel{SubAnd1} and
\rulelabel{SubAnd2} additionally require the type on the right-hand side is
atomic.

% Intersection types introduce natural subtyping relations among types. For
% example, $ \tyint \inter \tybool $ should be a subtype of $ \tyint $, since the former
% can be viewed as either $ \tyint $ or $ \tybool $. To summarize, the subtyping rules
% are standard except for three points listed below:
% \begin{enumerate}
% \item $ A_1 \inter A_2 $ is a subtype of $ A_3 $, if \emph{either} $ A_1 $ or
%   $ A_2 $ are subtypes of $ A_3 $,

% \item $ A_1 $ is a subtype of $ A_2 \inter A_3 $, if $ A_1 $ is a subtype of
%   both $ A_2 $ and $ A_3 $.

% \item $ \recordType {l_1} {A_1} $ is a subtype of $ \recordType {l_2} {A_2} $, if
%   $ l_1 $ and $ l_2 $ are identical and $ A_1 $ is a subtype of $ A_2 $.
% \end{enumerate}
% The first point is captured by two rules $ \rulelabelsubAndLeft $ and
% $ \rulelabelsubAndRight $, whereas the second point by $ \rulelabelsubAnd $.
% Note that the last point means that record types are covariant in the type of
% the fields.

It is easy to see that subtyping is reflexive and transitive.

\begin{lemma}[Subtyping is reflexive] \label{sub-refl}
Given a type $ A $, $ A \subtype A $.
\end{lemma}

\begin{lemma}[Subtyping is transitive] \label{sub-trans}
If $ A_1 \subtype A_2 $ and $ A_2 \subtype A_3 $,
then $ A_1 \subtype A_3 $.
\end{lemma}

For the corresponding mechanized proofs in Coq, we refer to the supplementary
materials submitted with the paper.

\subsection{Disjointness and well-formedness}

\begin{figure}
  \begin{mathpar}
    \framebox{$ \isdisjoint \Gamma A B$} \\

    \disjointvar

% \inferrule* [right=DisjointSym]
%       {\alpha * A \in \Gamma}
%       {\isdisjoint \Gamma A \alpha}

    \disjointinterleft

    \disjointinterright

    \disjointfun

    \disjointforall

    \disjointatomic

\framebox{$ A \not\sim B$} \\

\inferrule* [right=NotSimBot1]
      {}
      {\bot \not\sim A \to B}

\inferrule* [right=NotSimBot2]
      {}
      {\bot \not\sim \for {\alpha * B} A}

\inferrule* [right=NotSimFunForall]
      {}
      {A \to B \not\sim \for {\alpha * B} A}

\inferrule* [right=NotSimFunForall]
      {B \not\sim A}
      {A \not\sim B}

  \end{mathpar}

  \label{fig:disjointness}
  \caption{Disjointness.}
\end{figure}

The rules for the disjointness judgement are shown in
Figure~\ref{fig:disjointness}. The judgement says two types $A$ and $B$ are
disjoint in a context $\Gamma$. Two atomic types with different shapes (except
for the variable) are considered disjoint, which is factored out to the atomic
disjointness rules. The \rulelabel{DisjointInter1} and
\rulelabel{DisjointInter2} inductively distribute the relation itself over the
intersection constructor ($\inter$). \rulelabel{DisjointFun} is quite
interesting, because it says two function types are disjoint as long as their
return types are disjoint (regardless of their parameter types).

\begin{figure}
  \begin{mathpar}
    \framebox{$\istype \Gamma A$} \\

    \wfvar

    \wfbot

    \wffun

    \wfforall

    \wfinter
  \end{mathpar}

  \label{fig:wf}
  \caption{Well-formed types.}
\end{figure}

The well-formedness of types is standard except that the two components of an
intersection type must be disjoint.

\subsection{Typing}

\begin{figure*}
  \begin{mathpar}
    \framebox{$ \hastype \Gamma e A \yields E $} \\

    \tyvar

    \tylam

    \tyapp

    \tyblam

    \tytapp

    \tymerge

  \end{mathpar}

  \caption{The type system of \name.}
  \label{fig:fi-typing}
\end{figure*}

The syntax-directed typing rules of \name are shown in
Figure~\ref{fig:fi-typing}. They consist of one main typing judgment and two
auxiliary judgments. The main typing judgment is of the form: $ \hastype \Gamma
e A $. It reads: ``in the typing context $\Gamma$, the term $e$ is of type
$A$''. The rules that are the same as in System $F$ are rules for variables
(\rulelabel{Var}), lambda abstractions (\rulelabel{Lam}), and type applications
(\rulelabel{TApp}). For the ease of discussion, in \rulelabel{BLam}, we require
the type variable introduced by the quantifier is fresh. For programs with type
variable shadowing, this requirement can be met straighforwardly by variable
renaming. The rule \rulelabel{App} needs special attention as we add a subtyping
requirement: the type of the argument ($A_3$) is a subtype of that of the
parameter ($A_1$).
%The advantage is that it then
%becomes easier to derive an algorithm for typechecking.
For merges $e_1 \mergeOp e_2$, we typecheck $e_1$ and $e_2$, check that the two
resulting types are disjoint, and give it the intersection of the resulting
types.

% The last two rules make use of the $ \rulename{fields} $ function just to make
% sure that the field being accessed ($ \rulelabelRecSelect $) or updated
% ($ \rulelabelRecUpd $) actually exists. The function is defined recursively, in
% Haskell pseudocode, as:
% \[ \begin{array}{rll}
%   \fields{\alpha} & = & \rel{\cdot} {\alpha} \\
%   \fields{A_1 \to A_2} & = & \rel{\cdot} {A_1 \to A_2} \\
%   \fields{\forall \alpha. A} & = & \rel{\cdot} {\forall \alpha. A} \\
%   \fields{A_1 \inter A_2} & = & \fields{A_1} \dplus \fields{A_2} \\
%   \fields{\recordType l A} & = & \rel l t
% \end{array} \]
% where $ \cdot $ means empty list, $ \dplus $ list concatenation, and $ : $ is an
% infix operator that prepend the first argument to the second. The function
% returns an associative list whose domain is field labels and range types.
