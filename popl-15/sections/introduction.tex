\section{Introduction}

There has been a remarkable number of works aimed at improving support
for extensibility in programming languages. The motivation behind this
line of work is simple, and it is captured quite elegantly by the
infamous \emph{Expression Problem~}\cite{wadler1998expression}: there
are \emph{two} common and desirable forms of extensibility, but most
mainstream languages can only support one form well. Unfortunately
the lack of support in the other form has significant
consequences in terms of code maintenance and software evolution.  As a
result researchers proposed various approaches to address the problem,
including: visions of new programming
models~\cite{Prehofer97,Tarr99ndegrees,Harrison93subject}; new
programming languages or language
extensions~\cite{McDirmid01Jiazzi,Aracic06CaesarJ,Smaragdakis98mixin,nystrom2006j},
and \emph{design patterns} that can be used with existing mainstream
languages~\cite{togersen:2004,Zenger-Odersky2005,oliveira09modular,oliveira2012extensibility}.

Some of the more recent work on extensibility is focused on design
patterns. Examples include \emph{Object
  Algebras}~\cite{oliveira2012extensibility}, \emph{Modular Visitors}~\cite{oliveira09modular,togersen:2004} or
Torgersen's~\cite{togersen:2004} four design patterns using generics. In those
approaches the idea is to use some advanced (but already available)
features, such as \emph{generics}~\cite{Bracha98making}, in combination with conventional
OOP features to model more extensible designs.  Those designs work in
modern OOP languages such as Java, C\#, or Scala.

Although such design patterns give practical benefits in terms of
extensibility, they also expose limitations in existing mainstream OOP
languages. In particular there are three pressing limitations:
1) lack of good mechanisms for
  \emph{object-level} composition; 2) \emph{conflation of
    (type) inheritance with subtyping}; 3) \emph{heavy reliance on generics}.

  The first limitation shows up, for example, in encodings of Feature-Oriented
  Programming~\cite{Prehofer97} or Attribute Grammars~\cite{Knuth1968} using Object
  Algebras~\cite{oliveira2013feature,rendel14attributes}. These programs are best
  expressed using a form of \emph{type-safe}, \emph{dynamic},
  \emph{delegation}-based composition. Although such form of
  composition can be encoded in languages like Scala, it requires the
  use of low-level reflection techniques, such as dynamic proxies,
  reflection or other forms of meta-programming. It is clear
  that better language support would be desirable.

  The second limitation shows up in designs for modelling
  modular or extensible visitors~\cite{togersen:2004,oliveira09modular}.  The vast majority of modern
  OOP languages combines type inheritance and subtyping.
  That is, a type extension induces a subtype. However
  as Cook et al.~\cite{cook1989inheritance} famously argued there are programs where
  ``\emph{subtyping is not inheritance}''. Interestingly
  not many programs have been previously reported in the literature
  where the distinction between subtyping and inheritance is
  relevant in practice. However, as shown in this paper, it turns out that this
  difference does show up in practice when designing modular
  (extensible) visitors.  We believe that modular visitors provide a
  compelling example where inheritance and subtyping should
  not be conflated!

  Finally, the third limitation is prevalent in many extensible
  designs~\cite{togersen:2004,Zenger-Odersky2005,oliveira09modular,oliveira2013feature,rendel14attributes}.
  Such designs rely on advanced features of generics,
  such as \emph{F-bounded polymorphism}~\cite{Canning89f-bounded}, \emph{variance
    annotations}~\cite{Igarashi06variant}, \emph{wildcards}~\cite{Torgersen04wildcards} and/or \emph{higher-kinded
    types}~\cite{Moors08generics} to achieve type-safety. Sadly, the amount of
  type-annotations, combined with the lack of understanding of these
  features, usually deters programmers from using such designs.

\begin{comment}
Motivated by the insights gained in previous work, this paper presents
a minimal core calculus that addresses current limitations and
provides a better foundational model for statically typed
delegation-based OOP? We show that Object Algebras fit nicely in this
model.
\end{comment}

This paper presents System \name (pronounced \emph{f-and}): an extension of System F~\cite{Reynolds74f}
with intersection types and a merge operator~\cite{dunfield2014elaborating}.  The goal of
System \name is to study the \emph{minimal} foundational language
constructs that are needed to support various extensible designs,
while at the same time addressing the limitations of existing OOP
languages. To address the lack of good object-level composition
mechanisms, System \name uses the merge operator for dynamic
composition of values/objects. Moreover, in System \name (type-level)
extension is independent of subtyping, and it is possible for an
extension to be a supertype of a base object type. Furthermore,
intersection types and conventional subtyping can be used in many
cases instead of advanced features of generics. Indeed this paper
shows many previous designs in the literature can be encoded
without such advanced features of generics.


Technically speaking System \name is mainly inspired by the work of
Dundfield~\cite{dunfield2014elaborating}.  Dundfield showed how to model a simply typed
calculus with intersection types and a merge operator. The presence of
a merge operator adds significant expressiveness to the language,
allowing encodings for many other language constructs as syntactic
sugar. System \name differs from Dundfield's work in a few
ways. Firstly, it adds parametric polymorphism and formalizes an
extension for records to support a basic form of objects. Secondly,
the elaboration semantics into System F is done directly from the
source calculus with subtyping.
% In contrast, Dunfield has an additional step which eliminates subtyping.
Finally, a non-technical difference
is that System \name is aimed at studying issues of OOP languages and
extensibility, whereas Dunfield's work was aimed at Functional
Programming and he did not consider application to extensibility.
Like many other foundational formal models for OOP (for
example $F_{<:}$~\cite{CMMS}), System \name is purely functional and it uses
structural typing.

%%System \name is
%%formalized and implemented. Furthermore the paper illustrates how
%%various extensible designs can be encoded in System \name.

\begin{comment}
We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.
\end{comment}

In summary, the contributions of this paper are:

\begin{comment}
\george{Typing extensible records with a minimalistic design might also be of
  interest. We manage to achieve all what Daan Leijen achieved in
  \url{http://research.microsoft.com/pubs/65409/scopedlabels.pdf} except field
  renaming, with simpler approach.}
\end{comment}

\begin{itemize*}

\item {\bf A Minimal Core Language for Extensibility:} This paper
  identifies a minimal core language, System \name, capable of
  expressing various extensibility designs in the literature.
  System \name also addresses limitations of existing OOP
  languages that complicate extensible designs.

\item {\bf Formalization of System \name:} An elaboration semantics of
  System \name into System F is given, and type-soundness is proved.

\item {\bf Encodings of Extensible Designs:} Various encodings of
  extensible designs into System \name, including \emph{Object
    Algebras} and \emph{Modular Visitors}.

\item {\bf A Practical Example where ``Inheritance is not Subtyping''
    Matters:} This paper shows that modular/extensible visitors
  suffer from the ``inheritance is not subtyping problem''.
%% Moreover
%% with extensible visitors the extension should become a
%% \emph{supertype}, not a subtype. \bruno{extension with accept method}

\item {\bf Implementation:} An implementation of an
  extension of System \name, as well as the examples presented in the
  paper, are publicly available\footnote{{\bf Note to reviewers:} Due
    to the anonymous submission process, the code (and some machine
    checked proofs) is submitted as supplementary material.}.

\begin{comment}

\item{elaboration typing rules which given a source term with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $ e $ has type $ A $ in the source language,
    then the translated term $ \im e $ is well-typed and has type $ \im A $ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{comment}

\end{itemize*}

\begin{comment}
\subsection{Other Notes}

finitary overloading: yes
but have other merits of intersection been explored?

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]
\end{comment}

% \section{Introduction}

% Dundfield's work showed how many language features can be encoded in terms
% of intersection types with a merge operator. However two important
% questions were left open by Dundfield:

% \begin{enumerate}
% \item How to allow coherent programs only?

% \item If a restriction that allows coherent programs is in place, can
%   all coherent programs conform to the restriction?
% \end{enumerate}

% In other words question 1) asks whether we can find sufficient
% conditions to guarantee coherency; whereas question 2) asks
% whether those conditions are also necessary. In terms of technical
% lemmas that would correspond to:

% \begin{enumerate}

% \item Coherency theorem: $\Gamma \turns e : A \leadsto E_1 \wedge
%   \Gamma \turns e : A \leadsto E_2~\to~E_1 = E_2$.

% \item Completness of Coherency: ($\Gamma \turns_{old} e : A \leadsto E_1 \wedge
%   \Gamma \turns_{old} e : A \leadsto E_2~\to~E_1 = E_2) \to \Gamma
%   \turns e : A$.

% \end{enumerate}

% For these theorems we assume two type systems. On liberal type system
% that ensures type-safety, but not coherence ($\Gamma \turns_{old} e :
% A$); and another one that is both type-safe and coherent  ($\Gamma \turns e :
% A$). What needs to be shown for completness is that if a coherent
% program type-checks in the liberal type system, then it also
% type-checks in the restricted system.


% \special{papersize=8.5in,11in}
% \setlength{\pdfpageheight}{\paperheight}
% \setlength{\pdfpagewidth}{\paperwidth}

% \title{\name}

% \subsection{``Testsuite'' of examples}

% \begin{enumerate}

% \item $\lambda (x : Int * Int). (\lambda (z : Int) . z)~x$: This
%   example should not type-check because it leads to an ambigous choice
%   in the body of the lambda. In the current system the well-formedness
%   checks forbid such example.

% \item $\Lambda A.\Lambda B.\lambda (x:A).\lambda (y:B). (\lambda (z:A)
%   . z) (x,,y)$: This example should not type-check because it is not
%   guaranteed that the instantiation of A and B produces a well-formed
%   type. The TyMerge rule forbids it with the disjointness check.

% \item $\Lambda A.\Lambda B * A.\lambda (x:A).\lambda (y:B). (\lambda
%   (z:A) . z) (x,,y)$: This example should type-check because B is
%   guaranteed to be disjoint with A. Therefore instantiation should
%   produce a well-formed type.

% \item $(\lambda (z:Int) . z) ((1,,'c'),,(2,False))$: This example
%   should not type-check, since it leads to an ambigous lookup of
%   integers (can either be 1 or 2). The definition of disjointness is
%   crutial to prevent this example from type-checking. When
%   type-checking the large merge, the disjointness predicate will
%   detect that more than one integer exists in the merge.

% \item $(\lambda (f: Int \to Int \& Bool) . \lambda (g : Int \to Char \& Bool) . ((f,,g) : Int \to Bool)$:
%   This example
%   should not type-check, since it leads to an ambigous lookup of
%   functions. It shows that in order to check disjointness
%   of functions we must also check disjointness of the subcomponents.

% \item $(\lambda (f: Int \to Int) . \lambda (g : Bool \to Int) . ((f,,g) : Bool \& Int \to Int)$:
%   This example shows that whenever the return types overlap, so does the function type:
%   we can always find a common subtype for the argument types.
% \end{enumerate}

% \subsection{Achieving coherence}

% The crutial challenge lies in the generation of coercions, which can lead
% to different results due to multiple possible choices in the rules that
% can be used. In particular the rules SubAnd1 and SubAnd2 overlap and
% can result in coercions that are not equivalent. A simple example is:

% $(\lambda (x:Int) . x) (1,,2)$

% The result of this program can be either 1 or 2 depending on whether
% we chose SubAnd1 or SubAnd2.

% Therefore the challenge of coherence lies in ensuring that, for any given
% types A and B, the result of $A <: B$ always leads to the same (or semantically
% equivalent) coercions.

% It is clear that, in general, the following does not hold:

% $if~A <: B \leadsto C1~and~A <: B \leadsto C2~then~C1 = C2$

% We can see this with the example above. There are two possible coercions:\\

% \noindent $(Int\&Int) <: Int \leadsto \lambda (x,y). x$\\
% $(Int\&Int) <: Int \leadsto \lambda (x,y). y$\\

% However $\lambda (x,y). x$ and $\lambda (x,y). y$ are not semantically equivalent.

% One simple observation is that the use of the subtyping relation on the
% example uses an ill-formed type ($Int\&Int$). Since the type system can prevent
% such bad uses of ill-formed types, it could be that if we only allow well-formed
% types then the uses of the subtyping relation do produce equivalent coercions.
% Therefore the we postulate the following conjecture:

% $if~A <: B \leadsto C1~and~A <: B \leadsto C2~and~A, B~well~formed~then~C1 = C2$

% If the following conjecture does hold then it should be easy to prove that
% the translation is coherent.

% % \begin{mathpar}
% %   \inferrule
% %   {}
% %   {\hastype \epsilon {1 \mergeOp 2} {\constraints {\integer \disjoint \integer} \integer \inter \integer}}
% % \end{mathpar}

% % \begin{definition}{(Disjointness)}
% % Two sets $S$ and $T$ are \emph{disjoint} if there does not exist an element $x$, such that $x \in S$ and $x \in T$.
% % \end{definition}

% % \begin{definition}{(Disjointness)}
% % Two types $A$ and $B$ are \emph{disjoint} if there does not exist an term $e$, which is not a merge, such that $\hastype \epsilon e A'$, $\hastype \epsilon e B'$, $A' \subtype A$, and $B' \subtype B$.
% % \end{definition}

% \section{Introduction}

% The benefit of a merge, compared to a pair, is that you don't need to explicitly extract an item out. For example, \lstinline@fst (1,'c')@

% \begin{definition}{Determinism}
% If $e : A_1 \hookrightarrow E_1$ and $e : A_2 \hookrightarrow E_2$,
% then $A_1 = A_2$ and $E_1 = E_2$.
% \end{definition}

% \emph{Coherence} is a property about the relation between syntax and semantics. We say a semantics is \emph{coherent} if the syntax of a term uniquely determines its semantics.

% \begin{definition}{Coherence}
% If $e_1 : A_1 \hookrightarrow E_1$ and $e_2 : A_2 \hookrightarrow E_2$,
% $E_1 \Downarrow v_1$ and $E_2 \Downarrow v_2$,
% then $v_1 = v_2$.
% \end{definition}

% \begin{definition}{Disjointness}
% Two types $A$ and $B$ are \emph{disjoint} (written as ``$\disjoint A B$'') if there does not exist a type $C$ such that $C \subtype A$ and $C \subtype B$ and $C \subtype A \inter B$.
% \end{definition}

% \subsection{Equational reasoning}

% We can define a \code{fst} function that extracts the first item of a merged value:
% \begin{lstlisting}
% let fst A B (x : A & B) = (\(y : A). y) x in ...
% \end{lstlisting}
% Then we have the following equational reasoning:
% \begin{lstlisting}
% fst Int Int (2,,3)
% (\(y : Int). y) (2,,3)
% \end{lstlisting}

% \subsection{Discussion}

% In our type-directed translation, some inference rules return conclusions having
% \emph{the same constructor}. This phenomenon makes the translation
% nondeterministic. As an example,

% \begin{lstlisting}
% ({x=1},,{x=2}).x
% \end{lstlisting}

% can evaluate to either \lstinline@1@ or \lstinline@2@ (according their
% translation in the target language). In this case, the constructor is the
% intersection operator, for which both rules, (select1) and (select2), are
% applicable.

% One remedy, which you may have realised, is to enforce the order of applying
% rules. Whenever the case as shown above happens, the right component of
% \lstinline@&@ and \lstinline@,,@ will take precedence. In other words, the
% (select2) rule is tried first. Only if (select2) fails, the (select1) rule is
% tried. Therefore, \lstinline@({x=1},,{x=2}).x@ can only evaluate to 2. Likewise,
% \lstinline@({x=1},,{x="hi"}).x@ will evaluate to \lstinline@"hi"@ and will be of
% type \lstinline@String@. Generally, three pairs of rules in our system that
% cause nondeterminism can all be implemented in the same fashion (sub-and2 is
% favored over sub-and1), and (restrict2 is favored over restrict1).

% This approach seem works fine until you think about how it interact with
% parametric polymorphism.

% \begin{lstlisting}
% (/\A. \(x:A&Int). x) Int (1,,2) + 1
% \end{lstlisting}

% If we would like to have a deterministic elaboration result, another idea is to
% tweak the rules a little bit so that given a term, it is no longer possible that
% both of the twin rules described above can be used. For example, if
% $A_1 \inter A_2 \subtype
% A_3$, we would like to be certain that either $A_1 \subtype
% A_3$ holds or $A_2 \subtype A_3$ holds, but not both.

% Formally, we can state this theorem as:

% \begin{theorem}
%   If $A_1$, $A_2$, $A_3$, and $A_1 \inter A_2$ are well-formed
%   types, and $A_1 \inter A_2 \subtype A_3$, then $A_1 \inter A_3$
%   \emph{exclusive} or $A_2 \inter A_3$.
% \end{theorem}

% Note that $A$ \emph{exclusive} or $B$ is true if and only if their truth value
% differ. Next, we are going to investigate the minimal requirement (necessary and
% sufficient conditions) such that the theorem holds.

% If $A_1$ and $A_2$ in this setting are the same, for example,
% $\code{Int} \inter \code{Int} \subtype \code{Int}$, obviously the theorem will
% not hold since both the left $\code{Int}$ and the right $\code{Int}$ are a
% subtype of $\code{Int}$.

% If our types include primitive subtyping such as
% $\code{Nat} \subtype_\text{prim} \code{Int}$ (a natural number is also an
% integer), which can be promoted to the normal subtyping with this rule:
% \begin{mathpar}
%   \inferrule
%   {A_1 \subtype_\text{prim} A_2}
%   {A_1 \subtype A_2}
% \end{mathpar}
% the theorem will also not hold because
% $\code{Int} \inter \code{Nat} \subtype \code{Int}$ and yet
% $\code{Int} \subtype \code{Int}$ and $\code{Nat} \subtype \code{Int}$.

% We can try to rule out such possibilities by making the requirement of
% well-formedness stronger. This suggests that the two types on the sides of
% $\inter$ should not ``overlap''. In other words, they should be ``disjoint''. It
% is easy to determine if two base types are disjoint. For example, $\code{Int}$
% and $\code{Int}$ are not disjoint. Neither do $\code{Int}$ and $\code{Nat}$.
% Also, types built with different constructors are disjoint. For example,
% $\code{Int}$ and $\code{Int} \to \code{Int}$. For function types, disjointness
% is harder to visualise. But bear in the mind that disjointness can defined by
% the very requirement that the theorem holds.

% We shall give two semantics and show the two are the same.

% \begin{itemize}
% \item an type-directed semantics
% \item a direct operational semantics
% \end{itemize}

% say the example above:

% without the cast, you could either get:
% 1,,'c'
% or
% 1
% depending on what rules you use

% but I think with your change, you can only get the first

% (which is what we want)

% let me see how we can get `1` before the change

% \begin{mathpar}

% \end{mathpar}

% % (Int & Char) (1 : Int) ~> 1
% % ----------------------------------------------
% % (Int & Char) ((1 ,, 'c') : Int & Char) ~> 1

% With the change, we need $\code{Int} \subtype \code{Int} \inter \code{Char}$ to
% hold in order to get the premise, which does not. So it can be shown that
% $(\code{Int} \inter \code{Char}) ((1 \mergeOp 'c') : \code{Int} \inter
% \code{Char}) \hookrightarrow 1$ is not derivable.
