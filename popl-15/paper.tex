\documentclass[nocopyrightspace,preprint,times,9pt]{sigplanconf}

\input{packages.tex}

\input{macros.tex}

\input{rules/wf.tex}
\input{rules/disjoint.tex}
\input{rules/sub.tex}
\input{rules/ty.tex}
\input{rules/target.tex}


\newcommand{\name}{{\bf $F_{\&}$}\xspace}

\newcommand{\target}{{\bf f}\xspace}
\newcommand{\Target}{{\bf f}\xspace}

\newcommand{\authornote}[3]{{\color{#2} {\sc #1}: #3}}
\newcommand\bruno[1]{\authornote{bruno}{red}{#1}}
\newcommand\george[1]{\authornote{george}{blue}{#1}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\doi{nnnnnnn.nnnnnnn}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{\name}                        % 'preprint' option specified.

\title{Disjoint Intersection Types}
%%\subtitle{Subtitle Text, if any}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}

  Over the years there have been various proposals for \emph{design
    patterns} to improve \emph{extensibility} of programs.
  Examples include \emph{Object Algebras}, \emph{Modular Visitors} or
  Torgersen's design patterns using generics.
  Although those design patterns give practical
  benefits in terms of extensibility, they also expose limitations in
  existing mainstream OOP languages. Some pressing
  limitations are: 1) lack of good mechanisms for
  \emph{object-level} composition; 2) \emph{conflation of
    (type) inheritance with subtyping}; 3) \emph{heavy reliance on generics}.

  This paper presents System \name: an extension of System F with
  \emph{intersection types} and a \emph{merge operator}.  The goal of System \name
  is to study the minimal language constructs needed to support
  various extensible designs, while at the same time addressing the
  limitations of existing OOP languages. To address the lack of good
  object-level composition mechanisms, System \name uses the merge
  operator to do dynamic composition of values/objects. Moreover, in
  System \name type inheritance is independent of subtyping, and an
  extension can be a supertype of a base object type.  Finally, System
  \name replaces many uses of generics by intersection types or
  conventional subtyping. System \name is formalized and
  implemented. Moreover the paper shows how various extensible designs
  can be encoded in System \name.

\end{abstract}

%%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
%%\terms
%%Design, Languages, Theory

%%\keywords
%%Intersecion Types, Polymorphism, Type System

\section{Introduction}

Dundfield's work showed how many language features can be encoded in terms
of intersection types with a merge operator. However two important
questions were left open by Dundfield:

\begin{enumerate}
\item How to allow coherent programs only?

\item If a restriction that allows coherent programs is in place, can
  all coherent programs conform to the restriction?
\end{enumerate}

In other words question 1) asks whether we can find sufficient
conditions to guarantee coherency; whereas question 2) asks
whether those conditions are also necessary. In terms of technical
lemmas that would correspond to:

\begin{enumerate}

\item Coherency theorem: $\Gamma \turns e : A \leadsto E_1 \wedge
  \Gamma \turns e : A \leadsto E_2~\to~E_1 = E_2$.

\item Completness of Coherency: ($\Gamma \turns_{old} e : A \leadsto E_1 \wedge
  \Gamma \turns_{old} e : A \leadsto E_2~\to~E_1 = E_2) \to \Gamma
  \turns e : A$.

\end{enumerate}

For these theorems we assume two type systems. On liberal type system
that ensures type-safety, but not coherence ($\Gamma \turns_{old} e :
A$); and another one that is both type-safe and coherent  ($\Gamma \turns e :
A$). What needs to be shown for completness is that if a coherent
program type-checks in the liberal type system, then it also
type-checks in the restricted system.


\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{\name}

% Coherence for well-typed terms.

% \begin{figure*}
%   \caption{Disjointness between types.}
% \end{figure*}

% \begin{figure*}
%   \input{rule_in_figures/wellformedness.tex}
%   \caption{Well-formedness of types.}
% \end{figure*}

% \begin{figure*}
% \begin{mathpar}
% \begin{array}{l}
%   \begin{array}{llrl}
%     \text{Values} & v & \Coloneqq & \top \mid \lam x \tau e \mid \blam \alpha e \mid v_1 \mergeOp v_2 \mid \recordCon l e
%   \end{array}
% \end{array}
% \end{mathpar}
%
%   \caption{Values.}
% \end{figure*}

% \begin{figure*}

%   \begin{mathpar}
%     \begin{array}{lcl}
%       \fields {v_1 \mergeOp v_2} &=& \fields {v_1} \concatOp \fields {v_2} \\
%       \fields {\recordCon l e}   &=& [(l, e)] \\
%       \fields v                  &=& []
%     \end{array}
%   \end{mathpar}
%   \caption{\code{fields}.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \begin{array}{lcl}
%       \remove {\recordCon l e} l &=& \top \\
%       \remove {\recordCon l e \mergeOp v_2} l &=& v_2 \\
%       \remove {\recordCon l e \mergeOp v_2} {l'} &=& \recordCon l e \mergeOp \remove {v_2} {l'} \quad \quad (l \neq l') \\
%       \remove {v_1 \mergeOp \recordCon l e} l &=& v_1 \\
%       \remove {v_1 \mergeOp \recordCon l e} {l'} &=& \remove {v_1} {l'} \mergeOp \recordCon l e \quad \quad (l \neq l') \\

%       \remove v l                  &=& v
%     \end{array}

%   \end{mathpar}

%   \caption{\code{remove}.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \inferrule* [right=Cast/UpCast]
%       {\tau_1 \subtype \tau}
%       {\cast \tau {\withType v {\tau_1}} \hookrightarrow v}
%
%     \inferrule* [right=Cast/TakeLeft]
%       {\cast \tau {\withType {v_1} {\tau_1}} \hookrightarrow v}
%       {\cast \tau {\withType {v_1 \mergeOp v_2} {\tau_1 \intersect \tau_2}} \hookrightarrow v}
%
%     \inferrule* [right=Cast/TakeRight]
%       {\cast \tau {\withType {v_2} {\tau_2}} \hookrightarrow v}
%       {\cast \tau {\withType {v_1 \mergeOp v_2} {\tau_1 \intersect \tau_2}} \hookrightarrow v}
%   \end{mathpar}
%
%   \caption{Casts.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \inferrule* [right=Dyn/Val]
%       { }
%       {v \Downarrow v}
%
%     \inferrule* [right=Dyn/App]
%       {e_1 \Downarrow \lam x \tau e \\
%        e_2 \Downarrow v_2 \\
%        \cast \tau {\withType {v_2} {\tau_2}} \hookrightarrow v_3 \\
%        \subst {v_3} x e \Downarrow v}
%       {\app {e_1} {\withType {e_2} {\tau_2}} \Downarrow v}
%
%     \inferrule* [right=Dyn/TApp]
%       {e_1 \Downarrow \for \alpha e \\
%        \subst \tau \alpha e \Downarrow v}
%       {\tapp {e_1} \tau \Downarrow v}
%
%     \inferrule* [right=Dyn/Merge]
%       {e_1 \Downarrow v_1 \\ e_2 \Downarrow v_2}
%       {e_1 \mergeOp e_2 \Downarrow v_1 \mergeOp v_2}
%
%     % \inferrule* [right=Dyn/RecSelect]
%     %   {e \Downarrow v \\
%     %    (l, e_1) \; \code{`uniqueElem`} \; \fields v \\
%     %    e_1 \Downarrow v_1}
%     %   {e.l \Downarrow v_1}
%
%     % \inferrule* [right=Dyn/RecRestrict]
%     %   {e \Downarrow v \\
%     %    (l, e_1) \; \code{`uniqueElem`} \; \fields v}
%     %   {e \restrictOp l \Downarrow v \; \code{`remove`} \; l}
%   \end{mathpar}
%
%   \caption{Dynamic semantics.}
% \end{figure*}
%
% \begin{figure*}
%   \input{rule_in_figures/type-translation.tex}
%   \caption{Type translation.}
% \end{figure*}

\begin{figure}
  \begin{mathpar}
    \framebox{$\isatomic A$} \\

    \inferrule*
      {}
      {\isatomic \bot}

    \inferrule*
      {}
      {\isatomic {A \to B}}

    \inferrule*
      {}
      {\isatomic {\for {\alpha \disjoint B} A}}

  \end{mathpar}
  \caption{Atomic types.}
\end{figure}

\subsection{``Testsuite'' of examples}

\begin{enumerate}

\item $\lambda (x : Int * Int). (\lambda (z : Int) . z)~x$: This
  example should not type-check because it leads to an ambigous choice
  in the body of the lambda. In the current system the well-formedness
  checks forbid such example.

\item $\Lambda A.\Lambda B.\lambda (x:A).\lambda (y:B). (\lambda (z:A)
  . z) (x,,y)$: This example should not type-check because it is not
  guaranteed that the instantiation of A and B produces a well-formed
  type. The TyMerge rule forbids it with the disjointness check.

\item $\Lambda A.\Lambda B * A.\lambda (x:A).\lambda (y:B). (\lambda
  (z:A) . z) (x,,y)$: This example should type-check because B is
  guaranteed to be disjoint with A. Therefore instantiation should
  produce a well-formed type.

\item $(\lambda (z:Int) . z) ((1,,'c'),,(2,False))$: This example
  should not type-check, since it leads to an ambigous lookup of
  integers (can either be 1 or 2). The definition of disjointness is
  crutial to prevent this example from type-checking. When
  type-checking the large merge, the disjointness predicate will
  detect that more than one integer exists in the merge.

\item $(\lambda (f: Int \to Int \& Bool) . \lambda (g : Int \to Char \& Bool) . ((f,,g) : Int \to Bool)$:
  This example
  should not type-check, since it leads to an ambigous lookup of
  functions. It shows that in order to check disjointness
  of functions we must also check disjointness of the subcomponents.

\item $(\lambda (f: Int \to Int) . \lambda (g : Bool \to Int) . ((f,,g) : Bool \& Int \to Int)$:
  This example shows that whenever the return types overlap, so does the function type:
  we can always find a common subtype for the argument types.
\end{enumerate}

\subsection{Achieving coherence}

The crutial challenge lies in the generation of coercions, which can lead
to different results due to multiple possible choices in the rules that
can be used. In particular the rules SubAnd1 and SubAnd2 overlap and
can result in coercions that are not equivalent. A simple example is:

$(\lambda (x:Int) . x) (1,,2)$

The result of this program can be either 1 or 2 depending on whether
we chose SubAnd1 or SubAnd2.

Therefore the challenge of coherence lies in ensuring that, for any given
types A and B, the result of $A <: B$ always leads to the same (or semantically
equivalent) coercions.

It is clear that, in general, the following does not hold:

$if~A <: B \leadsto C1~and~A <: B \leadsto C2~then~C1 = C2$

We can see this with the example above. There are two possible coercions:\\

\noindent $(Int\&Int) <: Int \leadsto \lambda (x,y). x$\\
$(Int\&Int) <: Int \leadsto \lambda (x,y). y$\\

However $\lambda (x,y). x$ and $\lambda (x,y). y$ are not semantically equivalent.

One simple observation is that the use of the subtyping relation on the
example uses an ill-formed type ($Int\&Int$). Since the type system can prevent
such bad uses of ill-formed types, it could be that if we only allow well-formed
types then the uses of the subtyping relation do produce equivalent coercions.
Therefore the we postulate the following conjecture:

$if~A <: B \leadsto C1~and~A <: B \leadsto C2~and~A, B~well~formed~then~C1 = C2$

If the following conjecture does hold then it should be easy to prove that
the translation is coherent.

% \begin{mathpar}
%   \inferrule
%   {}
%   {\hastype \epsilon {1 \mergeOp 2} {\constraints {\integer \disjoint \integer} \integer \intersect \integer}}
% \end{mathpar}

% \begin{definition}{(Disjointness)}
% Two sets $S$ and $T$ are \emph{disjoint} if there does not exist an element $x$, such that $x \in S$ and $x \in T$.
% \end{definition}

% \begin{definition}{(Disjointness)}
% Two types $A$ and $B$ are \emph{disjoint} if there does not exist an expression $e$, which is not a merge, such that $\hastype \epsilon e A'$, $\hastype \epsilon e B'$, $A' \subtype A$, and $B' \subtype B$.
% \end{definition}

% \begin{figure}
%   % Typing
%   \begin{mathpar}
%     \framebox{$ \hastype \Gamma e A \yields E $} \\
%     \tyvar \and
%     \ruleTop \and
%     \tylam \and
%     \tyapp \and
%     \tyblam \and
%     \tytapp \and
%     \tymerge \and
%     \ruleDisjointAssume \and
%     \ruleDisjointCheck
%     % \rulerecordConstruct \and
%     % \ruleRecSelect \and \ruleRecRestrict
%   \end{mathpar}
%
%   % % Selection
%   % \begin{mathpar}
%   %   \framebox{$\judgeSelect {\tau_1} l \tau_2 \yields C$} \and
%   %   \ruleGet \and \ruleGetLeft \and \ruleGetRight
%   % \end{mathpar}
%   %
%   % % Restriction
%   % \begin{mathpar}
%   %   \framebox{$\judgeRestrict {\tau_1} l \tau_2 \yields C$} \and
%   %   \ruleRestrict \and \ruleRestrictLeft \and \ruleRestrictRight
%   % \end{mathpar}
%
%   \caption{Disjointness.}
% \end{figure}

\section{Introduction}

The benefit of a merge, compared to a pair, is that you don't need to explicitly extract an item out. For example, \lstinline@fst (1,'c')@

\begin{definition}{Determinism}
If $e : \tau_1 \hookrightarrow E_1$ and $e : \tau_2 \hookrightarrow E_2$,
then $\tau_1 = \tau_2$ and $E_1 = E_2$.
\end{definition}

\emph{Coherence} is a property about the relation between syntax and semantics. We say a semantics is \emph{coherent} if the syntax of a term uniquely determines its semantics.

\begin{definition}{Coherence}
If $e_1 : \tau_1 \hookrightarrow E_1$ and $e_2 : \tau_2 \hookrightarrow E_2$,
$E_1 \Downarrow v_1$ and $E_2 \Downarrow v_2$,
then $v_1 = v_2$.
\end{definition}

\begin{definition}{Disjointness}
Two types $A$ and $B$ are \emph{disjoint} (written as ``$\disjoint A B$'') if there does not exist a type $C$ such that $C \subtype A$ and $C \subtype B$ and $C \subtype A \intersect B$.
\end{definition}

\subsection{Equational reasoning}

We can define a \code{fst} function that extracts the first item of a merged value:
\begin{lstlisting}
let fst A B (x : A & B) = (\(y : A). y) x in ...
\end{lstlisting}
Then we have the following equational reasoning:
\begin{lstlisting}
fst Int Int (2,,3)
(\(y : Int). y) (2,,3)
\end{lstlisting}

\subsection{Discussion}

In our type-directed translation, some inference rules return conclusions having
\emph{the same constructor}. This phenomenon makes the translation
nondeterministic. As an example,

\begin{lstlisting}
({x=1},,{x=2}).x
\end{lstlisting}

can evaluate to either \lstinline@1@ or \lstinline@2@ (according their
translation in the target language). In this case, the constructor is the
intersection operator, for which both rules, (select1) and (select2), are
applicable.

One remedy, which you may have realised, is to enforce the order of applying
rules. Whenever the case as shown above happens, the right component of
\lstinline@&@ and \lstinline@,,@ will take precedence. In other words, the
(select2) rule is tried first. Only if (select2) fails, the (select1) rule is
tried. Therefore, \lstinline@({x=1},,{x=2}).x@ can only evaluate to 2. Likewise,
\lstinline@({x=1},,{x="hi"}).x@ will evaluate to \lstinline@"hi"@ and will be of
type \lstinline@String@. Generally, three pairs of rules in our system that
cause nondeterminism can all be implemented in the same fashion (sub-and2 is
favored over sub-and1), and (restrict2 is favored over restrict1).

This approach seem works fine until you think about how it interact with
parametric polymorphism.

\begin{lstlisting}
(/\A. \(x:A&Int). x) Int (1,,2) + 1
\end{lstlisting}

If we would like to have a deterministic elaboration result, another idea is to
tweak the rules a little bit so that given a term, it is no longer possible that
both of the twin rules described above can be used. For example, if
$\tau_1 \intersect \tau_2 \subtype
\tau_3$, we would like to be certain that either $\tau_1 \subtype
\tau_3$ holds or $\tau_2 \subtype \tau_3$ holds, but not both.

Formally, we can state this theorem as:

\begin{theorem}
  If $\tau_1$, $\tau_2$, $\tau_3$, and $\tau_1 \intersect \tau_2$ are well-formed
  types, and $\tau_1 \intersect \tau_2 \subtype \tau_3$, then $\tau_1 \intersect \tau_3$
  \emph{exclusive} or $\tau_2 \intersect \tau_3$.
\end{theorem}

Note that $A$ \emph{exclusive} or $B$ is true if and only if their truth value
differ. Next, we are going to investigate the minimal requirement (necessary and
sufficient conditions) such that the theorem holds.

If $\tau_1$ and $\tau_2$ in this setting are the same, for example,
$\code{Int} \intersect \code{Int} \subtype \code{Int}$, obviously the theorem will
not hold since both the left $\code{Int}$ and the right $\code{Int}$ are a
subtype of $\code{Int}$.

If our types include primitive subtyping such as
$\code{Nat} \subtype_\text{prim} \code{Int}$ (a natural number is also an
integer), which can be promoted to the normal subtyping with this rule:
\begin{mathpar}
  \inferrule
  {\tau_1 \subtype_\text{prim} \tau_2}
  {\tau_1 \subtype \tau_2}
\end{mathpar}
the theorem will also not hold because
$\code{Int} \intersect \code{Nat} \subtype \code{Int}$ and yet
$\code{Int} \subtype \code{Int}$ and $\code{Nat} \subtype \code{Int}$.

We can try to rule out such possibilities by making the requirement of
well-formedness stronger. This suggests that the two types on the sides of
$\intersect$ should not ``overlap''. In other words, they should be ``disjoint''. It
is easy to determine if two base types are disjoint. For example, $\code{Int}$
and $\code{Int}$ are not disjoint. Neither do $\code{Int}$ and $\code{Nat}$.
Also, types built with different constructors are disjoint. For example,
$\code{Int}$ and $\code{Int} \to \code{Int}$. For function types, disjointness
is harder to visualise. But bear in the mind that disjointness can defined by
the very requirement that the theorem holds.

We shall give two semantics and show the two are the same.

\begin{itemize}
\item an type-directed semantics
\item a direct operational semantics
\end{itemize}

say the example above:

without the cast, you could either get:
1,,'c'
or
1
depending on what rules you use

but I think with your change, you can only get the first

(which is what we want)

let me see how we can get `1` before the change

\begin{mathpar}

\end{mathpar}

% (Int & Char) (1 : Int) ~> 1
% ----------------------------------------------
% (Int & Char) ((1 ,, 'c') : Int & Char) ~> 1

With the change, we need $\code{Int} \subtype \code{Int} \intersect \code{Char}$ to
hold in order to get the premise, which does not. So it can be shown that
$(\code{Int} \intersect \code{Char}) ((1 \mergeOp 'c') : \code{Int} \intersect
\code{Char}) \hookrightarrow 1$ is not derivable.

\input{sections/introduction.tex}
\input{sections/overview.tex}
\input{sections/examples.tex}
\input{sections/fi.tex}
\input{sections/translation.tex}
\input{sections/implementation.tex}

\section{Disjoint Intersection Types}

This section shows how to restrict the system presented before
so that it supports coherence as well as type soundness.
The keys aspects are the notion of disjoint intersections,
and disjoint quantification for polymorphic types.

\subsection{Motivating design choices}\bruno{Maybe this belongs to Section 2?}

We need to motivate the 3 changes:

\paragraph{Well-formed types}: We need a new notion of well-formed types.

\paragraph{Disjoint quantification}: Needed when we have a
combination of polymorphism and intersection types.

With a subtyping relation in a type system, bounded polymorphism extends the universal quantifier by confining the polymorphic type to be a subtype of a given type. In our type system, the forall binder also extends the parametric polymorphism, but in a different vein: the polymorphic type can only be disjoint with a given type. Later during an instantiation, if the type provided overlaps with the constraint, such instantiation will be rejected by our type system.

\begin{itemize}
  \item \textbf{Bounded polymorphism}---the instantiation can only be the descendant of a given type
  \item \textbf{Polymorphism with disjoint constraint}---the instantiation cannot share a common ancestor with a given type
\end{itemize}

The intuition can be found in figure \ldots.

% http://tex.stackexchange.com/questions/158876/drawing-subgroup-lattices-in-tikz
\begin{figure}

% center everything in the figure
\centering
% horizontal node distance
\newcommand{\mydistance}{.6cm}
\begin{tikzpicture}[node distance=2cm]
\title{Untergruppenverband der $A_4$}
\node(A4)                           {$A_4$};
\node(V4)       [below right=2cm and 2cm of A4] {$V_4$};
\node(C31)      [below left=2cm and 0cm of A4]  {$C_3$};
\node(C32)      [left=\mydistance of C31]       {$C_3$};
\node(C33)      [left=\mydistance of C32]       {$C_3$};
\node(C34)      [left=\mydistance of C33]       {$C_3$};
\node(C22)      [below=2cm of V4]       {$C_2$};
\node(C21)      [left=\mydistance of C22]       {$C_2$};
\node(C23)      [right=\mydistance of C22]      {$C_2$};
\node(1)            [below=6cm of A4]     {$\left\{1\right\}$};
\draw(A4)       -- (V4);
\foreach \x\y in {1,2,3,4} {
    \draw (A4) -- (C3\x) node [midway, fill=white] {3};
    \draw (C3\x) -- (1);

}
\foreach \x\y in {1/2,2/3,3/4} {
    \draw(V4) -- (C2\x) node [midway, fill=white] {2};
\draw (C3\x) -- (C3\y);
\draw (C2\x) -- (1);
}
\draw(C21)      -- (C22);
\draw(C22)      -- (C23);
\end{tikzpicture}
\caption{Untergruppenverband}
\end{figure}

\paragraph{Restrictions on subtyping}:

The subtyping rules, without the atomic condition are overlapping. With the atomic constraint, one can guarantee that at any moment during the derivation of a subtyping relation, at most one rule can be used. Indeed, our restrictions on subtyping do not make the subtyping relation less expressive to one without such restrictions.\todo{Point to proofs}

\george{Add interpretation of the theorem}

\begin{theorem}
  If $A \subtype C$, then $A \intersect B \subtype C$.
  If $B \subtype C$, then $A \intersect B \subtype C$.
\end{theorem}

\begin{proof}
  By induction on $C$.
  If $C \neq C_1 \intersect C_2$, trivial.
  If $C = C_1 \intersect C_2$,
  Need to show $A \subtype C_1 \intersect C_2$ implies $A \intersect B \subtype C_1 \intersect C_2$.
  By inversion $A \subtype C_1$ and $A \subtype C_2$.
  By the i.h., $A \intersect B \subtype C_1$ and $A \intersect B \subtype C_2$.
  By \rulelabel{SubAnd}, $A \intersect B \subtype C_1 \intersect C_2$.
\end{proof}

\subsection{Disjointness}

Spec of disjointness/intuition ...

We say two types are \emph{disjoint} if they do not share a common supertype.

\begin{definition}[Disjointness]
$A \bot B = \not \exists C. A <: C \wedge B <: C$
\end{definition}

We require the types of two terms in a merge $e_1 \mergeOp e_2$ to be disjoint. Why do we require this? That is because if both terms can be assigned some type $C$, both of them can be chosen as the meaning of the merge, which leads to multiple meaning of a term, known as incoherence.

\subsection{Well-formed types}

A well-formed type is such that given any query type, it is always clear which subpart the query is referring to. The rules for well-formedness are standard except for intersection types we require the two components to be disjoint.

\subsection{Subtyping}

\subsection{Metatheory}

\begin{definition}{Type variable constraint}
We say the \emph{constraint} of a type variable $\alpha$ inside the context $\Gamma$ is $A$ if $\alpha \disjoint A \in \Gamma$.
\end{definition}

% \begin{lemma}
% If $A \subtype B$ where both $A$ and $B$ are well-formed, then $A$ and $B$ cannot be disjoint.
% \end{lemma}
%
% \begin{proof}
% $A \subtype B$ implies $B$ is a common supertype of $A$ and $B$. As a result, $A$ and $B$ are not disjoint by definition.
% \end{proof}

\begin{lemma}[Free type variables of disjoint bounds] \label{free-var-disjoint-bounds}
  If $\isdisjoint \Gamma \alpha A$, then $\alpha \not \in \ftv A$.
\end{lemma}

\begin{lemma}[Unique subtype contributor] \label{unique-subtype-contributor}
If $A \intersect B \subtype C$, where $A \intersect B$ and $C$ are well-formed types, then it is not possible that the following hold at the same time:
\begin{enumerate}
\item $A \subtype C$
\item $B \subtype C$
\end{enumerate}
\end{lemma}

If $A \intersect B \subtype C$, then either $A$ or $B$ contributes to that subtyping relation, but not both. The implication of this lemma is that during the derivation, it is not possible that two rules are applicable.

\newcommand{\wfinterlabel}{\textsc{WFInter}}

\begin{proof}
Since $A \intersect B$ is well-formed, $A \disjoint B$ by the formation rule of intersection types \wfinterlabel. Then by the definition of disjointness, there does not exist a type $C$ such that $A \subtype C$ and $B \subtype C$. It follows that $A \subtype C$ and $B \subtype C$ cannot hold simultaneously.
\end{proof}

The coercion of a subtyping relation $A \subtype B$ is uniquely determined.

\begin{lemma}[Unique coercion] \label{unique-coercion}
If $A \subtype B \yields {C_1}$ and $A \subtype B \yields {C_2}$, where $A$ and $B$ are well-formed types, then $C_1 \equiv C_2$
\end{lemma}

\begin{proof}
The set of rules for generating coercions is syntax-directed except for the three rules that involve intersection types in the conclusion. Therefore it suffices to show that if well-formed types $A$ and $B$ satisfy $A \subtype B$, where $A$ or $B$ is an intersection type, then at most one of the three rules applies. In the following, we do a case analysis on the shape of $A$ and $B$:

\begin{itemize}
  \item \textbf{Case} $A \neq A_1 \intersect A_2$ and $B = B_1 \intersect B_2$: Clearly only \textsc{SubAnd} can apply.
  \item \textbf{Case} $A = A_1 \intersect A_2$ and $B \neq B_1 \intersect B_2$: Only two rules can apply, \textsc{SubAnd1} and \textsc{SubAnd2}. Further, by the unique subtype contributor lemma, it is not possible that $A_1 \subtype B$ and that $A_2 \subtype B$. Thus we are certain that at most one rule of \textsc{SubAnd1} and \textsc{SubAnd2} will apply.
  \item \textbf{Case} $A = A_1 \intersect A_2$ and $B = B_1 \intersect B_2$\footnote{An example of this case is:
    \[ (\integer \intersect \bool) \intersect \character \subtype \bool \intersect \character \]}: Since $B$ is not atomic, only \rulelabel{SubAnd} apply.

  %   Suppose the contrary, that is, more than one of the three rules apply. Since it is not possible that both \textsc{SubAnd1} and \textsc{SubAnd2} apply by the unique subtype contributor lemma, only one of \textsc{SubAnd1} and \textsc{SubAnd2} apply. Therefore \textsc{SubAnd} has to hold. Without the loss of generality, assume \textsc{SubAnd1} apply. Then we have:
  % \[ A_1 \subtype B_1 \intersect B_2 \]
  % \[ A_1 \intersect A_2 \subtype B_1 \]
  % \[ A_1 \intersect A_2 \subtype B_2 \]
\end{itemize}
\end{proof}

In general, disjointness judgements are not invariant with respect to free-variable substitution. In other words, a careless substitution can violate the disjoint constraint in the context. For example, in the context $\alpha \disjoint \tyint$, $\alpha$ and $\tyint$ are disjoint:
\begin{mathpar}
\isdisjoint {\alpha \disjoint \tyint} \alpha \tyint
\end{mathpar}
But after the substitution of $\tyint$ for $\alpha$ on the two types, the sentence
\begin{mathpar}
\isdisjoint {\alpha \disjoint \tyint} \tyint \tyint
\end{mathpar}
is longer true since $\tyint$ is clearly not disjoint with itself.

\begin{lemma}{Invariance of disjointness} \label{invariance-of-disjointness}
If $\isdisjoint \Gamma A B$ and $R$ respects the constraints of $\beta$, then $\isdisjoint \Gamma {\subst R \beta A} {\subst R \beta B}$.
\end{lemma}

This lemma says that substitution for free type variables preserves disjointness of types if the combination of the replacement type and the type variable is proven disjoint.

\begin{proof}
By induction on the derivation of $\isdisjoint \Gamma A B$.
\begin{itemize}
  \item Case \[ \disjointvar \]
  We need to show \[ \isdisjoint \Gamma {\subst R \beta \alpha} {\subst R \beta B} \]
  If $\beta$ is not equivalent to $\alpha$ and is not free in $B$, then the above trivially holds by the def. of the substitution function. Otherwise, if $\beta$ is equivalent to $\alpha$, then we need to show
  \[ \isdisjoint \Gamma R {\subst R \beta B} \]

  % Note that $\beta \not \in \ftv B$. Thus $B$ is equivalent to $\subst R \beta B$.
  %
  % If $\beta$ is not equivalent to $\alpha$, $\subst R \beta \alpha$ is equivalent to $\alpha$. Therefore $\isdisjoint \Gamma {\subst R \beta \alpha} {\subst R \beta B}$ is true.
  % If $\beta$ is equivalent to $\alpha$, then $\subst R \beta \alpha$ is equivalent to $R$ by the def. of the substitution function. It now remains to show \[ \isdisjoint \Gamma R B \].

  \item Case \[ \disjointinterleft \]
  By applying the i.h. and the def. of the substitution function.

  \item Case \[ \disjointinterright \]
  Similar.

  \item Case \[ \disjointfun \]
  By applying the i.h. and the def. of the substitution function.

  \item Case \[ \disjointforall \]
  By applying the i.h. and the def. of the substitution function. Note that $\alpha$ is fresh.

  \item Case \[ \disjointatomic \]
  Substitution does not change the shape of types when the variable case is excluded. Therefore, the relation in the premise of the rule continue to hold and hence the conclusion.

\end{itemize}
\end{proof}

\begin{lemma}{Substitution} \label{substitution}
If $\istype \Gamma R$, $\istype \Gamma S$, and $R$ respects the constraints of $\beta$, then $\istype \Gamma {\subst R \beta S}$.
\end{lemma}

\begin{proof}
By induction on the derivation of $\istype \Gamma {\subst R \beta S}$.

\begin{itemize}
  \item Case \[ \wfvar \]
  If $\alpha$ happens to be the same as $\beta$, then by the def. of substitution $\subst R \beta \alpha = R$. Since $\istype \Gamma R$, we have $\istype \Gamma {\subst R \beta \alpha}$; On the other hand, if not, then by the def. of substitution $\subst R \beta S = S$. Since $\istype \Gamma S$, we also have $\istype \Gamma {\subst R \beta \alpha}$.

  \item Case
  \begin{mathpar}
    \wfbot
  \end{mathpar}
  Trivial.

  \item Case
  \begin{mathpar}
    \wffun
  \end{mathpar}
  By i.h., $\istype \Gamma {\subst R \beta A}$ and $\istype \Gamma {\subst R \beta B}$. By the def. of substitution, $\istype \Gamma {\subst R \beta {A \to B}}$.

  \item Case
  \begin{mathpar}
    \wfforall
  \end{mathpar}
  By the premise and the i.h.,
  \[ \istype {\Gamma} {\subst R \beta A} \]
  \[ \istype {\Gamma, \alpha \disjoint A} {\subst R \beta B} \]
  which by \rulelabel{WFForall} implies
  \[ \istype \Gamma {\for {\alpha \disjoint A} {\subst R \beta B}} \]
  By the def. of substitution, $\istype \Gamma {\subst R \beta {\for {\alpha \disjoint A} B}}$~\todo{Subst. of $A$}.

  \item Case
  \begin{mathpar}
    \wfinter
  \end{mathpar}
  By i.h., $\istype \Gamma {\subst R \beta A}$ and $\istype \Gamma {\subst R \beta B}$. By Lemma~\ref{invariance-of-disjointness}, we also have $\isdisjoint \Gamma {\subst R \beta A} {\subst R \beta B}$. Therefore by \rulelabel{WFInter}, $\istype \Gamma {\subst R \beta {A \intersect B}}$.
\end{itemize}
\end{proof}

\begin{lemma}{Instantiation} \label{instantiation}
If
  $\istype {\Gamma, \alpha \disjoint B} C$,
  $\istype \Gamma A$,
  $\isdisjoint \Gamma A B$
then
  $\istype \Gamma {\subst A \alpha C}$.
\end{lemma}

\begin{proof}
By induction.

\begin{itemize}
  \item Case \[ \wfvar \]
  If $C = \alpha$, then $\subst A \alpha \alpha = A$. Since $\istype \Gamma A$, it follows that $\istype \Gamma {\subst A \alpha \alpha}$; otherwise, let $C = \beta$, where $\beta$ is a type variable distinct from $\alpha$. Since $\istype {\Gamma, \alpha \disjoint B} \beta$ and $\alpha$ and $\beta$ are distinct, $\beta$ must be in $\Gamma$ and therefore $\istype {\Gamma} \beta$, which is equivalent to $\istype {\Gamma} {\subst A \alpha \beta}$.

  \item Case \[ \wffun \]
  By straightforwardly applying the i.h and the rule itself.

  \item Case \[ \wfbot \]
  Trivial.

  \item Case \[ \wfforall \]
  By straightforwardly applying the i.h and the rule itself.

  \item Case \[ \wfinter \]
  Let $C$ in the statement of this lemma be $C_1 \intersect C_2$.
  By the condition we know
  \[ \istype {\Gamma, \alpha \disjoint B} {C_1 \intersect C_2} \]
  Thus we must have,
  \[ \istype {\Gamma, \alpha \disjoint B} {C_1} \]
  By the i.h., $\istype \Gamma {\subst A \alpha {C_1}}$ and similarly $\istype \Gamma {\subst A \alpha {C_2}}$. By \rulelabel{WFInter}\todo{Show disjointness},
  \[ \istype \Gamma {\subst A \alpha {C_1} \intersect \subst A \alpha {C_2}} \]
  and hence
  \[ \istype \Gamma {\subst A \alpha {(C_1 \intersect C_2)}} \]

\end{itemize}

\end{proof}

\begin{lemma}{Well-formed typing} \label{wf-typing}
If $\hastype \Gamma e A$, then $\istype \Gamma e$.
\end{lemma}
Typing always produces a well-formed type.
\begin{proof}
By induction on the derivation of $\hastype \Gamma e A$. The case of \rulelabel{TyTApp} needs special attention
\begin{mathpar}
  \tytapp
\end{mathpar}
because we need to show that the result of substitution ($\subst A \alpha C$) is well-formed, which is evident by Lemma~\ref{instantiation}.
\end{proof}

\begin{theorem}[Unique elaboration] \label{unique-elaboration}
If $\hastype \Gamma e {A_1} \yields {E_1}$ and $\hastype \Gamma e {A_2} \yields {E_2}$, then $E_1 \equiv E_2$.
\end{theorem}
Given a source expression $e$, elaboration always produces the same target expression $E$.
\begin{proof}
The typing rules are syntax-directed. The case of \rulelabel{TyApp} needs special attention since we still need to show that the generated coercion $C$ is unique.
\begin{mathpar}
  \tyapp
\end{mathpar}
By Lemma~\ref{wf-typing}, we have $\istype \Gamma {A_1}$ and $\istype \Gamma {A_3}$. Therefore we are able to apply Lemma~\ref{unique-coercion} and conclude that $C$ is unique.
\end{proof}

\section{Algorithmic Disjointness}

Although the system in the previous section shows a formal system of
disjoint intersection types, it relies on a non-algorithmic
specification of disjointness. This section shows an algorithmic
specification of disjointness that is proved to be sound and complete.

The problem with the definition of disjointness is that it is a search problem. In this section, we are going to convert it that into an algorithm.

Let $\universe_0$ be the universe of $\tau$ types. Let $\universe$ be the quotient set of $\universe_0$ by $\approx$, where $\approx$ is defined by \ldots.

Let $\commonsuper$ be the ``common supertype'' function, and $\commonsub$ be the ``common subtype'' function. For example, assume $\integer$ and $\character$ share no common supertype. Then the fact can be expressed by $\commonsuper(\integer,\character)=\emptyset$. Formally,
\begin{align*}
  \commonsuper &: \universe \times \universe \to \powerset {\universe} \\
  \commonsub   &: \universe \times \universe \to \powerset {\universe}
\end{align*}
which, given two types, computes the set of their common supertypes. ($\powerset S$ denotes the power set of $S$, that is, the set of all subsets of $S$.)

\begin{align*}
  \commonsuper(\alpha,\alpha) &= \{ \alpha \} \\
  \commonsuper(\bot,\bot) &= \{ \bot \} \\
  \commonsuper(\tau_1 \to \tau_2, \tau_3 \to \tau_4) &= \commonsub(\tau_1,\tau_3) \to \commonsuper(\tau_2,\tau_4) \\
  % \commonsuper({\tau_1 \intersect \tau_2, \tau_3}) &= \commonsuper(\tau_1, \tau_3) \cup \commonsuper(\tau_1,\tau_3) \\
  % \commonsuper({\tau_1, \tau_2 \intersect \tau_3}) &= \commonsuper(\tau_1, \tau_2) \cup \commonsuper(\tau_1,\tau_3)
\end{align*}

Notation. We use $\commonsub(\tau_1,\tau_3) \to \commonsuper(\tau_2,\tau_4)$ as a shorthand for $\{ s \to t ~|~ s \in \commonsub(\tau_1 \to \tau_2), t \in \commonsuper(\tau_2,\tau_4) \}$. Therefore, the problem of determining if $\commonsub(\tau_1,\tau_3) \to \commonsuper(\tau_2,\tau_4)$ is empty reduces to the problem of determining if $\commonsuper(\tau_2,\tau_4)$ is empty.

Note that there always exists a common subtype of any two given types (case disjoint / case nondisjoint).

\subsection{Formal System}

Explain the rules and intuitions.

\section{Discussions}

\subsection{Systems without subtyping}

\subsection{Systems with a top type}

In type systems with a top type (such as \lstinline@Object@ in some OO languages), the definition of disjointness can be modified to:

We say two types are \emph{disjoint} if their only common supertype is the top type.

\input{sections/metatheory.tex}

\input{sections/related-work.tex}

\input{sections/conclusion.tex}

\input{sections/bibliography.tex}

% \acks
%
% Acknowledgments, if needed.

\clearpage
\onecolumn
\appendix
\input{sections/type-wellformedness.tex}
\input{sections/target-type-system.tex}
\input{sections/proofs.tex}

\end{document}
