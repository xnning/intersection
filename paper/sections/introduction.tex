\section{Introduction}

\bruno{The following are just some loose notes for the paper.}

There has been a remarkable number of works aimed at improving support
for extensibility in programming languages. These works include:
visions of new programming models\cite{}; new programming languages or
language extensions\cite{}, and \emph{design patterns} that can be
used with existing mainstream languages.

%\cite{family polymorphism and virtual
%classes.}. Another line of work are proposals for precise formal models or new 
%programming languages. Yet another line are \emph{design patterns}
%that can be used  with existing mainstream languages. 
%%Part of the motivation behind 

Some of the more recent work on extensibility includes various
proposals for design patterns.  Examples include \emph{Object
  Algebras}~\cite{}, \emph{Modular Visitors}~\cite{} or
Torgersen's~\cite{} four design patterns using generics. In those
approaches the idea is to use some advanced (but already available)
features, such as \emph{generics}, in combination with conventional OOP
features to model more extensible designs. Those designs work in
modern OOP languages such as Java, C\# or Scala. 

Although such design patterns give practical benefits in terms of
extensibility, they also expose limitations in existing mainstream OOP
languages. One limitation is that existing OOP languages lack
good mechanisms for \emph{object-level} composition.  As illustrated
by Oliveira et al.~\cite{}, highly modular programs using Object
Algebras are best expressed using a form of \emph{type-safe},
\emph{dynamic}, \emph{delegation}-based composition. Although such
form of composition can be encoded in Scala, it requires the use of
low-level reflection techniques, such as dynamic proxies, reflection
or other forms of meta-programming~\cite{}. It is clear that better 
language support would be desirable. Moreover, the vast 
majority of modern OOP languages follows a model where where 
type inheritance and subtyping are conflated. That is a type extension 
induces a subtype. However as Cook et al.~\cite{} famously argued there 
are programs where ``\emph{subtyping is not inheritance}''. Although 
previously not many practical programs have been reported in the literature 
where the distinction between subtyping and inheritance is relevant, 
this difference does show up in practice when designing extensible 
programs\bruno{Improve English}. In particular, modular (extensible)  
visitors provide a compeling practical example where inheritance 
and subtyping should not be conflated.
 

 2) the
\emph{conflation of (type) extension with subtyping}.

The use of existing languages has shown that we can get quite far, but
it has also exposed some limitations. For example, work on object
algebras has shown that a delegation-based OO model would be better
suited for OAs. Moreover, Object Algebra composition can benefit from
intersection types. Additionally Object Algebras suffer from the
``Inheritance is not Subtyping'' problem~\cite{cook1989inheritance}.
Although there are very few examples in the literature illustrating
programs where the separating inheritance from subtyping is desirable,
object algebras illustrate a particularly compelling example of this.

Motivated by the insights gained in previous work, this paper presents 
a minimal core calculus that addresses current limitations and
provides a better foundational model for statically typed
delegation-based OOP? We show that Object Algebras fit nicely in this
model. 

This paper presents System \name: an extension of System F with
intersection types and a merge operator.  The goal of System \name is
to study the foundational language constructs that are needed to
support various extensible designs, while at the same time addressing
the limitations of existing OOP languages. To address the lack of good
object-level composition mechanisms, System \name uses the merge
operator to allow dynamic composition of values/objects. Moreover, in
System \name (type-level) extension is independent of subtyping, and
it is possible for an extension to be a supertype of a base object
type.  System \name is formalized and implemented. Furthermore the
paper illustrates how various extensible designs can be encoded in
System \name.

We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.

Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.

In summary, the contributions of this paper are:

\begin{itemize}

\item {\bf A Minimal Core Language for Extensibility:} This paper
  identifies a minimal core language, System \name, capable of
  expressing various extensibility designs in the literature.
  System \name also addresses limitations of existing OOP
  languages that complicate extensible designs. 
  
\item {\bf Formalization of System \name:} An elaboration semantics of
  System \name into System F is given, and type-soundness is proved.

\item {\bf Encodings of Extensible Designs:} Various encodings of
  extensible designs into System \name, including \emph{Object
    Algebras} and \emph{Modular Visitors}. 

\item {\bf Implementation and Examples:} An implementation of an
  extension of System \name, as well as the examples presented in the
  paper, are publicly available. 

\begin{comment}

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $ e $ has type $ \ty $ in the source language,
    then the translated term $ \image e $ is well-typed and has type $ \image \ty $ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{comment}

\end{itemize}

\subsection{Other Notes}

finitary overloading: yes
but have other merits of intersection been explored?

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]
