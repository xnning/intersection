\section{Introduction}

There has been a remarkable number of works aimed at improving support
for extensibility in programming languages. These works include:
visions of new programming models~\cite{}; new programming languages or
language extensions~\cite{}, and \emph{design patterns} that can be
used with existing mainstream languages~\cite{}.

%\cite{family polymorphism and virtual
%classes.}. Another line of work are proposals for precise formal models or new 
%programming languages. Yet another line are \emph{design patterns}
%that can be used  with existing mainstream languages. 
%%Part of the motivation behind 

Some of the more recent work on extensibility is focused on various
proposals for design patterns.  Examples include \emph{Object
  Algebras}~\cite{}, \emph{Modular Visitors}~\cite{} or
Torgersen's~\cite{} four design patterns using generics. In those
approaches the idea is to use some advanced (but already available)
features, such as \emph{generics}, in combination with conventional
OOP features to model more extensible designs.  Those designs work in
modern OOP languages such as Java, C\# or Scala.

Although such design patterns give practical benefits in terms of
extensibility, they also expose limitations in existing mainstream OOP
languages. In particular there are three pressing limitations: 
1) lack of good mechanisms for
  \emph{object-level} composition; 2) \emph{conflation of 
    (type) inheritance with subtyping}; 3) \emph{heavy reliance on generics}.

  The first limitation shows up, for example, in Oliveira et
  al.~\cite{} encodings of Feature-Oriented Programming using Object
  Algebras~\cite{}. These programs are best expressed using a form of
  \emph{type-safe}, \emph{dynamic}, \emph{delegation}-based
  composition. Although such form of composition can be encoded in
  languages like Scala, it requires the use of low-level reflection
  techniques, such as dynamic proxies, reflection or other forms of
  meta-programming~\cite{}. It is clear that better language support
  would be desirable.

  The second limitation shows up in designs for modelling
  modular or extensible visitors~\cite{}.  The vast majority of modern
  OOP languages combines type inheritance and subtyping. 
  That is a type extension induces a subtype. However
  as Cook et al.~\cite{} famously argued there are programs where
  ``\emph{subtyping is not inheritance}''. Interestingly previously
  not many practical programs have been reported in the literature
  where the distinction between subtyping and inheritance is
  relevant. However, as shown in this paper, it turns out that this
  difference does show up in practice when designing modular
  (extensible) visitors.  We believe that modular visitors provide a
  compeling practical example where inheritance and subtyping should
  not be conflated!

  Finally, the third limitation is prevalent in many extensible
  designs~\cite{}. Such designs rely on advanced features of generics,
  such as \emph{f-bounded polymorphism}~\cite{}, \emph{variance
    annotations}~\cite{}, \emph{wildcards}~\cite{} and/or \emph{higher-kinded
    types}~\cite{} to achieve type-safety. Sadly, the amount of
  type-annotations, combined with the lack of understanding of these
  features, usually deters programmers from using such designs.

\begin{comment}
Motivated by the insights gained in previous work, this paper presents 
a minimal core calculus that addresses current limitations and
provides a better foundational model for statically typed
delegation-based OOP? We show that Object Algebras fit nicely in this
model. 
\end{comment}

This paper presents System \name: an extension of System F~\cite{}
with intersection types and a merge operator~\cite{}.  The goal of
System \name is to study the \emph{minimal} foundational language
constructs that are needed to support various extensible designs,
while at the same time addressing the limitations of existing OOP
languages. To address the lack of good object-level composition
mechanisms, System \name uses the merge operator to allow dynamic
composition of values/objects. Moreover, in System \name (type-level)
extension is independent of subtyping, and it is possible for an
extension to be a supertype of a base object type. Furthermore,
intersection types and conventional subtyping can be used in many
cases instead of advanced features of generics. Indeed this paper 
shows how many previous designs in the literature can be encoded 
without such advanced features of generics.


Technically speaking System \name is mainly inspired by the work of
Dundfield~\cite{}.  Dundfield shows how to model a simply typed
calculus with intersection types and a merge operator. The presence of
a merge operator adds significant expressiveness to the language,
allowing encodings for many other language constructs as syntactic
sugar. System \name differs from Dundfield's work in a few
ways. Firstly it adds parametric polymorphism and formalizes a
extension for records to support a basic form of objects. Secondly,
the elaboration semantics into System F is done directly from the
source calculus with subtyping. In contrast Dunfield has an additional
step which eliminates subtyping.  Finally a non-technical difference
is that System \name is aimed at studying issues of OOP languages and
extensibility, whereas Dunfield's work was aimed at Functional
Programming and he did not consider applications to extensibility.
Like many other foundational formal models for OOP (for
example~\cite{}), System \name is purely functional and it uses
structural typing.

%%System \name is
%%formalized and implemented. Furthermore the paper illustrates how
%%various extensible designs can be encoded in System \name.

\begin{comment}
We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.
\end{comment}

In summary, the contributions of this paper are:

\begin{itemize}

\item {\bf A Minimal Core Language for Extensibility:} This paper
  identifies a minimal core language, System \name, capable of
  expressing various extensibility designs in the literature.
  System \name also addresses limitations of existing OOP
  languages that complicate extensible designs. 
  
\item {\bf Formalization of System \name:} An elaboration semantics of
  System \name into System F is given, and type-soundness is proved.

\item {\bf Encodings of Extensible Designs:} Various encodings of
  extensible designs into System \name, including \emph{Object
    Algebras} and \emph{Modular Visitors}. 

\item {\bf A Practical Example where ``Inheritance is not Subtyping''
    Matters:} This paper shows that in modular/extensible visitors
  suffer from the ``inheritance is not subtyping problem''. Moreover 
  with extensible visitors the extension should become a
  \emph{supertype}, not a subtype. \bruno{extension with accept method}

\item {\bf Implementation and Examples:} An implementation of an
  extension of System \name, as well as the examples presented in the
  paper, are publicly available. 

\begin{comment}

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $ e $ has type $ \tau $ in the source language,
    then the translated term $ \image e $ is well-typed and has type $ \image \tau $ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{comment}

\end{itemize}

\begin{comment}
\subsection{Other Notes}

finitary overloading: yes
but have other merits of intersection been explored?

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]
\end{comment}