\section{Introduction}

\bruno{The following are just some loose notes for the paper.}
Modularity has always been a hot topic on OOP research. 

Looking for new programming language models with increased
expressiveness in terms of modularity. 

Two previous lines of work: 

\begin{itemize}

\item development of new languages with more 
expressive mechanisms. Examples: family polymorphism and virtual
classes.

\item Use of existing languages to express more modular designs 
with existing features. In particular Object Algebras. 

\end{itemize} 

The use of existing languages has shown that we can get quite far, but 
it has also exposed some limitations. For example, work on object
algebras has shown that a delegation-based OO model would be better 
suited for OAs. Moreover, Object Algebra composition can benefit from 
intersection types. Additionally Object Algebras suffer from the
``Inheritance is not Subtyping'' problem. Although there are very few
examples in the literature illustrating programs where the separating 
inheritance from subtyping is desirable, object algebras illustrate a 
particularly compeling example of this. 

Motivated by the insights gained in previous work, this paper presents 
a minimal core calculus that addresses current limitations and
provides a better foundational model for statically typed
delegation-based OOP? We show that Object Algebras fit nicely in this
model. 


Lots of work on developing new languages 

finitary overloading: yes
but have other merits of intersection been explored?

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]

We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.

Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.

In summary, the contributions of this paper are:

\begin{itemize}

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $ e $ has type $ \ty $ in the source language,
    then the translated term $ \image e $ is well-typed and has type $ \image \ty $ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{itemize}
