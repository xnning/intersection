\section{Introduction}

\bruno{The following are just some loose notes for the paper.}

There has been a remarkable number of works aimed at improving 
support for extensibility in programming languages. One line of work
is simply visions of new programming models, such as 
\cite{family polymorphism and virtual
classes.}. Another line of work are proposals for precise formal models or new 
programming languages. Yet another line are \emph{design patterns}
that can be used  with existing mainstream languages. 

%%Part of the motivation behind 

Over the years there have been various proposals for \emph{design
  patterns} for improved \emph{extensibility} of programs.  Examples
include \emph{Object Algebras}, \emph{Modular Visitors} or Torgersen's
four design patterns using generics.  Although those design patterns
give practical benefits in terms of extensibility, they also expose
limitations in existing mainstream OOP languages. In particular two
pressing limitations are: 1) the lack of good mechanisms for
\emph{object-level} composition; 2) the \emph{conflation of (type)
  extension with subtyping}.

The use of existing languages has shown that we can get quite far, but 
it has also exposed some limitations. For example, work on object
algebras has shown that a delegation-based OO model would be better 
suited for OAs. Moreover, Object Algebra composition can benefit from 
intersection types. Additionally Object Algebras suffer from the
``Inheritance is not Subtyping'' problem. Although there are very few
examples in the literature illustrating programs where the separating 
inheritance from subtyping is desirable, object algebras illustrate a 
particularly compeling example of this. 

Motivated by the insights gained in previous work, this paper presents 
a minimal core calculus that addresses current limitations and
provides a better foundational model for statically typed
delegation-based OOP? We show that Object Algebras fit nicely in this
model. 

This paper presents System \name: an extension of System F with
intersection types and a merge operator.  The goal of System \name is
to study the foundational language constructs that are needed to
support various extensible designs, while at the same time addressing
the limitations of existing OOP languages. To address the lack of good
object-level composition mechanisms, System \name uses the merge
operator to allow dynamic composition of values/objects. Moreover, in
System \name (type-level) extension is independent of subtyping, and
it is possible for an extension to be a supertype of a base object
type.  System \name is formalized and implemented. Furthermore the
paper illustrates how various extensible designs can be encoded in
System \name.

We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.

Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.

In summary, the contributions of this paper are:

\begin{itemize}

\item {\bf System $name$:} 

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $ e $ has type $ \ty $ in the source language,
    then the translated term $ \image e $ is well-typed and has type $ \image \ty $ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{itemize}

\subsection{Other Notes}

finitary overloading: yes
but have other merits of intersection been explored?

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]
