\section{The \name calculus}

\footnote{Joshua Dunfield}

This section formalizes the syntax, subtyping, and typing of \name. In the next
section, we will go through the type-directed translation from \name to System
F.

% Note the semantics of this language is not defined formally, instead, by a
% translation into the target language, System F.

\subsection{Syntax}

The syntax of the \name calculus extends System F by adding the two features:
intersection types and records. The formalization includes only single records
because single record types as the multi-records can be desugared into the merge
of multiple single records.

\input{rules/fi-syntax.tex}

% Types
Types $ t $ have five constructs. The first three are standard (present in
System F): type variable $ \alpha $, function types $ t \to t $, and type
abstraction $ \forall \alpha. t $; while the last two, intersection types
$ t \with t $ and record types $ \recordtype{l}{t} $, are novel in \Name. In
record types, $ l $ is the label and $ t $ the type.

% Expressions - standard ones
First five constructs of expressions are also standard: variables $ x $ and two
abstraction-elimination pairs. $ \abs{\rel{x}{t}}{e} $ abstracts expression
$ e $ over values of type $ t $ and is eliminated by application $ \app{e}{e} $;
$ \Abs{\alpha}{e} $ abstracts expression $ e $ over types and is eliminated by
type application $ \app{e}{t} $.

% Expressions - new ones
The last four constructs are novel. $ e \dcomma e $ is the \emph{merge} of two
terms. $ \recordintro{l}{e} $ introduces a record literal having $ l $ as the
label for field containing expression $ e $ . $ e.l $ access the field with
label $ l $ in $ e $. Finally, $ \recordupdate{e}{l}{e} $ updates the field
labelled $ l $ in expression $ e $. For simplicity, we omit other constructs in
order to focus on the essence of the calculus. For example, fixpoints can be
added in standard ways.

% Fields
The field $ F $ is non-standard and introduced to deal with records. It is an
associative list. Each item is a pair whose first item is either empty or a
label and the second the types.

% The most central construct of our language is ...

% Dunfield has described a language that includes a ``top'' type but it does not appear in our language. Our work differs from Dunfield in that ...

% Remark. The operational semantics of FI is not presented in this paper. However,

\subsection{Subtyping}

\begin{figure*}
\input{rules/fi-sub.tex}
\caption{Subtyping}
\end{figure*}

Thanks to intersection types, we have natural subtyping relations among types.
For example, $ Int \with Bool $ should be a subtype of $ Int $, since the former
can be viewed as either $ Int $ or $ Bool $. The subtyping rules are standard
except for three points listed below:
\begin{enumerate}
\item $ t_1 \with t_2 $ is a subtype of $ t_3 $, if \emph{either} $ t_1 $ or
  $ t_2 $ are subtypes of $ t_3 $,

\item $ t_1 $ is a subtype of $ t_2 \with t_3 $, if $ t_1 $ is a subtype of
  both $ t_2 $ and $ t_3 $.

\item $ \recordtype{l_1}{t_1} $ is a subtype of $ \recordtype{l_2}{t_2} $, if
  $ l_1 $ and $ l_2 $ are identical and $ t_1 $ is a subtype of $ t_2 $.
\end{enumerate}
The first point is captured by two rules \texttt{S-And-1} and \texttt{S-And-2},
whereas the second point by \texttt{S-And-3}. Note that the last point means
that record types are covariant in the type of the fields.

\subsection{Typing}

\begin{figure*}
\input{rules/fi-wf.tex}
\caption{Well-formedness}
\end{figure*}

\begin{figure*}
\input{rules/fi-typing.tex}
\input{rules/fi-get.tex}
\input{rules/fi-put.tex}
\caption{Typing}
\end{figure*}

The typing judgment for \name is of the form: $ \Gamma \vdash e : t $. This
judgment uses the context $ \Gamma $. The typing rules for our core languages
are mostly standard ones for System F. In particular we introduce a
\texttt{T-Merge} rule that applies to \emph{merge} constructs.

The last two rules make use of the $ \texttt{fields} $ function just to make
sure that the field being accessed (\texttt{T-RcdElim}) or updated
(\texttt{T-RcdUpd}) actually exists. The function is defined recursively, in
Haskell pseudocode, as:
\[ \begin{array}{rll}
  \fields{\alpha} & = & \rel{\cdot}{\alpha} \\
  \fields{t_1 \to t_2} & = & \rel{\cdot}{t_1 \to t_2} \\
  \fields{\forall \alpha. t} & = & \rel{\cdot}{\forall \alpha. t} \\
  \fields{t_1 \with t_2} & = & \fields{t_1} \dplus \fields{t_2} \\
  \fields{\recordtype{l}{t}} & = & \rel{l}{t}
\end{array} \]
where $ \cdot $ means empty list, $ \dplus $ list concatenation, and $ : $ is an
infix operator that prepend the first argument to the second. The function
returns an associative list whose domain is field labels and range types.

\textit{dom} reads: ``the domain of''. $ F(l) $ means the result of lookup for
$ l $ inside the associative list $ F $. The order of lookup can be either from
left to right or from right to left but has to be consistent inside one
implementation. We prefer the order from the right to the left because it make
possible record overriding. For example,
$ (\recordintro{count}{1} ,, \recordintro{count}{2}).count $ will evaluate to
$ 2 $ in this case.