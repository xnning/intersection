\section{The \name calculus}

\paragraph{Why no union types?}

\paragraph{Why no empty records?}

Limitations of encoding records as intersections
Local type inference

% { instruction = ``Buy'' } ,, { instruction = ``Sell'' }
% def merge[A,B](x: A)(y: B) = x ,, y
% id { instruction = ``Buy'' } { instruction = ``Sell'' }
% id : forall A B. A -> B -> A & B

\footnote{Joshua Dunfield}

This section formalizes the syntax, subtyping, and typing of \name. In the next
section, we will go through the type-directed translation from \name to System
F.

% Note the semantics of this language is not defined formally, instead, by a
% translation into the target language, System $ F $.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} specifies the syntax of \Name. It extends the syntax
of System $ F $ by adding the two features: intersection types and records. The
formalization includes only single records because single record types as the
multi-records can be desugared into the merge of multiple single records.

\begin{figure}
  \input{rules/fi-syntax.tex}
  \caption{Syntax of \name}
  \label{fig:fi-syntax}
\end{figure}

% Types
Types $ \ty $ have five constructs. The first three are standard (present in
System $ F $): type variable $ \alpha $, function types $ \ty \to \ty $, and type
abstraction $ \forall \alpha. \ty $; while the last two, intersection types
$ \ty \intersects \ty $ and record types $ \recordtype l \ty $, are novel in \Name. In
record types, $ l $ is the label and $ \ty $ the type.

% Expressions - standard ones
First five constructs of expressions are also standard: variables $ x $ and two
abstraction-elimination pairs. $ \abs {\rel x \ty} e $ abstracts expression
$ e $ over values of type $ \ty $ and is eliminated by application $ \app e e $;
$ \Abs \alpha e $ abstracts expression $ e $ over types and is eliminated by
type application $ \app e \ty $.

% Expressions - new ones
The last four constructs are novel. $ e \dcomma e $ is the \emph{merge} of two
terms. $ \recordintro l e $ introduces a record literal having $ l $ as the
label for field containing expression $ e $ . $ e.l $ access the field with
label $ l $ in $ e $. Finally, $ \recordupdate e l {e_1} $ is a \emph{new}
record which is exactly the same as $ e $ except the field labelled $ l $ is
updated to become $ e1 $. For simplicity, we omit other constructs in order to
focus on the essence of the calculus. For example, fixpoints can be added in
standard ways.

% Fields
The field $ F $ is non-standard and introduced to deal with records. It is an
associative list. Each item is a pair whose first item is either empty or a
label and the second the types.

% The most central construct of our language is ...

% Dunfield has described a language that includes a ``top'' type but it does not appear in our language. Our work differs from Dunfield in that ...

% Remark. The operational semantics of FI is not presented in this paper. However,

\subsection{Subtyping}

Subtyping is transitive and forms a lattice?
Do we have a subtyping lattice?

\begin{figure}
\input{rules/fi-sub.tex}
\caption{Subtyping}
\end{figure}

Intersection types introduce natural subtyping relations among types. For
example, $ Int \intersects Bool $ should be a subtype of $ Int $, since the
former can be viewed as either $ Int $ or $ Bool $. The subtyping rules are
standard except for three points listed below:
\begin{enumerate}
\item $ \ty_1 \intersects \ty_2 $ is a subtype of $ \ty_3 $, if \emph{either} $ \ty_1 $ or
  $ \ty_2 $ are subtypes of $ \ty_3 $,

\item $ \ty_1 $ is a subtype of $ \ty_2 \intersects \ty_3 $, if $ \ty_1 $ is a subtype of
  both $ \ty_2 $ and $ \ty_3 $.

\item $ \recordtype {l_1} {\ty_1} $ is a subtype of $ \recordtype {l_2} {\ty_2} $, if
  $ l_1 $ and $ l_2 $ are identical and $ \ty_1 $ is a subtype of $ \ty_2 $.
\end{enumerate}
The first point is captured by two rules \rulename{S-And-1} and \rulename{S-And-2},
whereas the second point by \rulename{S-And-3}. Note that the last point means
that record types are covariant in the type of the fields.

\subsection{Typing}

\begin{figure}
\input{rules/fi-wf.tex}
\caption{Well-formedness}
\end{figure}

\begin{figure}
\input{rules/fi-typing.tex}
\input{rules/fi-get.tex}
\input{rules/fi-put.tex}
\caption{Typing}
\end{figure}

The typing judgment for \name is of the form: $ \Gamma \turns e : \ty $. This
judgment uses the context $ \Gamma $. The typing rules for our core languages
are mostly standard ones for System $ F $. In particular we introduce a
\rulename{T-Merge} rule that applies to \emph{merge} constructs.

% The last two rules make use of the $ \rulename{fields} $ function just to make
% sure that the field being accessed (\rulename{T-RcdElim}) or updated
% (\rulename{T-RcdUpd}) actually exists. The function is defined recursively, in
% Haskell pseudocode, as:
% \[ \begin{array}{rll}
%   \fields{\alpha} & = & \rel{\cdot} {\alpha} \\
%   \fields{\ty_1 \to \ty_2} & = & \rel{\cdot} {\ty_1 \to \ty_2} \\
%   \fields{\forall \alpha. \ty} & = & \rel{\cdot} {\forall \alpha. \ty} \\
%   \fields{\ty_1 \intersects \ty_2} & = & \fields{\ty_1} \dplus \fields{\ty_2} \\
%   \fields{\recordtype l \ty} & = & \rel l t
% \end{array} \]
% where $ \cdot $ means empty list, $ \dplus $ list concatenation, and $ : $ is an
% infix operator that prepend the first argument to the second. The function
% returns an associative list whose domain is field labels and range types.

\textit{dom} reads: ``the domain of''. $ F(l) $ means the result of lookup for
$ l $ inside the associative list $ F $. The order of lookup can be either from
left to right or from right to left but has to be consistent inside one
implementation. We prefer the order from the right to the left because it make
possible record overriding. For example,
$ (\recordintro{count} {1} ,, \recordintro{count} {2}).count $ will evaluate to
$ 2 $ in this case.