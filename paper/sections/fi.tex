\section{The \name calculus}

Following Dunfield's~\cite{dunfield2014elaborating} work on a simply-typed
lambda calculus with intersection and union types, we present the syntax,
subtyping, and typing of \name. The semantics of \name, on the other hand, will
be defined by a type-directed translation from \name to a simple variant of
System $F$, which will be covered in the next section.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} shows the syntax of \name (with the addition to
System $F$ highlighted). As a convention in this paper, we will be using
lowercase letters as meta-variables for sorts in \name, and uppercase letters
for those in System $F$ (starting to appear in the next section).

% To System $ F $, we add two features: intersection types and single-field
% records.
% % ~\bruno{labelled types (single field records are fine too)} 
% We include only single records because single record types as the multi-records
% can be desugared into the merge of multiple single records.

\begin{figure}[h]
  \input{rule_in_figures/fi-syntax.tex}
  \caption{Syntax of \name.}
  \label{fig:fi-syntax}
\end{figure}

We use the meta-variable $\tau$ to range over types. Types include System $F$
constructs variable $ \alpha $; function types $ \tau_1 \to \tau_2 $; and type
abstraction $ \for \alpha \tau $. $ \tau_1 \andop \tau_2 $ denotes the
intersection of type $ \tau_1 $ and $ \tau_2 $; and $ \recty l \tau $ the types
for single-field records. Single-field record types can be viewed as types
tagged with a label $l$, while the other type forms are untagged types.
% \bruno{be consistent: in the source language we use \&, and in the
% formalization we use $\andop$}

Expressions are ranged over by meta-variables $e$. 
Standard constructs in System $F$ are 
variables $ x $; 
abstraction of expressions over variables of a given type $ \lam x \tau e $ (concretely written \lstinline$\(x:T) -> e$); 
abstraction of expressions over types $ \blam \alpha e $ (concretely written \lstinline$/\A -> e$); 
value application $ \app e_1 e_2 $;
and type application $ \tapp e \tau $ (concretely written \lstinline$e[T]$). 
The last four constructs are new: $ e_1 \mergeop e_2 $ 
is the \emph{merge} of two expressions $ e_1 $ and $ e_2 $.
% \bruno{explain further, after all this is new.}
It can be used as either $ e_1 $ or $ e_2 $. Particarly, if one regard $ e_1 $
and $ e_2 $ as objects, their merge will responds to every method that one or
both of them have. Merge of expressions correspond to intersection types
$ \tau_1 \andop \tau_2 $. $ \reccon l e $ constructs a single-field record.
$ e.l $ accesses the field labelled $ l $ in $ e $. Note that $ e $ does not
need to be a record type in this case. For example, although the merge of two
records
\[
x = \reccon {l_1} {e_1} \mergeop \reccon {l_1} {e_2} 
\]
is of an intersection type, $ x.{l_1} $ still gives $ e_1 $. On the other hand,
$ x.{l_3} $ will be rejected by the type system. Functional update $ \recupd e l {e_1} $ a
\emph{new} record which is exactly the same as $ e $ except the field labelled
$ l $ is updated to become $ e1 $. In order to focus on the most essential
features, we do not include other forms such as fixpoints here, although they
have are supported in our implementation and can be included in formalization in
standard ways.

\bruno{Talking about type-checking before type-checking is discussed!}
% \bruno{What field $F$? I don't know what this is refering to!}

Typing contexts $ \gamma $ track bound type variables and variables (and their
type $\tau$). We use $l$ for labels, whose nature is left undefined.

\paragraph{Discussion.} A natural question the reader might ask is that why we
have excluded union types from the language. The answer is we found that
intersection types alone are enough support extensible designs. To focus on the
key features that make this language interesting, we also omit other common
constructs. For example, fixpoints can be added in standard ways.
% Dunfield has described a language that includes a ``top'' type but it does not
% appear in our language. Our work differs from Dunfield in that ...

\subsection{Subtyping}

\george{Explain the subst syntax.}\bruno{Just say, in 1 sentence: 
the syntax means substitution, and the substitution function is standard 
and thus ommitted.}

\george{However, have we forbidden the interplay of subtyping relations
  explicitly declared by programmers as seen in class-based OO languages?}
\bruno{Discuss somewhere (perhaps in related work) that although 
our system is structural, we could apply the idea of separating 
inheritance and subtyping to a nominal language. Point out related work.}

\bruno{Intersection types require a simple form of subtyping. The subtyping
  relation is reflexive and transitive. Our subtyping relation follows previous
  work. Need to cite! The main difference is the interaction with parametric
  polymorphism.}

In some calculi such as System $ F_{\subtype} $, the subtyping relation is
orthogoal to other language features: those calculi are indifferent with how the
subtyping relation is defined. In \name, we take a syntatic approach, that is,
subtyping is due to solely of intersection and function types.

\begin{figure*}
  \input{rule_in_figures/fi-sub.tex}
  \caption{Subtyping in \name.}
  \label{fig:fi-subtyping}
\end{figure*}

% \bruno{Fix the overflow. For example by using 2 lines in
%   the conclusion.}
% \bruno{Subtyping figure is doing the translation already?}

Intersection types introduce natural subtyping relations among types. For
example, $ \Int \andop \Bool $ should be a subtype of $ \Int $, since the
former can be viewed as either $ \Int $ or $ \Bool $. To summarize, the
subtyping rules are standard except for three points listed below:
\begin{enumerate}
\item $ \tau_1 \andop \tau_2 $ is a subtype of $ \tau_3 $, if \emph{either} $ \tau_1 $ or
  $ \tau_2 $ are subtypes of $ \tau_3 $,

\item $ \tau_1 $ is a subtype of $ \tau_2 \andop \tau_3 $, if $ \tau_1 $ is a subtype of
  both $ \tau_2 $ and $ \tau_3 $.

\item $ \recty {l_1} {\tau_1} $ is a subtype of $ \recty {l_2} {\tau_2} $, if
  $ l_1 $ and $ l_2 $ are identical and $ \tau_1 $ is a subtype of $ \tau_2 $.
\end{enumerate}
The first point is captured by two rules $ \rulelabelsubandleft $ and
$ \rulelabelsubandright $, whereas the second point by $ \rulelabelsuband $. Note that the
last point means that record types are covariant in the type of the fields.

% The subtyping relation is reflexive and transitive.

\subsection{Typing}

\begin{figure*}
\input{rule_in_figures/fi-typing.tex}
\begin{mathpar}
\framebox{$\judgeget {\tau_1} l \tau_2$}

\ruleget

\rulegetleft

\rulegetright
\end{mathpar}
\begin{mathpar}
\framebox{$\judgeput \tau l \tau {\tau_2} {\tau_3}$}

\ruleput

\ruleputleft

\ruleputright
\end{mathpar}
\caption{The type system of \name.}
  \label{fig:fi-typing}
\end{figure*}

The typing of \name is shown in Figure~\ref{fig:fi-typing}. The typing judgment
is of the form: $ \judgee \gamma e \tau $. It says that ``in the typing context
$\gamma$, the expression $e$ is of type $\tau$''. The rules that are the same as
in System $F$ are rules for variables ($\rulelabelevar$), lambda abstractions
($\rulelabelelam$), type abstraction ($\rulelabeleblam$), and type application
($\rulelabeletapp$). The rule $\rulelabeleapp$ needs special attention. To cater
to the subtyping relations, we additionally require the type of the argument
($\tau_3$) be a subtype of that of the parameter ($\tau_1$). For merges like
$e_1 \mergeop e_2$, we typechecks $e_1$ and $e_2$ respectively, and give it the
intersection of the resulting types $\tau_1 \andop \tau_2$. The rule for
single-field record construction ($\rulelabelereccon$) is standard. For record
projection ($\rulelabelerecsel$) and update ($\rulelabelerecupd$), we resort to
the auxiliary ``get'' and ``put'' rules the check that the operations are valid.
The ``get'' judgment checks if a field $ l $ indeed exists in a type $ \tau $
and fetches the type of the field if so. The ``put'' judgment is almost similar,
except that it takes the intended update (both expression and type), and returns
in addition a new type of the expression. In record updates, we allow refining
the type of the field in question.

% \bruno{Sort the rules by those, which are exactly the same as System F,
%   following by those which are different (application) and finally the rules for
%   the new constructs.}

\bruno{A lot more explanation needed here! You want to
   explain: 1) the rules which are different, and why they are
   different; 2) the new rules and the intuition for the new rules.
   For the new rules have text for each of them.}

% The last two rules make use of the $ \rulename{fields} $ function just to make
% sure that the field being accessed ($ \rulelabelerecsel $) or updated
% ($ \rulelabelerecupd $) actually exists. The function is defined recursively, in
% Haskell pseudocode, as:
% \[ \begin{array}{rll}
%   \fields{\alpha} & = & \rel{\cdot} {\alpha} \\
%   \fields{\tau_1 \to \tau_2} & = & \rel{\cdot} {\tau_1 \to \tau_2} \\
%   \fields{\forall \alpha. \tau} & = & \rel{\cdot} {\forall \alpha. \tau} \\
%   \fields{\tau_1 \andop \tau_2} & = & \fields{\tau_1} \dplus \fields{\tau_2} \\
%   \fields{\recty l \tau} & = & \rel l t
% \end{array} \]
% where $ \cdot $ means empty list, $ \dplus $ list concatenation, and $ : $ is an
% infix operator that prepend the first argument to the second. The function
% returns an associative list whose domain is field labels and range types.
