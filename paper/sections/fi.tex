\section{The \name calculus}

% { instruction = ``Buy'' } ,, { instruction = ``Sell'' }
% def merge[A,B](x: A)(y: B) = x ,, y
% id { instruction = ``Buy'' } { instruction = ``Sell'' }
% id : forall A B. A -> B -> A & B

\footnote{Joshua Dunfield}

This section formalizes the syntax, subtyping, and typing of \name. In the next
section, we will go through the type-directed translation from \name to System
F.\bruno{Mention Dundfield}

% Note the semantics of this language is not defined formally, instead, by a
% translation into the target language, System $ F $.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} shows the syntax of \name. It is System $ F $ at its
core. To System $ F $, we add two features: intersection types and single-field
records~\bruno{labelled types (single field records are fine too)}. We include
only single records because single record types as the multi-records can be
desugared into the merge of multiple single records.

\begin{figure}
  \input{rules/fi-syntax.tex}
  \caption{Syntax of \name}
  \label{fig:fi-syntax}
\end{figure}

\paragraph{Types.} The constructs in the first row of types in
Figure~\ref{fig:fi-syntax} are standard in System $ F $: type variable
$ \alpha $, function types $ \ty \to \ty $, and type abstraction
$ \forall \alpha. \ty $. The last two are novel. $ \ty_1 \intersects \ty_1 $ is
the intersection of type $ \ty_1 $ and $ \ty_2 $, \bruno{be consistent: in the
  source language we use \&, and in the formalization we use $\intersects$} and
$ \recordtype l \ty $ are the types for single-field records.

\paragraph{Expressions.} The first five constructs of expressions are also
standard: variables $ x $, and two abstraction-elimination pairs: lambda
expressions $ \abs {\rel x \ty} e $ abstract expression $ e $ over values of
type $ \ty $ and are eliminated by application $ \app e e $; Big lambdas
$ \Abs \alpha e $ abstract expression $ e $ over types and are eliminated by
type application $ \app e \ty $. In the source language, lambdas are written as
\george{TODO} and big lambdas as \george{TODO}.

The last four constructs are new: $ e_1 \dcomma e_2 $ is the \emph{merge} of two
expressions $ e_1 $ and $ e_2 $.\bruno{explain further, after all this is new.}
It can be used as either $ e_1 $ or $ e_2 $. Particarly, if one regard $ e_1 $
and $ e_2 $ as objects, their merge will responds to every method that one or
both of them have. Merge of expressions correspond to intersection types
$ \ty_1 \intersects \ty_2 $. $ ecordcon l e $ constructs a single-field
record. $ e.l $ access the field labelled $ l $ in $ e $. Note that $ e $ does
not need to be a record type. For example, the merge of two records
$ ecordcon l_1 e_1 \dcomma ecordcon l_1 e_2 $ is an intersection type.
Functional update $ \recordupdate e l {e_1} $ a \emph{new} record which is
exactly the same as $ e $ except the field labelled $ l $ is updated to become
$ e1 $. \bruno{What field $F$? I don't know what this is refering to!}

\paragraph{Context.} Context $ \Gamma $ is also standard. It maps variables to
their types and keeps bound type variables.

\paragraph{Discussion.} A natural question the reader might ask is that why we
have excluded union types from the language. The answer is we found that
intersection types alone are enough support extensible designs. To focus on the
key features that make this language interesting, we also omit other common
constructs. For example, fixpoints can be added in standard ways.
% Dunfield has described a language that includes a ``top'' type but it does not
% appear in our language. Our work differs from Dunfield in that ...

\subsection{Subtyping}

\george{Explain the subst syntax.}

Due to intersection types, the types form a subtyping relation. The subtyping
relation is reflexive and transitive.

\bruno{Intersection types require a simple form of subtyping. The subtyping
  relation is reflexive and transitive. Our subtyping relation follows previous
  work. Need to cite! The main difference is the interaction with parametric
  polymorphism }

\begin{figure}
\input{rules/fi-sub.tex}
\caption{Subtyping}
\end{figure}\bruno{Fix the overflow. For example by using 2 lines in
  the conclusion.}\bruno{Subtyping figure is doing the translation already?}

Intersection types introduce natural subtyping relations among types. For
example, $ Int \intersects Bool $ should be a subtype of $ Int $, since the
former can be viewed as either $ Int $ or $ Bool $. The subtyping rules are
standard except for three points listed below:
\begin{enumerate}
\item $ \ty_1 \intersects \ty_2 $ is a subtype of $ \ty_3 $, if \emph{either} $ \ty_1 $ or
  $ \ty_2 $ are subtypes of $ \ty_3 $,

\item $ \ty_1 $ is a subtype of $ \ty_2 \intersects \ty_3 $, if $ \ty_1 $ is a subtype of
  both $ \ty_2 $ and $ \ty_3 $.

\item $ \recordtype {l_1} {\ty_1} $ is a subtype of $ \recordtype {l_2} {\ty_2} $, if
  $ l_1 $ and $ l_2 $ are identical and $ \ty_1 $ is a subtype of $ \ty_2 $.
\end{enumerate}
The first point is captured by two rules \rulename{S-And-1} and \rulename{S-And-2},
whereas the second point by \rulename{S-And-3}. Note that the last point means
that record types are covariant in the type of the fields.

\subsection{Typing}

\begin{figure}
\input{rules/fi-wf.tex}
\caption{Well-formedness}
\end{figure}

\begin{figure}
\input{rules/fi-typing.tex}
\input{rules/fi-get.tex}
\input{rules/fi-put.tex}
\caption{Typing}
\end{figure}

The typing judgment for \name is of the form: $ \Gamma \turns e : \ty $. This
judgment uses the context $ \Gamma $. The typing rules for our core languages
are mostly standard ones for System $ F $. \bruno{Sort the rules by
  those, which are exactly the same as System F, following by those
  which are different (application) and finally the rules for the new constructs.}
In particular we introduce a
\rulename{T-Merge} rule that applies to \emph{merge}
constructs.\bruno{A lot more explanation needed here! You want to
  explain: 1) the rules which are different, and why they are
  different; 2) the new rules and the intuition for the new rules.}

% The last two rules make use of the $ \rulename{fields} $ function just to make
% sure that the field being accessed (\rulename{T-RcdElim}) or updated
% (\rulename{T-RcdUpd}) actually exists. The function is defined recursively, in
% Haskell pseudocode, as:
% \[ \begin{array}{rll}
%   \fields{\alpha} & = & \rel{\cdot} {\alpha} \\
%   \fields{\ty_1 \to \ty_2} & = & \rel{\cdot} {\ty_1 \to \ty_2} \\
%   \fields{\forall \alpha. \ty} & = & \rel{\cdot} {\forall \alpha. \ty} \\
%   \fields{\ty_1 \intersects \ty_2} & = & \fields{\ty_1} \dplus \fields{\ty_2} \\
%   \fields{\recordtype l \ty} & = & \rel l t
% \end{array} \]
% where $ \cdot $ means empty list, $ \dplus $ list concatenation, and $ : $ is an
% infix operator that prepend the first argument to the second. The function
% returns an associative list whose domain is field labels and range types.

\textit{dom} reads: ``the domain of''. $ F(l) $ means the result of lookup for
$ l $ inside the associative list $ F $. The order of lookup can be either from
left to right or from right to left but has to be consistent inside one
implementation. We prefer the order from the right to the left because it make
possible record overriding. For example,
$ (ecordcon{count} {1} ,, ecordcon{count} {2}).count $ will evaluate to
$ 2 $ in this case.