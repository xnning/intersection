\section{The \name calculus}

% { instruction = ``Buy'' } ,, { instruction = ``Sell'' }
% def merge[A,B](x: A)(y: B) = x ,, y
% id { instruction = ``Buy'' } { instruction = ``Sell'' }
% id : forall A B. A -> B -> A & B

% \footnote{Joshua Dunfield}

Following Dunfield's~\cite{dunfield2014elaborating} work on simply-typed lambda
calculus with intersection and union types, we formalize the syntax, subtyping,
and typing of \name. In the next section, we will go through the type-directed
translation from \name to System F.

% \bruno{Mention Dundfield}

% Note the semantics of this language is not defined formally, instead, by a
% translation into the target language, System $ F $.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} shows the syntax of \name. It is System $ F $ at its
core. To System $ F $, we add two features: intersection types and single-field
records.
% ~\bruno{labelled types (single field records are fine too)} 
We include only single records because single record types as the multi-records
can be desugared into the merge of multiple single records.

\begin{figure}
  \input{rules/fi-syntax.tex}
  \caption{Syntax of \name.}
  \label{fig:fi-syntax}
\end{figure}

\paragraph{Types.} The constructs in the first row of types in
Figure~\ref{fig:fi-syntax} are standard in System $ F $: type variable
$ \alpha $, function types $ \tau \to \tau $, and type abstraction
$ \Forall \alpha \tau $. The last two are novel. $ \tau_1 \Intersect \tau_1 $ is
the intersection of type $ \tau_1 $ and $ \tau_2 $, 
% \bruno{be consistent: in the source language we use \&, and in the
% formalization we use $\Intersect$}
and $ \RecTy l \tau $ are the types for single-field records.

\paragraph{Expressions.} The first five constructs of expressions are also
standard: variables $ x $, and two abstraction-elimination pairs: lambda
expressions $ \Lam x \tau e $ abstract expression $ e $ over values of
type $ \tau $ and are eliminated by application $ \App e e $; Big lambdas
$ \BLam \alpha e $ abstract expression $ e $ over types and are eliminated by
type application $ \App e \tau $. In the source language, lambdas are written as
\george{TODO} and big lambdas as \george{TODO}.

The last four constructs are new: $ e_1 \Merge e_2 $ is the \emph{merge} of two
expressions $ e_1 $ and $ e_2 $.
% \bruno{explain further, after all this is new.}
It can be used as either $ e_1 $ or $ e_2 $. Particarly, if one regard $ e_1 $
and $ e_2 $ as objects, their merge will responds to every method that one or
both of them have. Merge of expressions correspond to intersection types
$ \tau_1 \Intersect \tau_2 $. $ \RecCon l e $ constructs a single-field record.
$ e.l $ accesses the field labelled $ l $ in $ e $. Note that $ e $ does not
need to be a record type in this case. For example, although the merge of two
records
\[
x = \RecCon {l_1} {e_1} \Merge \RecCon {l_1} {e_2} 
\]
is of an intersection type, $ x.{l_1} $ still gives $ e_1 $. On the other hand,
$ x.{l_3} $ does not type check. Functional update $ \RecUpd e l {e_1} $ a
\emph{new} record which is exactly the same as $ e $ except the field labelled
$ l $ is updated to become $ e1 $.
\bruno{Talking about type-checking before type-checking is discussed!}
% \bruno{What field $F$? I don't know what this is refering to!}

\paragraph{Context.} Context $ \Gamma $ is also standard. It maps variables to
their types and keeps bound type variables.

\paragraph{Discussion.} A natural question the reader might ask is that why we
have excluded union types from the language. The answer is we found that
intersection types alone are enough support extensible designs. To focus on the
key features that make this language interesting, we also omit other common
constructs. For example, fixpoints can be added in standard ways.
% Dunfield has described a language that includes a ``top'' type but it does not
% appear in our language. Our work differs from Dunfield in that ...

\subsection{Subtyping}

\george{Explain the subst syntax.}\bruno{Just say, in 1 sentence: 
the syntax means substitution, and the substitution function is standard 
and thus ommitted.}

\george{However, have we forbidden the interplay of subtyping relations
  explicitly declared by programmers as seen in class-based OO languages?}
\bruno{Discuss somewhere (perhaps in related work) that although 
our system is structural, we could apply the idea of separating 
inheritance and subtyping to a nominal language. Point out related work.}

\bruno{Intersection types require a simple form of subtyping. The subtyping
  relation is reflexive and transitive. Our subtyping relation follows previous
  work. Need to cite! The main difference is the interaction with parametric
  polymorphism.}

In some calculi such as System $ F_{\subtype} $, the subtyping relation is
orthogoal to other language features: those calculi are indifferent with how the
subtyping relation is defined. In \name, we take a syntatic approach, that is,
subtyping is due to solely of intersection and function types.

\begin{figure}
\input{rules/fi-sub.tex}
\caption{Subtyping in \name.}
\end{figure}

% \bruno{Fix the overflow. For example by using 2 lines in
%   the conclusion.}
% \bruno{Subtyping figure is doing the translation already?}

Intersection types introduce natural subtyping relations among types. For
example, $ \Int \Intersect \Bool $ should be a subtype of $ \Int $, since the
former can be viewed as either $ \Int $ or $ \Bool $. To summarize, the
subtyping rules are standard except for three points listed below:
\begin{enumerate}
\item $ \tau_1 \Intersect \tau_2 $ is a subtype of $ \tau_3 $, if \emph{either} $ \tau_1 $ or
  $ \tau_2 $ are subtypes of $ \tau_3 $,

\item $ \tau_1 $ is a subtype of $ \tau_2 \Intersect \tau_3 $, if $ \tau_1 $ is a subtype of
  both $ \tau_2 $ and $ \tau_3 $.

\item $ \RecTy {l_1} {\tau_1} $ is a subtype of $ \RecTy {l_2} {\tau_2} $, if
  $ l_1 $ and $ l_2 $ are identical and $ \tau_1 $ is a subtype of $ \tau_2 $.
\end{enumerate}
The first point is captured by two rules \rulename{S-And1} and
\rulename{S-And2}, whereas the second point by \rulename{S-And3}. Note that the
last point means that record types are covariant in the type of the fields.

% The subtyping relation is reflexive and transitive.

\subsection{Typing}

\begin{figure}
\input{rules/fi-wf.tex}
\caption{Well-formedness}
\end{figure}

\begin{figure*}
\input{rules/fi-typing.tex}
\begin{mathpar}
\framebox{$\judgeget {\tau_1} l \tau_2$}

\ruleget

\rulegetleft

\rulegetright
\end{mathpar}
\begin{mathpar}
\framebox{$\judgeput \tau l \tau {\tau_2} {\tau_3}$}

\ruleput

\ruleputleft

\ruleputright
\end{mathpar}
\caption{The type system of \name.}
\end{figure*}

The typing judgment for \name is of the form: $ \Gamma \turns e : \tau $. This
judgment uses the context $ \Gamma $. The rules for variables, abstraction, type
abstraction, and type application are standard in System $ F $. To cater to the
subtyping relations and avoid having undeterministic rules, in \rulename{App},
we additionally require the type of the argument be a subtype of the parameter.
The rule for record construction is also standard. For record projection and
update, we resort to the auxiliary ``get'' and ``put'' rules. The ``get''
judgment checks if a field $ l $ indeed exists in a type $ \tau $ and fetches the
type of the field if so. The ``put'' judgment is almost similar, except that it
takes the intended update (both expression and type), and returns in addition a
new type of the expression. In record updates, we allow refining the type of the
field in question.

% \bruno{Sort the rules by those, which are exactly the same as System F,
%   following by those which are different (application) and finally the rules for
%   the new constructs.}

In particular we introduce a
\rulename{T-Merge} rule that applies to \emph{merge}
constructs.

\bruno{A lot more explanation needed here! You want to
   explain: 1) the rules which are different, and why they are
   different; 2) the new rules and the intuition for the new rules.
   For the new rules have text for each of them.}

% The last two rules make use of the $ \rulename{fields} $ function just to make
% sure that the field being accessed (\rulename{T-RecProj}) or updated
% (\rulename{T-RcdUpd}) actually exists. The function is defined recursively, in
% Haskell pseudocode, as:
% \[ \begin{array}{rll}
%   \fields{\alpha} & = & \rel{\cdot} {\alpha} \\
%   \fields{\tau_1 \to \tau_2} & = & \rel{\cdot} {\tau_1 \to \tau_2} \\
%   \fields{\forall \alpha. \tau} & = & \rel{\cdot} {\forall \alpha. \tau} \\
%   \fields{\tau_1 \Intersect \tau_2} & = & \fields{\tau_1} \dplus \fields{\tau_2} \\
%   \fields{\RecTy l \tau} & = & \rel l t
% \end{array} \]
% where $ \cdot $ means empty list, $ \dplus $ list concatenation, and $ : $ is an
% infix operator that prepend the first argument to the second. The function
% returns an associative list whose domain is field labels and range types.
