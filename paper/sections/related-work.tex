\section{Related Work}

Intersection types date back to Coppo et al.~\cite{coppo1981functional}. From
another viewpoint, one can regard intersections as ``implicit pairs'' whose
introduction is explicit by using the merge operator and elimination is implicit
(with no source-level construct for elimination). Understanding records is
important for understanding object-oriented languages. And we are the first to
elaborate records in terms of System $ F $.

\cite{barbanera1995intersection}

\paragraph{Intersection Types with Polymorphism.}

Our type system combines intersection types and polymorphism. The closest to
ours is Pierce's Ph.D. thesis~\cite{pierce1991programming} on a prototype compiler for a
language with both intersection types, union types, and parametric polymorphism.
The important difference with our system is that in his language there is no
explicit introduction construct like our merge operator. However, as shown in
Section 3, this feature is critical in supporting modularity and extensibility
because it allows dynamic composition of values.

\paragraph{Other Type Systems with Intersection Types.}

% Write a comprehensive F_{<:}
% The dot calculus Foundations of path-dependent types
Dunfield~\cite{dunfield2014elaborating} describes a similar approach to ours:
compiling a system with intersection types into ordinary $\lambda$-calculus
terms. The major difference is that his system does not include parametric
polymorphism, while ours does not include unions. Although similar in spirit,
our elaboration typing is simpler: we require subtyping in the case of
applications, thus avoiding the subsumption rule. Besides, our treatment
combines the merge rules ($ k $ ranges over $ \{1, 2\} $)
\infrule
{\Gamma \turns e_k : \ty}
{\Gamma \turns e_1 \dcomma e_2 : \ty}
and the standard intersection-introduction rule
\infrule
{\Gamma \turns e : \ty_1 \andalso \Gamma \turns e : \ty_2}
{\Gamma \turns e : \ty_1 \intersects \ty_2}
into one rule:
\infrule[Merge]
{\Gamma \turns e_1 : \ty_1 \andalso \Gamma \turns e_2 : \ty_2}
{\Gamma \turns e_1 \dcomma e_2 : \ty_1 \intersects \ty_2}

Reynolds invented Forsythe in the 1980s. Our merge operator is analogous to
$ p_1, p_2 $. Castagna, and Dunfield describe elaborating multi-fields records
into merge of single-field records. As Dunfield has noted, in Forsythe merges
can be only used unambiguously. For instance, it is not allowed in Forsythe to
merge two functions. Reynolds and Castagna do not consider elaboration and
Dunfield do not formalize elaborating records.

Both Pierce and Dunfield's system include a subsumption rule, which states that
if an expression has been inferred of type $ \ty $, then it is also of any
supertype of $ \ty $. Our system does not have this rule.

What's the implication of refinement intersection being typecheckers?

Refinement intersection~\cite{dunfield2007refined,freeman1991refinement} is the
more conservative approach of adopting intersection types. It increases only the
expressiveness of types but not terms. But without a term-level construct like
``merge'', as Dunfield~\cite{dunfield2014elaborating} has noted, it is not
possible to encode various language features. \cite{davies2005practical}
\cite{dunfield2007refined}

Semantic subtyping. Frisch et al.~\cite{frisch2008semantic}

\paragraph{Type Systems for Modularity.}

Intersection types have been shown to be useful in designing languages that
support modularity.~\cite{nystrom2006j}

\cite{oliveira2013feature}

\paragraph{Encoding Records and Objects.}

Extensible records were introduced by Wand~\cite{wand1987complete}. Encoding
records using intersection types appear in Reynolds~\cite{reynolds1997design}
and Castagna et al.~\cite{castagna1995calculus}. Although Dunfield also
discusses this idea in his paper \cite{dunfield2014elaborating} and provides an
implementation, he does not proceed to propose a set of elaboration typing rules
for records. Very similar to our treatment of elaborating records is Cardelli's
work~\cite{cardelli1992extensible} on translating a calculus, named
$ F_{\subtype \rho}$, with extensible records to a simpler calculus that without
records primitives (in which case is $ F_{\subtype} $). But he does not consider
encoding multi-field records as intersections; hence his translation is more
heavyweight. Crary~\cite{crary1998simple} uses intersection types and
existential types to address the problem that arises when interpreting method
dispatch as self-application. But in his paper, intersection types are not used
to encode multi-field records.

Indeed, our system can be adapted to simulate systems that support extensible
records but not intersection of ordinary types like \texttt{Int} and
\texttt{Float} by allowing only intersection of record types.

$ \turnsrec \ty $ states that $ \ty $ is a record type, or the intersection of
record types, and so forth.

\infax[RecBase]{\turnsrec \recordtype l \ty}

\infrule[RecStep]
{\turnsrec \ty_1 \andalso \turnsrec \ty_2}
{\turnsrec \ty_1 \intersects \ty_2}

\infrule[Merge']
{\Gamma \turns e_1 : \ty_1 \yields {E_1} \andalso \turnsrec \ty_1 \\
 \Gamma \turns e_2 : \ty_2 \yields {E_2} \andalso \turnsrec \ty_2}
{\Gamma \turns e_1 \dcomma e_2 : \ty_1 \intersects \ty_2 \yields {\tupled {E_1, E_2}}}

Of course our approach has its limitation as duplicated labels in a record are
allowed. This has been discussed in a larger issue by
Dunfield~\cite{dunfield2014elaborating}.

R{\'e}my~\cite{remy1989type}

\paragraph{Other Related Work.}

Compagnoni and Pierce~\cite{compagnoni1996higher} add intersection types to
System $ F^{\omega} $ and use the new calculus, $ F^{\omega}_{\intersects} $, to
model multiple inheritance. Compared to $ F^{\omega} $, in their system, types
additionally include the construct of intersection of types of the same kind
$ K $. Compared to our work, they do not have a term-level construct for
intersection introduction. Davies and Pfenning \cite{davies2000intersection}
study the interactions between intersection types and effects in call-by-value
languages. And they propose a ``value restriction'' for intersection types,
similar to value restriction on parametric polymorphism. In the Scala community,
there have been attempts to provide a foundational calculus for Scala that
incorporates intersection types~\cite{amin2014foundations,amin2012dependent}.
