\section{Related work} \label{sec:related-work}

http://homepages.inf.ed.ac.uk/gdp/publications/Sub_Par.pdf

\cite{plotkin1994subtyping}

Also discussed intersection types!~\cite{malayeri2008integrating}.

% Pierce Ph.D thesis: F<: + /|
%        technical report: F + /|, closer to ours

% \cite{barbanera1995intersection}

\paragraph{Intersection types with polymorphism.}

Intersection types date back to as early as Coppo et
al.~\cite{coppo1981functional}. Recently, some form of intersection types have
been adopted in object-oriented languages such as Scala, Ceylon, and Grace. One
defining difference, among others, is that all those languages only allow
intersections of concrete types (classes), whereas our language allows
intersections of type variables, such as \texttt{A \& B}. Without that vehicle,
we would not be able to define the generic \texttt{merge} function (below) for
all interpretations of a given algebra, and would incur boilerplate code:
\begin{minted}{haskell}
let merge [A, B] (f: ExpAlg A) (g: ExpAlg B) = {
  lit (x : Int) = f.lit x ,, g.lit x,
  add (x : A & B) (y : A & B) =
    f.add x y ,, g.add x y
}
\end{minted}
In Scala community, there have been attempts to provide a foundational calculus
for Scala that incorporates intersection
types~\cite{amin2014foundations,amin2012dependent}.

Our type system combines intersection types and polymorphism. The closest to
ours is Pierce's work~\cite{pierce1991programming1} on a prototype compiler for
a language with both intersection types, union types, and parametric
polymorphism. The important difference with our system is that in his language
there is no explicit introduction construct like our merge operator. As shown in
Section~\ref{sec:application}, this feature is pivotal in supporting modularity
and extensibility because it allows dynamic composition of values. Pierce has
also studied a system where both intersection types and bounded polymorphism are
present in his Ph.D dissertation~\cite{pierce1991programming2} and a 1997
report~\cite{pierce1997intersection}. Going in the direction of higher kinds,
Compagnoni and Pierce~\cite{compagnoni1996higher} add intersection types to
System $ F^{\omega} $ and use the new calculus, $ F^{\omega}_{\intersects} $, to
model multiple inheritance. In their system, types include the construct of
intersection of types of the same kind $ K $. Compared to our work, they do not
have a term-level construct for intersection introduction. Davies and Pfenning
\cite{davies2000intersection} study the interactions between intersection types
and effects in call-by-value languages. And they propose a ``value restriction''
for intersection types, similar to value restriction on parametric polymorphism.

\paragraph{Other type systems with intersection types.}

% Write a comprehensive F_{<:}
% The dot calculus Foundations of path-dependent types
Dunfield~\cite{dunfield2014elaborating} describes a similar approach to ours:
compiling a system with intersection types into ordinary $ \lambda $-calculus
terms. The major difference is that his system does not include parametric
polymorphism, while ours does not include unions. Besides, our rules are
algorithmic.

% Although similar in spirit,
% our elaboration typing is simpler: we require subtyping in the case of
% applications, thus avoiding the subsumption rule. Besides, our treatment
% combines the merge rules ($ k $ ranges over $ \{1, 2\} $)
% \infrule
% {\Gamma \turns e_k : \ty}
% {\Gamma \turns e_1 \dcomma e_2 : \ty}
% and the standard intersection-introduction rule
% \infrule
% {\Gamma \turns e : \ty_1 \andalso \Gamma \turns e : \ty_2}
% {\Gamma \turns e : \ty_1 \intersects \ty_2}
% into one rule:
% \infrule[Merge]
% {\Gamma \turns e_1 : \ty_1 \andalso \Gamma \turns e_2 : \ty_2}
% {\Gamma \turns e_1 \dcomma e_2 : \ty_1 \intersects \ty_2}

Reynolds invented Forsythe~\cite{reynolds1997design} in the 1980s. Our merge
operator is analogous to his $ p_1, p_2 $. Castagna, and Dunfield describe
elaborating multi-fields records into merge of single-field records. As Dunfield
has noted, in Forsythe merges can be only used unambiguously. \footnote{Why the
  restriction?} For instance, it is not allowed in Forsythe to merge two
functions.

% Reynolds and Castagna do not consider elaboration and Dunfield do not
% formalize elaborating records.

% Both Pierce and Dunfield's system include a subsumption rule, which states that
% if an expression has been inferred of type $ \ty $, then it is also of any
% supertype of $ \ty $. Our system does not have this rule.

Refinement
intersection~\cite{dunfield2007refined,davies2005practical,freeman1991refinement}
is the more conservative approach of adopting intersection types. It increases
only the expressiveness of types but not terms. But without a term-level
construct like ``merge'', it is not possible to encode various language
features. As an alternative to syntatic subtyping described in this paper,
Frisch et al.~\cite{frisch2008semantic} study semantic subtyping.

\paragraph{Type systems for modularity.}

Goto http://i.cs.hku.hk/~bruno/papers/ecoop2012.pdf Language-based

* http://www.informatik.uni-marburg.de/~kos/papers/popl06-virtualclasses.pdf
* Poly variants

Intersection types have been shown to be useful in designing languages that
support modularity.~\cite{nystrom2006j}

\paragraph{Extensible records.}

http://elm-lang.org/learn/Records.elm

Understanding records is important for understanding object-oriented languages.
And we are the first to elaborate records to System $ F $. Encoding records
using intersection types appear in Reynolds~\cite{reynolds1997design} and
Castagna et al.~\cite{castagna1995calculus}. Although Dunfield also discusses
this idea in his paper \cite{dunfield2014elaborating}, he only provides an
implementation but not formalization. Very similar to our treatment of
elaborating records is Cardelli's work~\cite{cardelli1992extensible} on
translating a calculus, named $ F_{\subtype \rho}$, with extensible records to a
simpler calculus that without records primitives (in which case is
$ F_{\subtype} $). But he does not consider encoding multi-field records as
intersections; hence his translation is more heavyweight.
Crary~\cite{crary1998simple} uses intersection types and existential types to
address the problem that arises when interpreting method dispatch as
self-application. But in his paper, intersection types are not used to encode
multi-field records.

Wand~\cite{wand1987complete} started the work on extensible records and proposes
row types~\cite{wand1989type} for records. Cardelli and
Mitchell~\cite{cardelli1990operations} define three primitive operations on
records that are different from ours: \emph{selection}, \emph{restriction}, and
\emph{extension}. Following this approach, Leijen~\cite{leijen2005extensible}
define record update in terms of restriction and extension, while in our record
system record update is a primitive operation. Both Leijen's system and ours
allows records that contain duplicate labels. Arguably Leijen's system is
stronger. For example, it supports passing record labels as arguments to
functions. He also shows encoding an intersection type using first-class labels.
Chlipala's \texttt{Ur}~\cite{chlipala2010ur} explains record as type level
constructs.

% Remy~\cite{remy1993type}

% \cite{harper1991record}

Indeed, our system can be adapted to simulate systems that support extensible
records but not intersection of ordinary types like \texttt{Int} and
\texttt{Float} by allowing only intersection of record types.

$ \turnsrec \ty $ states that $ \ty $ is a record type, or the intersection of
record types, and so forth.

\infax[RecBase]{\turnsrec \recordtype l \ty}

\infrule[RecStep]
{\turnsrec \ty_1 \andalso \turnsrec \ty_2}
{\turnsrec \ty_1 \intersects \ty_2}

\infrule[Merge']
{\Gamma \turns e_1 : \ty_1 \yields {E_1} \andalso \turnsrec \ty_1 \\
 \Gamma \turns e_2 : \ty_2 \yields {E_2} \andalso \turnsrec \ty_2}
{\Gamma \turns e_1 \dcomma e_2 : \ty_1 \intersects \ty_2 \yields {\tupled {E_1, E_2}}}

Of course our approach has its limitation as duplicated labels in a record are
allowed. This has been discussed in a larger issue by
Dunfield~\cite{dunfield2014elaborating}.

% R{\'e}my~\cite{remy1989type}
