\section{A Taste of $ \name $}

\begin{footnote}
  Change the examples later to something very simple.
\end{footnote}

This section provides the reader with the intuition of \name, while we postpone
the presentation of the details in later sections.

In short, \name generalizes System $ F $ by adding intersection polymorphism. \name terms
are elaborated into \Target, a variant of System $ F $. System $ F $, or polymorphic
lambda calculus lays the foundation of functional programming languages such as
Haskell.

The type system of \name permits a subtyping relation naturally and enables
prototype-based inheritance. We will explore the usefulness of such a type
system in practice by showing various examples.

\subsection{Intersection Types}

The central addition to the type system of \target in \name is intersection
types. What is an intersection type? One classic view is from set-theoretic
interpretation of types: $ A \intersects B $ stands for the intersection of the
set of values of $ A $ and $ B $. The other view, adopted in this paper, regards
types as a kind of interface: a value of type $ A \intersects B $ satisfies both
of the interfaces of $ A $ and $ B $. For example, \lstinline{eval : Int} is the
interface that supports evaluation to integers, while \lstinline{ eval : Int & print : String } supports both evaluation and pretty printing. Those interfaces are akin to interfaces in Java or traits in Scala. But one key
difference is that they are unnamed in \name.

Intersection types provide a simple mechanism for ad-hoc polymorphism, similar
to what type classes in Haskell achieve. The key constructs are the ``merge''
operator, denoted by $ \dcomma $, at the value level and the corresponding type
intersection operator, denoted by, $ \intersects $ at the type level.

For example, we can define an (ad-hoc)-polymorphic \lstinline{show} function
that is able to convert integers and booleans to strings. In \name such function
can be given the type

\begin{lstlisting}
  (Int -> String) & (Bool -> String)
\end{lstlisting}

and be defined using the merge operator $ \dcomma $ as

\begin{lstlisting}
  let show = showInt ,, showBool
\end{lstlisting}

where \lstinline{showString} and \lstinline{showBool} are ordinary monomorphic
functions. Later suppose the integer \lstinline{1} is applied to the \lstinline{show} function,
the first component \lstinline{showInt} will be picked because the type of \lstinline{showInt}
is compatible with \lstinline{1} while \lstinline{showBool} is not.

% The merge construct in the original function is elaborated into a pair in the
% target language:

% \begin{verbatim}
% show = (showInt, showBool)
% \end{verbatim}

% In the target language where there is no intersection types, the application
% of the integer \texttt{1} to this function does not typecheck. However, we may
% rescue this situtation by inserting a coercion that extracts the first item
% out of this pair.

% Thus \texttt{show 1} in FI corresponds to \texttt{(fst show) 1} in F.

% While elaborating intersection types, this paper is the first that presents a
% type system that incorporates both parametric polymorphism and intersection
% polymorphism.

% Describe intersection types, encoding records with Intersecion types

% \lstinputlisting[linerange=-]{} % APPLY:linerange=MIXIN_LIB

\subsection{Encoding Records}

In addition to introduction of record literals using the usual notation, \name
support two more operations on records: record elimination and record update.

A record type of the form $ \recordtype l \ty $ can be thought as a normal type \lstinline{t}
tagged by the label \lstinline{l}.

% A basic example

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICS_ADD

\lstinline{e1} and \lstinline{e2} are two expressions that support both evaluation and pretty
printing and each has type \lstinline{eval : Int, print : String}. \lstinline{add} takes
two expressions and computes their sum. Note that in order to compute a sum,
\lstinline{add} only requires that the two expressions support evaluation and hence the
type of the parameter \lstinline{eval : Int}. As a result, the type of \lstinline{e1} and
\lstinline{e2} are not exactly the same with that of the parameters of \lstinline{add}. However,
under a structural type system, this program should typecheck anyway because the
arguments being passed has more information than required. In other words,
\lstinline{eval : Int, print : String} is a subtype of \lstinline{eval : Int}.

How is this subtyping relation derived? In \name, multi-field record types are
excluded from the type system because \lstinline{eval : Int, print : String} can
be encoded as \lstinline{eval : Int & print : String}. And by one of
subtyping rules derives that \lstinline{eval : Int & print : String} is a
subtype of \lstinline{eval : Int}.

% This example is elaborated into the following in \Target.

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICSELAB_ADD

\subsection{Parametric Polymorphism}

The presence of both parametric polymorphism and intersection is critical, as we
shall see in the next section, in solving modularity problems. Here is a code
snippet from the next section (The reader is not required to understand the
purpose of this code at this stage; just recognizing the two types of
polymorphism is enough.)

\begin{lstlisting}
type SubExpAlg E = (ExpAlg E) \& { sub : E -> E -> E };
let e2 E (f : SubExpAlg E) = f.sub (exp1 E f) (f.lit 2);
\end{lstlisting}

\lstinline{SubExpAlg} is a type synonym (a la Haskell) defined as the intersection of
\lstinline{ExpAlg E} and \lstinline{sub : E -> E -> E}, parametrized by a type parameter
\lstinline{E}. \lstinline{e2} exhibits parametric polymorphism as it takes a type argument
\lstinline{E}.
