\section{Elaboration Typing}

In order to give the reader an intuitive idea of how the elaboration works,
let's first imagine a manual translation.

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore $ \{ eval = 4, print = ``4'' \} $ becomes
$ \{ eval = 4 \} ,, \{ print = ``4'' \} $. Merges of two values are elaborated
into just a pair of them and single-field record literals lose their field
labels during the elaboration. Hence $ \{ eval = 4 \} ,, \{ print = ``4'' \} $
becomes $ (4, ``4'') $.

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). x.\_1 $ before being applied to $ add $. We adopt a
Scala-like syntax where $ .\_1 $ denotes the projection of a tuple on the first
element, and so on.

\framebox{$|\tau| = T$}

\[
\begin{array}{rcl}
  |\alpha|               & = & \alpha \\
  |\tau_1 \to \tau_2|    & = & |\tau_1| \to |\tau_2| \\
  |\forall \alpha. \tau| & = & \forall \alpha. |\tau| \\
  |t_1 \& t_2|           & = & \langle |\tau_1|, |\tau_2| \rangle \\
  |\{ l : \tau \}|       & = & |\tau|
\end{array}
\]

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $$
  then $$ |\Gamma| \vdash C : |\tau_1| \to |\tau_2| $$
\end{lemma}

In this section, we present a relatively lightweight type-directed elaboration
from FI to F. The elaboration consists of four sets of rules, which are
explained below:

\begin{itemize}

\item{\bf Coercion}

  The coercion judgment $ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $ extends
  the subtyping judgment with a coercion on the right hand side of
  $ \hookrightarrow $. A coercion, which is just an expression in the target
  language, is guaranteed to have type $ \tau_1 \to \tau_2 $, as proved by Lemma
  \ref{type-coerce}. It is read ``In the environment $ \Gamma $, $ \tau_1 $ is a
  subtype of $ \tau_2 $; and if any expression $ e $ has a type $ t_1 $ that is
  a subtype of the type of $ t_2 $, the elaborated $ e $, when applied to the
  corresponding coercion $ C $, has exactly type $ |t_2| $''. For example,
  $\Gamma \vdash Int \& Bool <: Bool \yields{fst} $, where $ fst $ is the
  projection of a tuple on the first element. The coercion judgment is only used
  in the \texttt{TrApp} case.

\item{\bf Elaboration}

  The elaboration judgment $ \Gamma \vdash e : \tau \yields{E} $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. It is also standard, except for the case of
  \texttt{TrApp}, in which a coercion from the inferred type of the argument to
  the expected type of the parameter is inserted before the argument; and the
  case of \texttt{TrRcdEim} and \texttt{TrRcdUpd}, where the ``get'' and ``put''
  rules will be used. The two set of rules are explained below.

\item{\bf ``get'' rules}

  The ``get'' judgment can be thought as producing a field accessor.

\item{\bf ``put'' rules}

  The ``put'' judgment can be thought as producing a field updater.

\end{itemize}

Type-Directed Translation to System F.
Main results: type-preservation + coherence.