\section{Type-directed Translation to System $ F $}

In this section we define the semantics of the call-by-value \name by means of a
type-directed translation to a variant of System $F$. This translation turns
merges into usual pairs, much like Dunfield's elaboration. In addition it
removes labels of record and properly rewrite record selection and update
operations into coercions. In the end we obtain target expressions which can be
typed by System $F$ rules.

\subsection{Informal Discussion}

In this subsection we present the translation informally. Generally speaking,
there are three ideas. The first idea is turning merges into pairs. Therefore,
\begin{lstlisting}
1,,"one"
\end{lstlisting}
becomes
\begin{lstlisting}
(1,"one")
\end{lstlisting}
The second idea is erasing record labels:
\begin{lstlisting}
{name = "Barbara"}
\end{lstlisting}
becomes just
\begin{lstlisting}
"Barbara"
\end{lstlisting}
To see an small application, consider the following program:
\begin{lstlisting}
{distance = {inLightYears = 3, inParsecs = 1}}
\end{lstlisting}
Since multi-field records are just merges, it is desugared as
\begin{lstlisting}
{distance = {inLightYears = 3} ,, {inParsecs = 1}}
\end{lstlisting}
and then translated to
\begin{lstlisting}
(3,1)
\end{lstlisting}
by the two ideas above. Record selection is translated as the application of a
coercion to the translated expression. For example,
\begin{lstlisting}
{distance = {value = 4.3, unit="light-year"}}.distance
\end{lstlisting}
becomes
\begin{lstlisting}
(\ (x: ((Int,Int),Int)) -> (\ (x: (Int,Int)) -> x._1) x._1) ((1969,12),31)
\end{lstlisting}
The coercion 
\begin{lstlisting}
(\ (x: ((Int,Int),Int)) -> (\ (x: (Int,Int)) -> x._1) x._1) 
\end{lstlisting}
extracts the item inside the nested pair.

\bruno{Don't abuse inlining of examples in the text!}

\bruno{Show the source program, and the program that it gets
  translated to. Then explain how that translation works.}

\subsection{Target Language}

Our target language is System $F$ extended with pairs and pair types. The syntax
and typing is completely standard. The syntax of the target language is shown in
Figure~\ref{fig:f-syntax} and the typing rules in the Appendix, while the
operational semantics can be found in standard texts~\cite{pierce2002types}.
% \bruno{fill!}
\begin{figure}[h]
  \input{rule_in_figures/f-syntax.tex}
  \caption{Target syntax.}
  \label{fig:f-syntax}
\end{figure}

% \bruno{Why is this lemma placed here?}
% \bruno{Generaly Speaking this text seems out of place.Move to 5.4, maybe?}

The main translation judgment is $ \judgee \gamma e \tau \yields E $ which
states that with respect to the typing context $ \gamma $, the \name expression
$e$ is of $\tau$ and its translation is a target expression $ E $.

We also define the type translation function $ \im \cdot $ from \name types
$ \tau $ to target types $ T $.

\begin{figure}[h]
\input{rule_in_figures/type-translation.tex}
\caption{Type translation.}
\end{figure}

The rules given in this section are identical with those in
Section~\ref{sec:fi}, except for the light blue part. The translation consists
of four sets of rules, which are explained below:

\subsection{Subtyping (Coercion)}

% \george{Talk about $ \eta $-expansion.}

\begin{figure*}
\input{rule_in_figures/elab-sub.tex}
\caption{Coersive subtyping.}
\end{figure*}

The coercion judgment $ \tau_1 \subtype \tau_2 \yields C $ extends the subtyping
judgment with a coercion on the right hand side of $ \yields {} $. A coercion
$ C $ is just an expression in the target language and has type
$ \tau_1 \to \tau_2 $, as proved by Lemma \ref{type-coerce}. It is read ``In the
environment $ \gamma $, $ \tau_1 $ is a subtype of $ \tau_2 $; and if any
expression $ e $ has a type $ \tau_1 $ that is a subtype of the type of
$ \tau_2 $, the elaborated $ e $, when applied to the corresponding coercion
$ C $, has exactly type $ \im \tau_2 $''. For example,
$Int \& Bool <: Bool \yields {fst} $, where $ fst $ is the
selection of a tuple on the first element. The coercion judgment is only used in
the $ \rulelabeleapp $ case. As $ \rulelabelsubfun $ supports contravariant
parameter type and covariant return type, the coercion of the parameter types
and that of the return types are used to create a coercion for the function
type. $ \rulelabelsubandleft $, $ \rulelabelsubandright $, and
$ \rulelabelsuband $ deal with intersection types. The first two are
complementary to each other. Take $ \rulelabelsubandleft $ for example, if we
know $ \tau_1 $ is a subtype of $ \tau_3 $ and $ C $ is a coercion from
$ \tau_1 $ to $ \tau_3 $, then we can conclude that $ \tau_1 \andop \tau_2 $ is
also a subtype of $ \tau_3 $ and the new coercion is a function that takes a
value $ x $ of type $ \tau_1 \andop \tau_2 $, project $ x $ on the first item,
and apply $ C $ to it. $ \rulelabelsuband $ uses both of two coercions and
constructs a pair. \bruno{Give a couple of concrete examples when explaining the
  rules.}

\subsection{Typing (Translation)}

In this subsection we now present formally the translation rules that convert
\name expressions into System $ F $ ones. This set of rules essentially extends
those in the previous section with the light-blue part for the translation.

\begin{figure*}
\input{rule_in_figures/elab-typing.tex}
\caption{Elaboration typing from \name to System $ F $.}
\end{figure*}

% \bruno{Badly structured. Don't mention Coercion here, as it was already
% explained in the previous section.}
% \bruno{Don't use itemize and items. Use paragraphs instead!}

\paragraph{Translation.} The elaboration judgment
$ \judgee \gamma e \tau \yields E $ extends the typing judgment with an
elaborated expression on the right hand side of $ \hookrightarrow $. The
translation ensures that $ E $ has type $ \im \tau $. It is also standard,
except for the case of $ \rulelabeleapp $, in which a coercion from the inferred
type of the argument, $ e_2 $ , to the expected type of the parameter,
$ \tau_1 $, is inserted before the argument; $ \rulelabelemerge $ translates
merges into pairs. $ \rulelabelereccon $ uses the same System $ F $ expression
$ E $ for $ e $ as for $ \reccon l e $. And in $ \rulelabelerecselect $ and
$ \rulelabelerecupd $ the coercions generated by the ``get'' and ``put'' rules
will be used to coece the main \name expression.

  $ \rulelabelerecselect $ typechecks $ e $ and use the ``get'' rule to return the
  type of the field $ \tau_1 $ and the coecion $ C $. The type of the whole
  expression is $ \tau_1 $ and its translation of $ \app C E $.

  $ \rulelabelerecupd $ is similar to $ \rulelabelerecselect $ in that it uses the
  auxiliary ``put'' rule. This rule typechecks $ e $ and $ e_1 $, and uses the
  ``put'' rule. Note that it allows refining of types by an $ e_1 $ that is of a
  subtype of $ \tau_1' $, which is the type of the field $ l $ in $ e $. The type
  of the updated expression then takes the type $ \tau' $ returned by the ``put''
  rule, while its translation is $ E $, applied to the coercion generated by the
  ``put'' rule, $ C $.

  The two set of rules are explained below.

  \paragraph{``get'' rules.} The ``get'' judgment additionally yields a coercion
  can be thought as a field accessor. For example:\bruno{Still not showing the
    derivations!}

  $ \Gamma \turnsget (\{ \code{eval} : \code{Int} \}, \code{eval}) : \{ \code{eval} : \code{Int} \} \yields {\lam x \code{Int} x} $

  The lambda is the field accessor and when applied to a translated expression
  of type $ \{ \code{eval} : \code{Int} \}$, it is able to give the desired
  field. $ \rulelabelselect $ is the base case: the type of the field labelled
  $ l $ in a $ \recty l \tau $ is just $ \tau $ and the coercion is an identity
  function specialized to type $ \im {\recty l \tau} $ $ \rulelabelselectleft $ and
  $ \rulelabelselectright $ are complementary to each other.

  Consider the source program:
  \begin{lstlisting}
    ({ name = "Isaac", age = 10 }).name
  \end{lstlisting}

  Multi-field records are desugared into merge of single-field records:
  \begin{lstlisting}
    ({ name = "Isaac"} ,, { age = 10 }).name
  \end{lstlisting}

  By $ \rulelabelselect $,
  \[ \turnsget (\recty {name} {String}; {name}) : String \]

  we have the coercion
  \[ \lam x {\im {\recty {name} {String}}} x \]

  which is just $ \lam x {String} x $ according to type translation.

  By $ \rulelabelselectleft $,
  \[ \turnsget (\recty {name} {String} \andop \recty {age} {Int}; {name}) : String \]

  % we have the coercion
  % \[ \abs {\rel x {\im {\recty {name} {String} \andop \recty
  %         {age} {Int}}}} \app {(\abs {\rel x {\im {\recty {name} {String}}}} x)} {(\fst ~ x)} \]
  % which is just $ \abs {\rel x {(String, Int)}} {\app {(\abs {\rel x {String}} x)} {(\fst ~ x)}} $ by type translation.

  By typing rules, the translation of the program is
  \[ ("Isaac", 10) \]. If we apply the coercion to it, we get
  \[ "Isaac" \]


\paragraph{``put'' rules.}\bruno{Missing example (and derivation)}

  The ``put'' judgment deals spefically with record update can be thought as
  producing a field updater. Compared to the ``get'' rules, the ``put'' rules
  take an extra input $ e $, which is the desired expression to replace the
  field lablled $ l $ in values of type $ \tau $. $ \rulelabelupdate $ is the base
  case. This rule allows refinement of record fields in the sense that the type
  of $ e $ can be a subtype of the type of the field labelled by $ l $. The
  resulting type is $ \recty l {\tau'} $ and the generated coercion is a
  constant function that always returns $ E $. $ \rulelabelupdateleft $ and
  $ \rulelabelupdateright $ are complementary to each other: the idea is exactly the
  same as $ \rulelabelselectleft $ and $ \rulelabelselectright $ except that the refined type
  $ \tau_1' $ and $ \tau_2' $ is used.

\subsection{Meta-theory}

\begin{lemma}[Subtyping is reflexive.] \label{sub-refl}
Given a type $ \tau $, $ \tau \subtype \tau $.
\end{lemma}

\begin{lemma}[Subtyping is transitive.] \label{sub-trans}
If $ \tau_1 \subtype \tau_2 $ and $ \tau_2 \subtype \tau_3 $,
then $ \tau_1 \subtype \tau_3 $.
\end{lemma}

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \turns \tau_1 <: \tau_2 \yields C $$
  then $$ \im \Gamma \turns C : \im {\tau_1} \to \im {\tau_2} $$
\end{lemma}

\begin{lemma}[\rulelabelsub~rules produce type-correct coercion] 
  If $ \tau_1 \subtype \tau_2 \yields C $, then $ \judget \epsilon C {\im {\tau_1} \to \im {\tau_2}} $.
\end{lemma}

\begin{lemma}[\rulelabelselect~rules produce type-correct coercion] \label{lemma:select-correct}
  If $ \judgeselect \tau l {\tau_1} \yields C $, then $ \judget \epsilon C {\im \tau \to \im {\tau_1}} $.
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[\rulelabelupdate~rules produce type-correct coercion] 
  If $ \judgeupdate \tau l {\tau_1 \yields E} {\tau_2} {\tau_3} \yields C $ and $
  \judget \Gamma E {\im {\tau_1}} $ for some $ \Gamma $, then
  $ \judget \Gamma C {\im \tau \to \im {\tau_2}} $.
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Translation preserves well-formedness.] 
  If   $$ \Gamma \turns \tau $$
  then $$ \im \Gamma \turns \im \tau $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{theorem}[Type-preserving translation]
  If $ \judgee \gamma e \tau \yields E $, then $ \judget {\im \gamma} E {\im \tau} $.
\end{theorem}

\begin{proof}
(Sketch) By structural induction on the expression and the corresponding
inference rule. The full proof can be found in the appendix.
\end{proof}

Type-Directed Translation to System $ F $.
Main results: type-preservation + coherence.
