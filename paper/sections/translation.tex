\section{Type-directed Translation to System F}

In this section we define the semantics of \name by means of a type-directed
translation to System F. This translation removes the labels of records and
turns intersections into products, much like Dunfield's elaboration. But our
translation also deals with parametric polymorphism and records.

\subsection{Informal Discussion}

To help the reader have a high-level understanding of how the translation
works, in this subsection we present the translation informally. Take the \name
expression for example:

\begin{lstlisting}
{ eval = 4, print = ``4'' }.eval
\end{lstlisting}

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore $ \{ eval = 4, print = ``4'' \} $ becomes
$ \{ eval = 4 \} ,, \{ print = ``4'' \} $. Merges of two values are translated
into just a pair of them by \texttt{TrMerge} and single-field record literals lose their field
labels by \texttt{TrRcdIntro}. Hence $ \{ eval = 4 \} ,, \{ print = ``4'' \} $
becomes $ (4, ``4'') $.

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). \texttt{fst} x $.

\subsection{Target Language}

The target language is System F extended with pairs. The syntax and typing is
completely standard. The syntax of Systm F is as follows:

\input{rules/f-syntax.tex}

The dynamic semantics of System F can be found in ...

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $$
  then $$ |\Gamma| \vdash C : |\tau_1| \to |\tau_2| $$
\end{lemma}

The main translation judgment is $ \Gamma \vdash e : \tau \hookrightarrow E $ which
states that with respect to the environment $ \Gamma $, the \name expression
$ e $ is of a \name type $ \tau $ and its translation is a System F expression $ E $.

We also define the type translation function $ | \cdot | $ from \name types
$ \tau $ to System F types $ T $.
\input{rules/type-trans.tex}
The first three rules of the translation is standard. For the last two, the
intersection of two types are translated into a product of them, and the label
of record types are erased.

The translation consists of four sets of rules, which are explained below:

\subsection{Subtyping (Coercion)}

\begin{figure*}
\input{rules/trans-sub.tex}
\caption{Coercion}
\end{figure*}

The coercion judgment $ \Gamma \vdash \tau_1 \subtype \tau_2 \yields{C} $
extends the subtyping judgment with a coercion on the right hand side of
$ \hookrightarrow $. A coercion $ C $ is an expression in the target language
and has type $ \tau_1 \to \tau_2 $, as proved by Lemma \ref{type-coerce}. It is
read ``In the environment $ \Gamma $, $ \tau_1 $ is a subtype of $ \tau_2 $; and
if any expression $ e $ has a type $ t_1 $ that is a subtype of the type of
$ t_2 $, the elaborated $ e $, when applied to the corresponding coercion $ C $,
has exactly type $ |t_2| $''. For example,
$\Gamma \vdash Int \& Bool <: Bool \yields{fst} $, where $ fst $ is the
projection of a tuple on the first element. The coercion judgment is only used
in the \texttt{TrApp} case. As \texttt{SFun} supports contravariant parameter
type and covariant return type, the coercion of the parameter types and that of
the return types are used to create a coercion for the function type.
\texttt{SAnd1}, \texttt{SAnd2}, and \texttt{SAnd3} deal with intersection types.
The first two are complementary to each other. Take \texttt{SAnd1} for example,
if we know $ t_1 $ is a subtype of $ t_3 $ and $ C $ is a coercion from $ t_1 $
to $ t_3 $, then we can conclude that $ t_1 \with t_2 $ is also a subtype of
$ t_3 $ and the new coercion is a function that takes a value $ x $ of type
$ t_1 \with t_2 $, project $ x $ on the first item, and apply $ C $ to it.
\texttt{SAnd3} uses both of two coercions and constructs a pair.

\subsection{Typing (Translation)}

In this subsection we now present formally the translation rules that convert
\name expressions into System F ones. This set of rules essentially extends
those in the previous section with the light-blue part for the translation.

\begin{figure*}
\input{rules/trans-typing.tex}
\input{rules/trans-get.tex}
\input{rules/trans-put.tex}
\caption{Type system}
\end{figure*}

\begin{itemize}

\item{\bf Coercion}

  Explained in the previous subsection.

\item{\bf Elaboration}

  The elaboration judgment $ \Gamma \vdash e : \tau \yields{E} $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. It is also standard, except for the case of
  \texttt{TrApp}, in which a coercion from the inferred type of the argument,
  $ e_2 $ , to the expected type of the parameter, $ t_1 $, is inserted before
  the argument; \texttt{TrMerge} translates merges into pairs.
  \texttt{TrRcdIntro} uses the same System F expression $ E $ for $ e $ as for
  $ \{ l = e \} $. And in \texttt{TrRcdEim} and \texttt{TrRcdUpd} the coercions
  generated by the ``get'' and ``put'' rules will be used to coece the main
  \name expression. The two set of rules are explained below.

\item{\bf ``get'' rules}

  The ``get'' judgment deals spefically with record elimination and yields a
  coercion can be thought as a field accessor. For example:

  $ \Gamma \vdash_{get} (\{ eval : Int \}, eval) : \{ eval : Int \} \yields {\abs {\rel x Int} x} $

  The lambda is the field accessor and when applied to a translated expression
  of type $ \{ eval : Int \}$, it is able to give the desired field.
  \texttt{GetBase} is the base case: the type of the field labelled $ l $ in a $
  \recordtype l t $ is just $ t $ and the coercion is an identity function
  specialized to type $ \imageof {\recordtype l t} $
  \texttt{GetLeft} and \texttt{GetRight} are complementary to each other.

\item{\bf ``put'' rules}

  The ``put'' judgment deals spefically with record update can be thought as
  producing a field updater. Compared to the ``get'' rules, the ``put'' rules
  take an extra input $ e $, which is the desired expression to replace the
  field lablled $ l $ in values of type $ t $. \texttt{PutBase} is the base
  case. This rule allows refinement of record fields in the sense that the type
  of $ e $ can be a subtype of the type of the field labelled by $ l $. The
  resulting type is $ \recordtype l {t'} $ and the generated coercion is a
  constant function that always returns $ E $. \texttt{PutLeft} and
  \texttt{PutRight} are complementary to each other: the idea is exactly the
  same as \texttt{GetLeft} and \texttt{GetRight} except that the refined type
  $ t_1' $ and $ t_2' $ is used.

\end{itemize}

\subsection{Meta-theory}

\begin{lemma}{Subtyping is reflexive} \label{sub-refl}
Given a type $ \tau $, $ \tau \subtype \tau $.
\end{lemma}

\begin{lemma}{Subtyping is transitive} \label{sub-trans}
If $ \tau_1 \subtype \tau_2 $ and $ \tau_2 \subtype \tau_3$,
then $ \tau_1 \subtype \tau_3$.
\end{lemma}


\begin{lemma}[Get rules produce the correct coercion] \label{type-get}
  If $$ \Gamma \vdash_{get} \tau ; l = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau_1| $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Put rules produce the correct coercion] \label{type-put}
  If $$ \Gamma \vdash_{put} \tau ; l ; E = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau| $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Translation preserves well-formedness] \label{preserve-wf}
  If   $$ \Gamma \vdash \tau $$
  then $$ |\Gamma| \vdash |\tau| $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{theorem}[Type preserving translation] \label{preserve-tr}
  If   $$ \Gamma \vdash e : \tau \yields{E} $$
  then $$ |\Gamma| \vdash E : \left| \tau \right| $$
\end{theorem}

\begin{proof}
(Sketch) By structural induction on the expression and the corresponding
inference rule. The full proof can be found in the appendix.
\end{proof}

Type-Directed Translation to System F.
Main results: type-preservation + coherence.
