\section{Type-directed translation to System $ F $}

In this section we define the semantics of \name by means of a type-directed
translation to a variant of System $ F $ extended with tuples. This translation
removes the labels of records and turns intersections into products, much like
Dunfield's elaboration. But our translation also deals with parametric
polymorphism and records.

\subsection{Informal discussion}

To help the reader have a high-level understanding of how the translation
works, in this subsection we present the translation informally. Take the \name
expression for example:

\begin{lstlisting}
{ eval = 4, print = ``4'' }.eval
\end{lstlisting}

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore $ \{ eval = 4, print = ``4'' \} $ becomes
$ \{ eval = 4 \} ,, \{ print = ``4'' \} $. Merges of two values are translated
into just a pair of them by \rulename{Merge} and single-field record literals lose their field
labels by \rulename{RecCon}. Hence $ \{ eval = 4 \} ,, \{ print = ``4'' \} $
becomes $ (4, ``4'') $.\bruno{Don't abuse inlining of examples in the
  text!}

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). \fst ~ x $.
\bruno{Show the source program, and the program that it gets
  translated to. Then explain how that translation works.}

\subsection{Target language}

The target language is System $ F $ extended with pairs. The syntax and typing is
completely standard. The syntax of Systm F is as follows:

\input{rules/f-syntax.tex}

The dynamic semantics of System $ F $ can be found in ...\bruno{fill!}

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \turns \ty_1 <: \ty_2 \yields C $$
  then $$ \image \Gamma \turns C : \image {\ty_1} \to \image {\ty_2} $$
\end{lemma}\bruno{Why is this lemma placed here?}

\bruno{Generaly Speaking this text seems out of place.Move to 5.4, maybe?}
The main translation judgment is $ \Gamma \turns e : \ty \hookrightarrow E $ which
states that with respect to the environment $ \Gamma $, the \name expression
$ e $ is of a \name type $ \ty $ and its translation is a System $ F $ expression $ E $.

We also define the type translation function $ \image \cdot $ from \name types
$ \ty $ to System $ F $ types $ T $.

\begin{figure*}
\input{rules/type-trans.tex}
\caption{Type translation}
\end{figure*}

The first three rules of the translation is standard. For the last two, the
intersection of two types are translated into a product of them, and the label
of record types are erased.

The translation consists of four sets of rules, which are explained below:

\subsection{Subtyping (coercion)}

Talk about $ \eta $-expansion.

\begin{figure*}
\input{rules/trans-sub.tex}
\caption{Coercion}
\end{figure*}

The coercion judgment $ \Gamma \turns \ty_1 \subtype \ty_2 \yields C $
extends the subtyping judgment with a coercion on the right hand side of
$ \hookrightarrow $. A coercion $ C $ is an expression in the target language
and has type $ \ty_1 \to \ty_2 $, as proved by Lemma \ref{type-coerce}. It is
read ``In the environment $ \Gamma $, $ \ty_1 $ is a subtype of $ \ty_2 $; and
if any expression $ e $ has a type $ \ty_1 $ that is a subtype of the type of
$ \ty_2 $, the elaborated $ e $, when applied to the corresponding coercion $ C $,
has exactly type $ \image \ty_2 $''. For example,
$\Gamma \turns Int \& Bool <: Bool \yields {fst} $, where $ fst $ is the
projection of a tuple on the first element. The coercion judgment is only used
in the \rulename{App} case. As \rulename{SFun} supports contravariant parameter
type and covariant return type, the coercion of the parameter types and that of
the return types are used to create a coercion for the function type.
\rulename{SAnd1}, \rulename{SAnd2}, and \rulename{SAnd3} deal with intersection types.
The first two are complementary to each other. Take \rulename{SAnd1} for example,
if we know $ \ty_1 $ is a subtype of $ \ty_3 $ and $ C $ is a coercion from $ \ty_1 $
to $ \ty_3 $, then we can conclude that $ \ty_1 \intersects \ty_2 $ is also a subtype of
$ \ty_3 $ and the new coercion is a function that takes a value $ x $ of type
$ \ty_1 \intersects \ty_2 $, project $ x $ on the first item, and apply $ C $ to it.
\rulename{SAnd3} uses both of two coercions and constructs a pair.
\bruno{Give a couple of concrete examples when explaining the rules.}

\subsection{Typing (translation)}

In this subsection we now present formally the translation rules that convert
\name expressions into System $ F $ ones. This set of rules essentially extends
those in the previous section with the light-blue part for the translation.

\begin{figure*}
\input{rules/trans-typing.tex}
\input{rules/trans-get.tex}
\input{rules/trans-put.tex}
\caption{Type-directed translation from \name to System $ F $.}
\end{figure*}

\bruno{Badly structured. Don't mention Coercion here,
    as it was already explained in the previous section.}
\bruno{Don't use itemize and items. Use paragraphs instead!}

\paragraph{Translation}

  The elaboration judgment $ \Gamma \turns e : \ty \yields E $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. The translation ensures that $ E $ has type
  $ \image \ty $. It is also standard, except for the case of \rulename{App}, in
  which a coercion from the inferred type of the argument, $ e_2 $ , to the
  expected type of the parameter, $ \ty_1 $, is inserted before the argument;
  \rulename{Merge} translates merges into pairs. \rulename{RecCon} uses the
  same System $ F $ expression $ E $ for $ e $ as for $ ecordcon l e $. And in
  \rulename{RecEim} and \rulename{RecUpd} the coercions generated by the ``get''
  and ``put'' rules will be used to coece the main \name expression.

  \rulename{RecProj} typechecks $ e $ and use the ``get'' rule to return the
  type of the field $ \ty_1 $ and the coecion $ C $. The type of the whole
  expression is $ \ty_1 $ and its translation of $ \app C E $.

  \rulename{RecUpd} is similar to \rulename{RecProj} in that it uses the
  auxiliary ``put'' rule. This rule typechecks $ e $ and $ e_1 $, and uses the
  ``put'' rule. Note that it allows refining of types by an $ e_1 $ that is of a
  subtype of $ \ty_1' $, which is the type of the field $ l $ in $ e $. The type
  of the updated expression then takes the type $ \ty' $ returned by the ``put''
  rule, while its translation is $ E $, applied to the coercion generated by the
  ``put'' rule, $ C $.

  The two set of rules are explained below.

\paragraph{``get'' rules}

  The ``get'' judgment deals spefically with record elimination and yields a
  coercion can be thought as a field accessor. For
  example:\bruno{Still not showing the derivations!}

  $ \Gamma \turnsget (\{ eval : Int \}, eval) : \{ eval : Int \} \yields {\abs {\rel x Int} x} $

  The lambda is the field accessor and when applied to a translated expression
  of type $ \{ eval : Int \}$, it is able to give the desired field.
  \rulename{GetBase} is the base case: the type of the field labelled $ l $ in a $
  \recty l \ty $ is just $ \ty $ and the coercion is an identity function
  specialized to type $ \image {\recty l \ty} $
  \rulename{GetLeft} and \rulename{GetRight} are complementary to each other.

  Consider the source program:
  \begin{lstlisting}
    ({ name = ``Isaac'', age = 10 }).name
  \end{lstlisting}

  Multi-field records are desugared into merge of single-field records:
  \begin{lstlisting}
    ({ name = ``Isaac''} ,, { age = 10 }).name
  \end{lstlisting}

  By \rulename{GetBase},
  \[ \turnsget (\recty {name} {String}; {name}) : String \]

  we have the coercion
  \[ \abs {\rel x {\image {\recty {name} {String}}}} x \]

  which is just $ \abs {\rel x {String}} x $ according to type translation.

  By \rulename{GetLeft},
  \[ \turnsget (\recty {name} {String} \intersects \recty {age} {Int}; {name}) : String \]

  % we have the coercion
  % \[ \abs {\rel x {\image {\recty {name} {String} \intersects \recty
  %         {age} {Int}}}} \app {(\abs {\rel x {\image {\recty {name} {String}}}} x)} {(\fst ~ x)} \]
  % which is just $ \abs {\rel x {(String, Int)}} {\app {(\abs {\rel x {String}} x)} {(\fst ~ x)}} $ by type translation.

  By typing rules, the translation of the program is
  \[ (``Isaac'', 10) \]. If we apply the coercion to it, we get
  \[ ``Isaac'' \]


\paragraph{``put'' rules}\bruno{Missing example (and derivation)}

  The ``put'' judgment deals spefically with record update can be thought as
  producing a field updater. Compared to the ``get'' rules, the ``put'' rules
  take an extra input $ e $, which is the desired expression to replace the
  field lablled $ l $ in values of type $ \ty $. \rulename{PutBase} is the base
  case. This rule allows refinement of record fields in the sense that the type
  of $ e $ can be a subtype of the type of the field labelled by $ l $. The
  resulting type is $ \recty l {\ty'} $ and the generated coercion is a
  constant function that always returns $ E $. \rulename{PutLeft} and
  \rulename{PutRight} are complementary to each other: the idea is exactly the
  same as \rulename{GetLeft} and \rulename{GetRight} except that the refined type
  $ \ty_1' $ and $ \ty_2' $ is used.

\subsection{Meta-theory}

\begin{lemma}{Subtyping is reflexive} \label{sub-refl}
Given a type $ \ty $, $ \ty \subtype \ty $.
\end{lemma}

\begin{lemma}{Subtyping is transitive} \label{sub-trans}
If $ \ty_1 \subtype \ty_2 $ and $ \ty_2 \subtype \ty_3 $,
then $ \ty_1 \subtype \ty_3 $.
\end{lemma}


\begin{lemma}[Get rules produce the type-correct coercion] \label{type-get}
  If $$ \Gamma \turnsget \ty ; l = C ; \ty_1 $$
  then $$ \image \Gamma \turns C : \image \ty \to \image {\ty_1} $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Put rules produce the type-correct coercion] \label{type-put}
  If $$ \Gamma \turnsput \ty ; l ; E = C ; \ty_1 $$
  then $$ \image \Gamma \turns C : \image \ty \to \image \ty $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Translation preserves well-formedness] \label{preserve-wf}
  If   $$ \Gamma \turns \ty $$
  then $$ \image \Gamma \turns \image \ty $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{theorem}[Type preserving translation] \label{preserve-tr}
  If   $$ \Gamma \turns e : \ty \yields E $$
  then $$ \image \Gamma \turns E : \image \ty $$
\end{theorem}

\begin{proof}
(Sketch) By structural induction on the expression and the corresponding
inference rule. The full proof can be found in the appendix.
\end{proof}

Type-Directed Translation to System $ F $.
Main results: type-preservation + coherence.
