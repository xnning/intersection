\section{Type-directed Translation to System F}

In this section we define the semantics of \name by means of a type-directed
translation to System F. This translation removes the labels of records and
turns intersections into products, much like Dunfield's elaboration. But our
translation also deals with parametric polymorphism and records.

\subsection{Informal Discussion}

To help the reader have a high-level understanding of how the translation
works, in this subsection we present the translation informally. Take the \name
expression for example:

\begin{lstlisting}
{ eval = 4, print = ``4'' }
\end{lstlisting}

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore $ \{ eval = 4, print = ``4'' \} $ becomes
$ \{ eval = 4 \} ,, \{ print = ``4'' \} $. Merges of two values are elaborated
into just a pair of them and single-field record literals lose their field
labels during the elaboration. Hence $ \{ eval = 4 \} ,, \{ print = ``4'' \} $
becomes $ (4, ``4'') $.

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). x.\_1 $ before being applied to $ add $. We adopt a
Scala-like syntax where $ .\_1 $ denotes the projection of a tuple on the first
element, and so on.

\begin{figure*}

\framebox{\(t \subtype t \yields{C}\)}

\infax[S-Var]
{\alpha \subtype \alpha \yields{\abs{\rel{x}{\imageof{\alpha}}}{x}}}

\infrule[S-Fun]
{t_3 \subtype t_1 \yields{C_1} \andalso t_2 \subtype t_4 \yields{C_2}}
{t_1 \to t_2 \subtype t_3 \to t_4
  \yields
    {\abs{\rel{f}{\imageof{t_1 \to t_2}}}
      {\abs{\rel{x}{\imageof{t_3}}}
        {\app{C_2}{(\app{f}{(\app{C_1}{x})})}}}}}

\infrule[S-Forall]
{t_1 \subtype \subst{\alpha_2}{\alpha_1} t_2 \yields{C}}
{\univquant{\alpha_1}{t_1} \subtype \univquant{\alpha_2}{t_2}
  \yields
    {\abs{\rel{f}{\imageof{\univquant{\alpha}{t_1}}}}
      {\Abs{\alpha}{\app{C}{(\app{f}{\alpha})}}}}}

\infrule[S-And-1]
{t_1 \subtype t_3 \yields{C}}
{t_1 \with t_2 \subtype t_3
  \yields
    {\abs{\rel{x}{\imageof{t_1 \with t_2}}}
      {\app{C}{(\proj{1}{x})}}}}

\infrule[S-And-2]
{t_2 \subtype t_3 \yields{C}}
{t_1 \with t_2 \subtype t_3
  \yields
    {\abs{\rel{x}{\imageof{t_1 \with t_2}}}
      {\app{C}{(\proj{2}{x})}}}}

\infrule[S-And-3]
{t_1 \subtype t_2 \yields{C_1} \andalso t_1 \subtype t_3 \yields{C_2}}
{t_1 \subtype t_2 \with t_3
  \yields
    {\abs{\rel{x}{\imageof{t_1}}}
      {\tupled{\app{C_1}{x}, \app{C_2}{x}}}}}

\infrule[S-Rcd]
{t_1 \subtype t_2 \yields{C}}
{\recordtype{l}{t_1} \subtype \recordtype{l}{t_2}
  \yields
    {\abs{\rel{x}{\imageof{\recordtype{l}{t_1}}}}{\tupled{\app{C}{(\proj{1}{x})}}}}}

\end{figure*}

\subsection{Target Language}

The target language is System F extended with pairs. The syntax and typing is
completely standard. The syntax of Systm F is as follows:

\input{formalization/f-syntax.tex}

The dynamic semantics of System F can be found in ...

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $$
  then $$ |\Gamma| \vdash C : |\tau_1| \to |\tau_2| $$
\end{lemma}

The main translation judgment is $ \Gamma \vdash e : \tau \hookrightarrow E $ which
states that with respect to the environment $ \Gamma $, the \name expression
$ e $ is of a \name type $ \tau $ and its translation is a System F expression $ E $.

We also define the type translation function $ | \cdot | $ from \name types
$ \tau $ to System F types $ T $.
\input{formalization/type-translation.tex}
The translation is standard, except the intersection of two types are translated
into a product of them, and the label of record types are erased.

The translation consists of four sets of rules, which are explained below:

\begin{itemize}

\item{\bf Coercion}

  The coercion judgment $ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $ extends
  the subtyping judgment with a coercion on the right hand side of
  $ \hookrightarrow $. A coercion, which is just an expression in the target
  language, is guaranteed to have type $ \tau_1 \to \tau_2 $, as proved by Lemma
  \ref{type-coerce}. It is read ``In the environment $ \Gamma $, $ \tau_1 $ is a
  subtype of $ \tau_2 $; and if any expression $ e $ has a type $ t_1 $ that is
  a subtype of the type of $ t_2 $, the elaborated $ e $, when applied to the
  corresponding coercion $ C $, has exactly type $ |t_2| $''. For example,
  $\Gamma \vdash Int \& Bool <: Bool \yields{fst} $, where $ fst $ is the
  projection of a tuple on the first element. The coercion judgment is only used
  in the \texttt{TrApp} case.

\item{\bf Elaboration}

  The elaboration judgment $ \Gamma \vdash e : \tau \yields{E} $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. It is also standard, except for the case of
  \texttt{TrApp}, in which a coercion from the inferred type of the argument to
  the expected type of the parameter is inserted before the argument; and the
  case of \texttt{TrRcdEim} and \texttt{TrRcdUpd}, where the ``get'' and ``put''
  rules will be used. The two set of rules are explained below.

\item{\bf ``get'' rules}

  The ``get'' judgment can be thought as producing a field accessor.

\item{\bf ``put'' rules}

  The ``put'' judgment can be thought as producing a field updater.

\end{itemize}

Type-Directed Translation to System F.
Main results: type-preservation + coherence.
