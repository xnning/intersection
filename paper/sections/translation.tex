\section{Type-directed Translation to System $ F $}

In this section we define the semantics of \name by means of a type-directed
translation to a variant of System $ F $ extended with tuples. This translation
removes the labels of records and turns intersections into products, much like
Dunfield's elaboration. But our translation also deals with parametric
polymorphism and records.

\subsection{Informal Discussion}

To help the reader have a high-level understanding of how the translation works,
in this subsection we present the translation informally. Take the \name
expression for example:
\begin{lstlisting}
{ eval = 4, print = "4" }.eval
\end{lstlisting}

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore
\begin{lstlisting}
{ eval = 4, print = "4" }
\end{lstlisting}
becomes
\begin{lstlisting}
{ eval = 4 } ,, { print = "4" }
\end{lstlisting}
Merges of two values are translated into just a pair of them by \rulename{Merge}
and single-field record literals lose their field labels by \rulename{RecCon}.
Hence \lstinline $ { eval = 4 } ,, { print = "4" } $ becomes \lstinline
$ (4, "4") $.

\bruno{Don't abuse inlining of examples in the text!}

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). \Proj 1 x $.
\bruno{Show the source program, and the program that it gets
  translated to. Then explain how that translation works.}

\subsection{Target Language}

The target language is System $ F $ extended with pairs. The syntax and typing
is completely standard. The syntax of System $ F $ is as follows:
% \bruno{fill!}
\begin{figure}
  \input{rules/f-syntax.tex}
  \caption{Target syntax.}
  \label{fig:f-syntax}
\end{figure}
while its semantics can be found in standard texts~\cite{pierce2002types}.

% \bruno{Why is this lemma placed here?}
% \bruno{Generaly Speaking this text seems out of place.Move to 5.4, maybe?}

The main translation judgment is $ \Gamma \turns e : \tau \hookrightarrow E $ which
states that with respect to the environment $ \Gamma $, the \name expression
$ e $ is of a \name type $ \tau $ and its translation is a System $ F $ expression $ E $.

We also define the type translation function $ \image \cdot $ from \name types
$ \tau $ to System $ F $ types $ T $.

\begin{figure}
\input{rules/type-trans.tex}
\caption{Type translation}
\end{figure}

The first three rules of the translation is standard. For the last two, the
intersection of two types are translated into a product of them, and the label
of record types are erased.

The translation consists of four sets of rules, which are explained below:

\subsection{Subtyping (Coercion)}

\george{Talk about $ \eta $-expansion.}

\begin{figure*}
\input{rules/trans-sub.tex}
\caption{Coercion}
\end{figure*}

The coercion judgment $ \Gamma \turns \tau_1 \subtype \tau_2 \yields C $
extends the subtyping judgment with a coercion on the right hand side of
$ \hookrightarrow $. A coercion $ C $ is an expression in the target language
and has type $ \tau_1 \to \tau_2 $, as proved by Lemma \ref{type-coerce}. It is
read ``In the environment $ \Gamma $, $ \tau_1 $ is a subtype of $ \tau_2 $; and
if any expression $ e $ has a type $ \tau_1 $ that is a subtype of the type of
$ \tau_2 $, the elaborated $ e $, when applied to the corresponding coercion $ C $,
has exactly type $ \image \tau_2 $''. For example,
$\Gamma \turns Int \& Bool <: Bool \yields {fst} $, where $ fst $ is the
projection of a tuple on the first element. The coercion judgment is only used
in the \rulename{App} case. As \rulename{SFun} supports contravariant parameter
type and covariant return type, the coercion of the parameter types and that of
the return types are used to create a coercion for the function type.
\rulename{SAnd1}, \rulename{SAnd2}, and \rulename{SAnd3} deal with intersection types.
The first two are complementary to each other. Take \rulename{SAnd1} for example,
if we know $ \tau_1 $ is a subtype of $ \tau_3 $ and $ C $ is a coercion from $ \tau_1 $
to $ \tau_3 $, then we can conclude that $ \tau_1 \Intersect \tau_2 $ is also a subtype of
$ \tau_3 $ and the new coercion is a function that takes a value $ x $ of type
$ \tau_1 \Intersect \tau_2 $, project $ x $ on the first item, and apply $ C $ to it.
\rulename{SAnd3} uses both of two coercions and constructs a pair.
\bruno{Give a couple of concrete examples when explaining the rules.}

\subsection{Typing (Translation)}

In this subsection we now present formally the translation rules that convert
\name expressions into System $ F $ ones. This set of rules essentially extends
those in the previous section with the light-blue part for the translation.

\begin{figure*}
\input{rules/trans-typing.tex}
\input{rules/trans-get.tex}
\input{rules/trans-put.tex}
\caption{Type-directed translation from \name to System $ F $.}
\end{figure*}

% \bruno{Badly structured. Don't mention Coercion here, as it was already
% explained in the previous section.}
% \bruno{Don't use itemize and items. Use paragraphs instead!}

\paragraph{Translation}

  The elaboration judgment $ \Gamma \turns e : \tau \yields E $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. The translation ensures that $ E $ has type
  $ \image \tau $. It is also standard, except for the case of \rulename{App}, in
  which a coercion from the inferred type of the argument, $ e_2 $ , to the
  expected type of the parameter, $ \tau_1 $, is inserted before the argument;
  \rulename{Merge} translates merges into pairs. \rulename{RecCon} uses the
  same System $ F $ expression $ E $ for $ e $ as for $ \RecCon l e $. And in
  \rulename{RecEim} and \rulename{RecUpd} the coercions generated by the ``get''
  and ``put'' rules will be used to coece the main \name expression.

  \rulename{RecProj} typechecks $ e $ and use the ``get'' rule to return the
  type of the field $ \tau_1 $ and the coecion $ C $. The type of the whole
  expression is $ \tau_1 $ and its translation of $ \App C E $.

  \rulename{RecUpd} is similar to \rulename{RecProj} in that it uses the
  auxiliary ``put'' rule. This rule typechecks $ e $ and $ e_1 $, and uses the
  ``put'' rule. Note that it allows refining of types by an $ e_1 $ that is of a
  subtype of $ \tau_1' $, which is the type of the field $ l $ in $ e $. The type
  of the updated expression then takes the type $ \tau' $ returned by the ``put''
  rule, while its translation is $ E $, applied to the coercion generated by the
  ``put'' rule, $ C $.

  The two set of rules are explained below.

\paragraph{``get'' Rules}

  The ``get'' judgment deals spefically with record elimination and yields a
  coercion can be thought as a field accessor. For
  example:\bruno{Still not showing the derivations!}

  $ \Gamma \turnsget (\{ \code{eval} : \code{Int} \}, \code{eval}) : \{ \code{eval} : \code{Int} \} \yields {\Lam x \code{Int} x} $

  The lambda is the field accessor and when applied to a translated expression
  of type $ \{ \code{eval} : \code{Int} \}$, it is able to give the desired
  field. \rulename{GetBase} is the base case: the type of the field labelled
  $ l $ in a $ \RecTy l \tau $ is just $ \tau $ and the coercion is an identity
  function specialized to type $ \image {\RecTy l \tau} $ \rulename{GetLeft} and
  \rulename{GetRight} are complementary to each other.

  Consider the source program:
  \begin{lstlisting}
    ({ name = "Isaac", age = 10 }).name
  \end{lstlisting}

  Multi-field records are desugared into merge of single-field records:
  \begin{lstlisting}
    ({ name = "Isaac"} ,, { age = 10 }).name
  \end{lstlisting}

  By \rulename{GetBase},
  \[ \turnsget (\RecTy {name} {String}; {name}) : String \]

  we have the coercion
  \[ \Lam x {\image {\RecTy {name} {String}}} x \]

  which is just $ \Lam x {String} x $ according to type translation.

  By \rulename{GetLeft},
  \[ \turnsget (\RecTy {name} {String} \Intersect \RecTy {age} {Int}; {name}) : String \]

  % we have the coercion
  % \[ \abs {\rel x {\image {\RecTy {name} {String} \Intersect \RecTy
  %         {age} {Int}}}} \App {(\abs {\rel x {\image {\RecTy {name} {String}}}} x)} {(\fst ~ x)} \]
  % which is just $ \abs {\rel x {(String, Int)}} {\App {(\abs {\rel x {String}} x)} {(\fst ~ x)}} $ by type translation.

  By typing rules, the translation of the program is
  \[ ("Isaac", 10) \]. If we apply the coercion to it, we get
  \[ "Isaac" \]


\paragraph{``put'' Rules}\bruno{Missing example (and derivation)}

  The ``put'' judgment deals spefically with record update can be thought as
  producing a field updater. Compared to the ``get'' rules, the ``put'' rules
  take an extra input $ e $, which is the desired expression to replace the
  field lablled $ l $ in values of type $ \tau $. \rulename{PutBase} is the base
  case. This rule allows refinement of record fields in the sense that the type
  of $ e $ can be a subtype of the type of the field labelled by $ l $. The
  resulting type is $ \RecTy l {\tau'} $ and the generated coercion is a
  constant function that always returns $ E $. \rulename{PutLeft} and
  \rulename{PutRight} are complementary to each other: the idea is exactly the
  same as \rulename{GetLeft} and \rulename{GetRight} except that the refined type
  $ \tau_1' $ and $ \tau_2' $ is used.

\subsection{Meta-theory}

\begin{lemma}[Subtyping is reflexive.] \label{sub-refl}
Given a type $ \tau $, $ \tau \subtype \tau $.
\end{lemma}

\begin{lemma}[Subtyping is transitive.] \label{sub-trans}
If $ \tau_1 \subtype \tau_2 $ and $ \tau_2 \subtype \tau_3 $,
then $ \tau_1 \subtype \tau_3 $.
\end{lemma}

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \turns \tau_1 <: \tau_2 \yields C $$
  then $$ \image \Gamma \turns C : \image {\tau_1} \to \image {\tau_2} $$
\end{lemma}

\begin{lemma}[Get rules produce the type-correct coercion.] \label{type-get}
  If $$ \Gamma \turnsget \tau ; l = C ; \tau_1 $$
  then $$ \image \Gamma \turns C : \image \tau \to \image {\tau_1} $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Put rules produce the type-correct coercion.] \label{type-put}
  If $$ \Gamma \turnsput \tau ; l ; E = C ; \tau_1 $$
  then $$ \image \Gamma \turns C : \image \tau \to \image \tau $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Translation preserves well-formedness.] \label{preserve-wf}
  If   $$ \Gamma \turns \tau $$
  then $$ \image \Gamma \turns \image \tau $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{theorem}[Type preserving translation.] \label{preserve-tr}
  If   $$ \Gamma \turns e : \tau \yields E $$
  then $$ \image \Gamma \turns E : \image \tau $$
\end{theorem}

\begin{proof}
(Sketch) By structural induction on the expression and the corresponding
inference rule. The full proof can be found in the appendix.
\end{proof}

Type-Directed Translation to System $ F $.
Main results: type-preservation + coherence.
