\section{Type-directed Translation to System F}

In this section we define the semantics of \name by means of a type-directed
translation to System F. This translation removes the labels of records and
turns intersections into products, much like Dunfield's elaboration. But our
translation also deals with parametric polymorphism and records.

\subsection{Informal Discussion}

To help the reader have a high-level understanding of how the translation
works, in this subsection we present the translation informally. Take the \name
expression for example:

\begin{lstlisting}
{ eval = 4, print = ``4'' }.eval
\end{lstlisting}

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore $ \{ eval = 4, print = ``4'' \} $ becomes
$ \{ eval = 4 \} ,, \{ print = ``4'' \} $. Merges of two values are translated
into just a pair of them by \rulename{TrMerge} and single-field record literals lose their field
labels by \rulename{TrRcdIntro}. Hence $ \{ eval = 4 \} ,, \{ print = ``4'' \} $
becomes $ (4, ``4'') $.

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). \fst ~ x $.

\subsection{Target Language}

The target language is System F extended with pairs. The syntax and typing is
completely standard. The syntax of Systm F is as follows:

\input{rules/f-syntax.tex}

The dynamic semantics of System F can be found in ...

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $$
  then $$ |\Gamma| \vdash C : |\tau_1| \to |\tau_2| $$
\end{lemma}

The main translation judgment is $ \Gamma \vdash e : \tau \hookrightarrow E $ which
states that with respect to the environment $ \Gamma $, the \name expression
$ e $ is of a \name type $ \tau $ and its translation is a System F expression $ E $.

We also define the type translation function $ | \cdot | $ from \name types
$ \tau $ to System F types $ T $.

\begin{figure*}
\input{rules/type-trans.tex}
\caption{Type translation}
\end{figure*}

The first three rules of the translation is standard. For the last two, the
intersection of two types are translated into a product of them, and the label
of record types are erased.

The translation consists of four sets of rules, which are explained below:

\subsection{Subtyping (Coercion)}

\begin{figure*}
\input{rules/trans-sub.tex}
\caption{Coercion}
\end{figure*}

The coercion judgment $ \Gamma \vdash \tau_1 \subtype \tau_2 \yields{C} $
extends the subtyping judgment with a coercion on the right hand side of
$ \hookrightarrow $. A coercion $ C $ is an expression in the target language
and has type $ \tau_1 \to \tau_2 $, as proved by Lemma \ref{type-coerce}. It is
read ``In the environment $ \Gamma $, $ \tau_1 $ is a subtype of $ \tau_2 $; and
if any expression $ e $ has a type $ t_1 $ that is a subtype of the type of
$ t_2 $, the elaborated $ e $, when applied to the corresponding coercion $ C $,
has exactly type $ |t_2| $''. For example,
$\Gamma \vdash Int \& Bool <: Bool \yields{fst} $, where $ fst $ is the
projection of a tuple on the first element. The coercion judgment is only used
in the \rulename{TrApp} case. As \rulename{SFun} supports contravariant parameter
type and covariant return type, the coercion of the parameter types and that of
the return types are used to create a coercion for the function type.
\rulename{SAnd1}, \rulename{SAnd2}, and \rulename{SAnd3} deal with intersection types.
The first two are complementary to each other. Take \rulename{SAnd1} for example,
if we know $ t_1 $ is a subtype of $ t_3 $ and $ C $ is a coercion from $ t_1 $
to $ t_3 $, then we can conclude that $ t_1 \with t_2 $ is also a subtype of
$ t_3 $ and the new coercion is a function that takes a value $ x $ of type
$ t_1 \with t_2 $, project $ x $ on the first item, and apply $ C $ to it.
\rulename{SAnd3} uses both of two coercions and constructs a pair.

\subsection{Typing (Translation)}

In this subsection we now present formally the translation rules that convert
\name expressions into System F ones. This set of rules essentially extends
those in the previous section with the light-blue part for the translation.

\begin{figure*}
\input{rules/trans-typing.tex}
\input{rules/trans-get.tex}
\input{rules/trans-put.tex}
\caption{Type system}
\end{figure*}

\begin{itemize}

\item{\bf Coercion}

  Explained in the previous subsection.

\item{\bf Translation}

  The elaboration judgment $ \Gamma \vdash e : \tau \yields{E} $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. It is also standard, except for the case of
  \rulename{TrApp}, in which a coercion from the inferred type of the argument,
  $ e_2 $ , to the expected type of the parameter, $ t_1 $, is inserted before
  the argument; \rulename{TrMerge} translates merges into pairs.
  \rulename{TrRcdIntro} uses the same System F expression $ E $ for $ e $ as for
  $ \{ l = e \} $. And in \rulename{TrRcdEim} and \rulename{TrRcdUpd} the coercions
  generated by the ``get'' and ``put'' rules will be used to coece the main
  \name expression.

  \rulename{TrRcdElim} typechecks $ e $ and use the ``get'' rule to return the
  type of the field $ t_1 $ and the coecion $ C $. The type of the whole
  expression is $ t_1 $ and its translation of $ C E $.

  \rulename{TrRcdUpd} is similar to \rulename{TrRcdElim} in that it uses the
  auxiliary ``put'' rule. This rule typechecks $ e $ and $ e_1 $, and uses the
  ``put'' rule. Note that it allows refining of types by an $ e_1 $ that is of a
  subtype of $ t_1' $, which is the type of the field $ l $ in $ e $. The type
  of the updated expression then takes the type $ t' $ returned by the ``put''
  rule, while its translation is $ E $, applied to the coercion generated by the
  ``put'' rule, $ C $.

  The two set of rules are explained below.

\item{\bf ``get'' rules}

  The ``get'' judgment deals spefically with record elimination and yields a
  coercion can be thought as a field accessor. For example:

  $ \Gamma \vdash_{get} (\{ eval : Int \}, eval) : \{ eval : Int \} \yields {\abs {\rel x Int} x} $

  The lambda is the field accessor and when applied to a translated expression
  of type $ \{ eval : Int \}$, it is able to give the desired field.
  \rulename{GetBase} is the base case: the type of the field labelled $ l $ in a $
  \recordtype l t $ is just $ t $ and the coercion is an identity function
  specialized to type $ \imageof {\recordtype l t} $
  \rulename{GetLeft} and \rulename{GetRight} are complementary to each other.

  Consider the source program:
  \begin{lstlisting}
    ({ name = ``Isaac'', age = 10 }).name
  \end{lstlisting}

  Multi-field records are desugared into merge of single-field records:
  \begin{lstlisting}
    ({ name = ``Isaac''} ,, { age = 10 }).name
  \end{lstlisting}

  By \rulename{GetBase},
  \[ \vdash_{get} (\recordtype {name} {String}; {name}) : String \]

  we have the coercion
  \[ \abs {\rel {x} {\imageof{\recordtype {name} {String}}}} x \]

  which is just $ \abs {\rel {x} {String}} x $ according to type translation.

  By \rulename{GetLeft},
  \[ \vdash_{get} (\recordtype {name} {String} \with \recordtype {age} {Int}; {name}) : String \]

  we have the coercion
  \[ \abs {\rel {x} {\imageof{\recordtype {name} {String} \with \recordtype
          {age} {Int}}}} \app {(\abs {\rel {x} {\imageof{\recordtype {name} {String}}}} x)} {(\fst ~ x)} \]
  which is just $ \abs {\rel x {(String, Int)}} {\app {(\abs {\rel x {String}} x)} {(\fst ~ x)}} $ by type translation.

  By typing rules, the translation of the program is
  \[ (``Isaac'', 10) \]. If we apply the coercion to it, we get
  \[ ``Isaac'' \]


\item{\bf ``put'' rules}

  The ``put'' judgment deals spefically with record update can be thought as
  producing a field updater. Compared to the ``get'' rules, the ``put'' rules
  take an extra input $ e $, which is the desired expression to replace the
  field lablled $ l $ in values of type $ t $. \rulename{PutBase} is the base
  case. This rule allows refinement of record fields in the sense that the type
  of $ e $ can be a subtype of the type of the field labelled by $ l $. The
  resulting type is $ \recordtype l {t'} $ and the generated coercion is a
  constant function that always returns $ E $. \rulename{PutLeft} and
  \rulename{PutRight} are complementary to each other: the idea is exactly the
  same as \rulename{GetLeft} and \rulename{GetRight} except that the refined type
  $ t_1' $ and $ t_2' $ is used.

\end{itemize}

\subsection{Meta-theory}

\begin{lemma}{Subtyping is reflexive} \label{sub-refl}
Given a type $ \tau $, $ \tau \subtype \tau $.
\end{lemma}

\begin{lemma}{Subtyping is transitive} \label{sub-trans}
If $ \tau_1 \subtype \tau_2 $ and $ \tau_2 \subtype \tau_3$,
then $ \tau_1 \subtype \tau_3$.
\end{lemma}


\begin{lemma}[Get rules produce the correct coercion] \label{type-get}
  If $$ \Gamma \vdash_{get} \tau ; l = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau_1| $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Put rules produce the correct coercion] \label{type-put}
  If $$ \Gamma \vdash_{put} \tau ; l ; E = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau| $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{lemma}[Translation preserves well-formedness] \label{preserve-wf}
  If   $$ \Gamma \vdash \tau $$
  then $$ |\Gamma| \vdash |\tau| $$
\end{lemma}

\begin{proof}
By induction on the given derivation.
\end{proof}

\begin{theorem}[Type preserving translation] \label{preserve-tr}
  If   $$ \Gamma \vdash e : \tau \yields{E} $$
  then $$ |\Gamma| \vdash E : \left| \tau \right| $$
\end{theorem}

\begin{proof}
(Sketch) By structural induction on the expression and the corresponding
inference rule. The full proof can be found in the appendix.
\end{proof}

Type-Directed Translation to System F.
Main results: type-preservation + coherence.
