\section{An Overview of \name}

% \bruno{mention (and cite) that there are a number of OO languages supporting
% intersection types }
\george{Change the examples later to something very simple.}
\bruno{Mention that we use some syntactic sugar, which is part 
of our implementation.}

In this section we provide the reader with the necessary intuition of \name. We
will do so by introducing a simple source language, which will be used in
Section~\ref{sec:application}. \george{From the practice of similar papers, I
  think a figure listing the source syntax is neccessary.}

In \name, the central addition to the type system of System $ F $ is
intersection types. A number of OO languages, such as Java, C\#, Scala, and
Ceylon~\footnote{\url{http://ceylon-lang.org/}}, already support intersection
types to different degrees. In Java, for example,
\begin{lstlisting}
interface AwithB extends A, B 
\end{lstlisting}
introduces a new interface \lstinline{AwithB} that satisfies the interfaces of
both \lstinline{A} and \lstinline{B}, which can be considered as a nominal
intersection type. Scala steps further by eliminating the need of a nominal type
and allowing intersection of type parameters, for example,
\begin{lstlisting}
def merge[A,B] (x: A) (y: B) : A with B = ...
\end{lstlisting}
uses the annonymous intersection of two type parameters \lstinline{A} and
\lstinline{B}.

A common limitation in those languages, though, is that there is no introduction
construct at the term level for intersection types. In Java and Scala, we cannot
create an instance of class type \lstinline{A & B} with
\begin{lstlisting}
  new A() & B()
\end{lstlisting}

The limitation essentially put intersection types in a second-class status. In
contrast, there are term-level introduction construct for function types (with
lambdas) and universal quantification (with big lambdas) in most core calculi.
To fill this gap, we allow intersecting any two terms at run time using a
\emph{merge} operator (denoted by $ \mergeop $), similar to
Dunfield's~\cite{dunfield2014elaborating} approach.

In summary,

\begin{tabular}{ l | c | c | c }
                                      & Java & Scala      & \name      \\ \hline
  Intersection without a nominal type &      & \checkmark & \checkmark \\ \hline
  Intersection of type parameters     &      & \checkmark & \checkmark \\ \hline
  Term-level intersection             &      &            & \checkmark 
\end{tabular} \\

% The key constructs are the ``merge'' operator, denoted by $ \mergeop $
% at the term level and the corresponding type intersection operator, denoted by
% $ \andop $ at the type level.
% \bruno{We take a particular approach to intersection types, namely that of
% Dundfield. Some other approaches are different. The \emph{key feature} in
% Dunfield's approach is the $\mergeop$ operator, which allows for run-time
% value/object composition.}

% The addition of intersection types to System $ F $ has a number of consequences,
% which we will explore one by one in the following subsections.
% \bruno{Don't mention prototype-based inheritance in the summary, unless you
% are going to mention it later in the section. \emph{More generally don't
% mention things that you don't talk about later!}}.

\subsection{Intersection Types}

% What is an intersection type? One classic view is from set-theoretic
% interpretation of types: $ A \andop B $ stands for the intersection of
% the set of values of $ A $ and $ B $. A more practical view, adopted in this
% paper, regards types as a kind of interface: a value of type
% $ A \andop B $ satisfies both of the interfaces of $ A $ and $ B $. For
% example, \lstinline{eval : Int} is the interface that supports evaluation to
% integers, while \lstinline{eval : Int & print : String } supports both
% evaluation and pretty printing. Those interfaces are akin to interfaces in
% Java or traits in Scala. But one key difference is that they are unnamed in
% \name.

We motivate the use of intersection types with overloaded function, as
intersection types provide a simple mechanism for ad-hoc polymorphism, similar
to what type classes in Haskell achieve. The benefit is that programmers can use
the same operation on different types and delegate the task of choosing a
concrete implementation to the type system. For example, we can define a
\lstinline{show} function that takes either an integer or a boolean and return
its string representation. In other words, it is also \emph{both} a function
from integers to strings as well as a function from boolean to strings.
Therefore, in \name it should be of following type:
\begin{lstlisting}
show : (Int -> String) & (Bool -> String)
\end{lstlisting}
Assuming we have the following two functions available,
\begin{lstlisting}
showInt : Int  -> String 
showBool : Bool -> String
\end{lstlisting}
We may define \lstinline{show} by merging the them using the merge operator
({\lstinline{,,}):
\begin{lstlisting}
let show = showInt ,, showBool
\end{lstlisting}
% \bruno{This is not a proper sentence. Polish text.}

To illustrate the usage, consider the function application \lstinline{show 100}.
The type system will pick the first component of \lstinline{show}, namely
\lstinline{showInt}, as the implementation being applied to \lstinline{100}
because the type of \lstinline{showInt} is compatible with \lstinline{100}, but
\lstinline{showBool} is not. This example shows that one may regard
intersections in our system as ``implicit pairs'' whose introduction is explicit
by the merge operator and elimination is implicit (with no source-level
construct for elimination).

% The merge construct in the original function is elaborated into a pair in the
% target language:

% \begin{verbatim}
% show = (showInt, showBool)
% \end{verbatim}

% In the target language where there is no intersection types, the application
% of the integer \texttt{1} to this function does not typecheck. However, we may
% rescue this situtation by inserting a coercion that extracts the first item
% out of this pair.

% Thus \texttt{show 1} in FI corresponds to \texttt{(fst show) 1} in F.

% While elaborating intersection types, this paper is the first that presents a
% type system that incorporates both parametric polymorphism and intersection
% polymorphism.

% Describe intersection types, encoding records with Intersecion types

% \lstinputlisting[linerange=-]{} % APPLY:linerange=MIXIN_LIB

\subsection{Subtyping}

\bruno{Use the show example to illustrate subtyping in our language; and show other forms of subtyping.}

As a result of intersection types, the type system of \name permits a subtyping
relation naturally. The subtyping also arises from contravariant parameter types
and covariant return types for functions. Taking the previous example again, the
type of the function \lstinline{show} subsumes from
\begin{lstlisting}
(Int -> String) & (Bool -> String)
\end{lstlisting}
to its supertype
\begin{lstlisting}
Int -> String
\end{lstlisting}
and therefore can take \lstinline{100} as its argument.

% Subtyping in \name is syntactical and structual.

\subsection{Generalized Records}

\bruno{The title of this section needs adjusting. Moreover we do not want to
  talk about record elimination and update. \name supports a
  \emph{generalization} of record elimination and update that \emph{works for
    any type}. That's what we want to mention instead.}

\bruno{Show and talk about the record types too!}

\bruno{we support ``object/value-level composition''. Contrast with class-level
  or trait level composition in Scala.}\george{Already addressed in the
  beginning of this section.}

Following Reynolds~\cite{reynolds1997design} and Castagna et
al.~\cite{castagna1995calculus}, we leverage intersection types to type
extensible records. The idea is that a multi-field record can be encoded as
merges of single-field records, and multi-field record types as intersections.
Therefore in \name, there are only single-field record constructs. The result
are orthogonal addition to the existing type system and a more general notion of
records. 

We define three primitive operations related to records: \emph{construction},
\emph{projection}, and \emph{update}. \emph{Extension}, described in many other
record systems, is delegated to the merge operator, discussed earlier. Working
with records is type-safe: the type system prevents accessing or updating a
field that does not exist.

Conventionally, record operations work only on record types. But \name
generalizes them, allowing operations to occur on \emph{any} type. This makes
sense in the context of record encoding, because multi-field records in \name do
not have a proper record type. They are intersections.

\subsubsection{Record Operations}

\paragraph{Construction.}
The notation for record construction and record types is standard in the source
language. For example:
\begin{lstlisting}
let point : { x = 3, y = 4, z = 0 } 
  = { x: Int, y : Int, z : Int } 
in ...
\end{lstlisting}
The type ascription \lstinline$ { x = 3, y = 4, z = 0 } $ is optional. 

\paragraph{Generalized projection.}
Fields can be extracted using dot notation:
\begin{lstlisting}
point.x
\end{lstlisting}

\paragraph{Generalized update.}
(Functional) update allows creating a new record based on an existing one, with
one or more fields replaced. Refinement of fields is also possible, in the sense
that the type of a new value can be a subtype of that of the old
one.~\footnote{The subtyping restriction is not required for the \name to be
  coherent and it leaves option open for language designers.} For example,
\begin{lstlisting}
point with { x = 0, y = 0 }
\end{lstlisting}

\paragraph{Extension.}
With intersection types, we are able to regard multi-field records as just
merges of single-field records~\cite{}, for example:
\begin{lstlisting}
{ x = 1, y = 2 }
\end{lstlisting}
is just syntatic sugar for
\begin{lstlisting}
{ x = 1 } ,, { y = 2 }
\end{lstlisting}
In addition, a record is just a normal type and can be merged with any other
terms, for example, this is also valid
\begin{lstlisting}
let mixed : Int & { x : Int } : 1 ,, { x = 2 } in ...
\end{lstlisting}
and we can further extract a field out of it, such as
\begin{lstlisting}
mixed.x
\end{lstlisting}
That is because a record type of the form $ \recty l \tau $ can be thought as a
normal type $ \tau $ tagged by the label $ l $. In consequence, \name supports a
generalization of record projection and update that works for any type.

\subsubsection{Record Subtyping}

Besides, subtyping of record types is in both width and depth, as one might
expect: \lstinline$ { x: Int, y: Int } $ is a subtype of
\lstinline$ { x: Int } $; and if \lstinline$ T1 $ is a subtype of
\lstinline$ T2 $, then \lstinline$ { l: T1 } $ is also a subtype of
\lstinline$ { l: T2 } $.

% \bruno{I would call this a labelled type. Record types can be viewed as
% intersections of labelled types.}
% \bruno{Not a proper sentence! }

% \lstinline{e1} and \lstinline{e2} are two expressions that support both
% evaluation and pretty printing and each has type \lstinline{eval : Int, print :
%   String}. \lstinline{add} takes two expressions and computes their
% sum\bruno{Don't inline examples in the text. Give proper separate code
%   examples.}. Note that in order to compute a sum, \lstinline{add} only requires
% that the two expressions support evaluation and hence the type of the parameter
% \lstinline{eval : Int}. As a result, the type of \lstinline{e1} and
% \lstinline{e2} are not exactly the same with that of the parameters of
% \lstinline{add}. However, under a structural type system, this program should
% typecheck anyway because the arguments being passed has more information than
% required. In other words, \lstinline{eval : Int, print : String} is a subtype of
% \lstinline{eval : Int}.

% How is this subtyping relation derived? In \name, multi-field record types are
% excluded from the type system because \lstinline{eval : Int, print : String} can
% be encoded as \lstinline{eval : Int & print : String}. And by one of subtyping
% rules derives that \lstinline{eval : Int & print : String} is a subtype of
% \lstinline{eval : Int}.

% \bruno{Examples illustrating update and elimination of intersections
%   are missing!}

\subsection{Parametric Polymorphism}

% The presence of both parametric polymorphism and intersection is critical, as we
% shall see in the next section, in solving modularity problems. 

The simplest example that involves both intersection and polymorphism is a
function that just uses the merge operator:
% \bruno{use the join example here.}
\begin{lstlisting}
let merge [A] [B] (x: A) (y: B) : A & B = x ,, y
\end{lstlisting}
Had we tried to port the code to Scala we would get stuck on the right-hand side
because there is no counterpart of \lstinline{with} at the term level:
\begin{lstlisting}
def merge[A,B] (x: A) (y: B) : A with B = // stuck
\end{lstlisting}

\bruno{Show also how to use merge.}
\bruno{Syntax for type applications looks uncurried.}

\bruno{Talk about Inheritance is not Subtyping. 
Describe type inheritance and subtyping, show that they don't necessarelly 
go along together in our language. You may need to write some Java code, to 
illustrate differences. \emph{We support contravariant argument types!}
}

\bruno{Related to the previous point, don't forget to mention that 
there are nominal languages, that also separate inheritance from subtyping!
See Klaus Ostermann's paper \& ``Inheritance is not Subtyping''.
}

\george{I think points regarding the designs of type system should prob. be addressed
  somewhere else. The purpose of this section is just introducing the source
  language and preparing the reader for the next section.}
