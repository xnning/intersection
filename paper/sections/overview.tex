\section{An Overview of \name}

\george{
  Change the examples later to something very simple.}

This section provides the reader with the intuition of \name, while we
postpone the presentation of the details to later sections.

In short, \name generalizes System $ F $ by adding intersection polymorphism.
\name terms are elaborated into a variant of System $ F $ extended with tuples.
System $ F $, or polymorphic lambda calculus lays the foundation of functional
programming languages such as Haskell.

\bruno{Don't mention prototype-based inheritance in the summary, unless you are
  going to mention it later in the section. \emph{More generally don't mention
    things that you don't talk about later!}}. As a result of intersection
types, the type system of \name permits a subtyping relation naturally. We will
explore the usefulness of such a type system in practice by showing various
examples.

\subsection{Intersection Types}

The central addition to the type system of \target in \name is intersection
types. \bruno{mention (and cite) that there are a number of OO languages
  supporting intersection types } A number of OO languages already support
intersection types, such as Java, Scala, and Ceylon, although mostly with some
limitations. What is an intersection type? One classic view is from
set-theoretic interpretation of types: $ A \intersects B $ stands for the
intersection of the set of values of $ A $ and $ B $. A more practical view,
adopted in this paper, regards types as a kind of interface: a value of type
$ A \intersects B $ satisfies both of the interfaces of $ A $ and $ B $. For
example, \lstinline{eval : Int} is the interface that supports evaluation to
integers, while \lstinline{eval : Int & print : String } supports both
evaluation and pretty printing. Those interfaces are akin to interfaces in Java
or traits in Scala. But one key difference is that they are unnamed in \name.

\paragraph{Overloading.} Intersection types provide a simple mechanism for
ad-hoc polymorphism, similar to what type classes in Haskell achieve. As a
result, programmers can use the same operation on different types and delegate
the task of choosing a concrete implementation to the type system. For example,
we can define an \lstinline{show} function that takes either an integer or a
boolean and return its string representation. In other words, it is also
\emph{both} a function from integers to strings as well as a function from
boolean to strings. Therefore, in \name it should be of following type:
\begin{lstlisting}
(Int -> String) & (Bool -> String)
\end{lstlisting}
And we may define \lstinline{show} by merging two monomorphic functions with the
following signature using the merge operator ({\lstinline{,,}):
\begin{lstlisting}
showInt  : Int  -> String
showBool : Bool -> String
let show = showInt ,, showBool
\end{lstlisting}
\bruno{This is not a proper sentence. Polish text.}

To illustrate the usage, consider the function application \lstinline{show 100}.
The type system will pick the first component of \lstinline{show},
\lstinline{showInt}, as the implementation being applied to \lstinline{100}
because the type of \lstinline{showInt} is compatible with \lstinline{100}, but
\lstinline{showBool} is not.

% <<< Overloading <<<

The key constructs are the ``merge'' operator, denoted by $ \dcomma $, at the
value level and the corresponding type intersection operator, denoted by,
$ \intersects $ at the type level.\bruno{We take a particular approach to
  intersection types, namely that of Dundfield. Some other approaches are
  different. The \emph{key feature} in Dunfield's approach is the $\dcomma$
  operator, which allows for run-time value/object composition.}

From another viewpoint, one can regard intersections in our system as ``implicit
pairs'' whose introduction is explicit by using the merge operator and
elimination is implicit (with no source-level construct for
elimination). 

% The merge construct in the original function is elaborated into a pair in the
% target language:

% \begin{verbatim}
% show = (showInt, showBool)
% \end{verbatim}

% In the target language where there is no intersection types, the application
% of the integer \texttt{1} to this function does not typecheck. However, we may
% rescue this situtation by inserting a coercion that extracts the first item
% out of this pair.

% Thus \texttt{show 1} in FI corresponds to \texttt{(fst show) 1} in F.

% While elaborating intersection types, this paper is the first that presents a
% type system that incorporates both parametric polymorphism and intersection
% polymorphism.

% Describe intersection types, encoding records with Intersecion types

% \lstinputlisting[linerange=-]{} % APPLY:linerange=MIXIN_LIB

\subsection{Labels and a Record Encoding}
\bruno{The title of this section needs adjusting. Moreover 
we do not want to talk about record elimination and update. \name
supports a \emph{generalization} of record elimination and update 
that \emph{works for any type}. That's what we want to mention instead.}

In addition to introduction of record literals using the usual
notation, \name support two more operations on records: record
elimination and record update.

A record type of the form $ \recty l \ty $ can be thought as a normal type \lstinline{t}
tagged by the label \lstinline{l}.\bruno{I would call this a labelled
  type. Record types can be viewed as intersections of labelled types.}

% A basic example

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICS_ADD

\bruno{Not a proper sentence! }
\lstinline{e1} and \lstinline{e2} are two expressions that support both evaluation and pretty
printing and each has type \lstinline{eval : Int, print : String}. \lstinline{add} takes
two expressions and computes their sum\bruno{Don't inline examples in the text. Give
  proper separate code examples.}. Note that in order to compute a sum,
\lstinline{add} only requires that the two expressions support evaluation and hence the
type of the parameter \lstinline{eval : Int}. As a result, the type of \lstinline{e1} and
\lstinline{e2} are not exactly the same with that of the parameters of \lstinline{add}. However,
under a structural type system, this program should typecheck anyway because the
arguments being passed has more information than required. In other words,
\lstinline{eval : Int, print : String} is a subtype of \lstinline{eval : Int}.

How is this subtyping relation derived? In \name, multi-field record types are
excluded from the type system because \lstinline{eval : Int, print : String} can
be encoded as \lstinline{eval : Int & print : String}. And by one of
subtyping rules derives that \lstinline{eval : Int & print : String} is a
subtype of \lstinline{eval : Int}.

\bruno{Examples illustrating update and elimination of intersections
  are missing!}

% This example is elaborated into the following in \Target.

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICSELAB_ADD

\subsection{Intersection Types and Parametric Polymorphism}

The presence of both parametric polymorphism and intersection is critical, as we
shall see in the next section, in solving modularity problems. Here is a code
snippet from the next section (The reader is not required to understand the
purpose of this code at this stage; just recognizing the two types of
polymorphism is enough.)\bruno{use the join example here.}

\begin{lstlisting}
type SubExpAlg E = (ExpAlg E) \& { sub : E -> E -> E };
let e2 E (f : SubExpAlg E) = f.sub (exp1 E f) (f.lit 2);
\end{lstlisting}

\lstinline{SubExpAlg} is a type synonym (a la Haskell) defined as the intersection of
\lstinline{ExpAlg E} and \lstinline{sub : E -> E -> E}, parametrized by a type parameter
\lstinline{E}. \lstinline{e2} exhibits parametric polymorphism as it takes a type argument
\lstinline{E}.
