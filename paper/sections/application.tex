\section{Application}

% Algebra -> P1,2
% Visitor -> P2

% Yanlin
% Mixin

This section shows that the System F plus intersection types are enough
for encoding extensible designs, and even improve on those designs. In
particular, System FI has two main advantages over existing languages:

\begin{itemize}
\item It supports dynamic composition of intersecting values.
\item It supports contravariant parameter types in the subtyping relation.
\end{itemize}

Various solutions have been proposed to deal with the extensibility problems and
many rely on heavyweight language features such as abstract methods and classes
in Java.

These two features can be used to improve existing designs of modular programs.

% Introduce the expression problem

The expression problem refers to the difficulty of adding a new operations and a
new data variant without changing or duplicating existing code in statically
typed functional languages.

There has been recently a lightweight solution to the expression problem that
takes advantage of covariant return types in Java. We show that FI is able to
solve the expression problem in the same spirit. The
A)

\subsection{Object Algebras}

% Explain how our type system solves the limitations in using OA.

we first define an interface that supports the evaluation operation:
\lstinputlisting[linerange=2-2]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_IEVAL
The interface is just a type synonym \lstinline{IEval}. In \systemFI, record
types are structural and hence any value that satisfies this interface is of
type \lstinline{IEval} or of a subtype of \lstinline{IEval}.

In the following, \lstinline{ExpAlg} is an object algebra interface of
expressions with literal and addition case. And \lstinline{evalAlg} is an object
algebra for evluation of those expressions.

\lstinputlisting[linerange=6-10]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_EXPALG

\lstinline{evalAlg} has type \lstinline{ExpAlg Int}

\lstinputlisting[linerange=14-14]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_IPRINT
\lstinputlisting[linerange=18-24]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_SUBEXPALG

Provided with the definitions above, we can then create values using the
appropriate algebras. For example:
\lstinputlisting[linerange=28-29]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_E1_E2
defines two expressions. There are two interesting points that are worth noting here.
First, the expressions themselves are functions that take an extra argument, the
algebras, and use the data constructors in the object algebra (factory)
\lstinline{f} such as \lstinline{lit}, \lstinline{add}  and \lstinline{sub}
to create values.

\lstinputlisting[linerange=33-36]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_MERGE
\lstinputlisting[linerange=40-40]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_NEWALG
\lstinputlisting[linerange=44-44]{../src/Algebra.sf} % APPLY:linerange=ALGEBRA_PRINT

\lstinline{e1} is a single object created that supports both evaluation and
printing, thus achieving full feature-oriented programming.

The merge operator $ ,, $ is used in the definition of $ merge $.

\subsection{From Algebras Back to Visitors}

The visitor pattern allows adding new operations to existing structures without
modifying those structures.

\lstinputlisting{../src/Visitor.sf}

Contravariant param type helpers programmers to write more intuitive programs.

\subsection{Yanlin}

% Mixin goes last

\subsection{Mixins}

\lstinputlisting{../src/Mixin.sf}

In Haskell, one is able to write programs in mixin style using records. However,
this approach has a serious drawback: it is not possible to refine the mixin by
adding more fields to the records. This means that the type of the family of the
mixins has to be determined upfront.

\subsection{Composing Mixins and Object Algebras}
