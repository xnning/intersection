\section{Application} \label{sec:application}

% Structural subtyping facilitates reuse~\cite{malayeri2008integrating}.
% \bruno{orphan sentence!}

This section shows that the System $ F $ plus intersection types are enough for
encoding extensible designs, and even beat the designs in languages with a much
more sophisticated type system (such as Scala). In particular, \name has two
main advantages over existing languages:

\begin{enumerate}
\item It supports dynamic composition of intersecting values.
\item It supports contravariant parameter types in the subtyping relation.
\end{enumerate}

Various solutions have been proposed to deal with the extensibility problems and
many rely on heavyweight language features such as abstract methods and classes
in Java. These two features can be used to improve existing designs of modular
programs.

\bruno{I would like to see a story about Church Encodings in
  \name. Can you look at Pierce's papers and try to write something
  along those lines? That will be a good intro for object algebras and
visitors!}

% Introduce the expression problem

The expression problem refers to the difficulty of adding a new operations and a
new data variant without changing or duplicating existing code.

% There has been recently a lightweight solution to the expression problem that
% takes advantage of covariant return types in Java. We show that \name is able
% to solve the expression problem in the same spirit.

% - Object/Fold Algebras. How to support extensibility in an easier way.

% See Datatypes a la Carte

% - Mixins

% - Lenses? Can intersection types help with lenses? Perhaps making the
% types more natural and easy to understand/use?

% - Embedded DSLs? Extensibility in DSLs? Composing multiple DSL interpretations?

% http://www.cs.ox.ac.uk/jeremy.gibbons/publications/embedding.pdf

\begin{lstlisting}[language=scala]
trait Expr {
  def eval: Int
}
class Lit(n: Int) extends Expr {
  def eval: Int = n
}
class Add(n: Int) extends Expr {
  def eval: Int = e1.eval + e2.eval
}
\end{lstlisting}
% \bruno{You already talk about overloading in the previous section. Need to
% decide where to put the text!}

% Dunfield~\cite{dunfield2014elaborating} notes that using merges as a mechanism
% of overloading is not as powerful as type classes.

\subsection{Encoding Bounded Polymorphism}
% \bruno{IMPORTANT: Always capitalize the relevant words in a title!. This title
% should be "Encoding Bounded Polymorphism''}

As \name extends System $ F $ with intersection types, $ F_{\subtype} $ extends
System $ F $ with bounded polymorphism. $ F_{\subtype} $~\cite{pierce2002types}
allows giving an upper bound to the type variable in type abstractions. The idea
of bounded universal quantification was discussed in the seminal paper by
Cardelli and Wegner ~\cite{cardelli1985understanding}. They show that bounded
quantifiers are useful because it is able to solve the ``loss of information''
problem.

In fact, the extension of System $ F $ in the other direction, i.e., with
intersection types, is able to address the same problem effectively. Suppose we
have the following definitions:
\begin{lstlisting}{language=scala}
let user = { name = "George", admin = true }
let id(user: {name: String}) = user
\end{lstlisting}
Under a structural type system, programmers would expect that passing the user
to the function is allowed. They are correct. Note that in the source language
multi-field records are just syntatic sugars for merges of single-field records.
Therefore, user is of a subtype of the parameter due to subtyping introduced by
intersection types. So far so good. But there is a problem: what if programmers
wants to access the \texttt{admin} field later, like:
\begin{lstlisting}{language=scala}
(id user).admin
\end{lstlisting}
They cannot do so as the above will not typecheck. After going through the
function, the user now has only the type
\begin{lstlisting}{language=scala}
{name: String}
\end{lstlisting}
This is rather undesired because it indeed has an \texttt{admin} field!

Bounded polymorphism enable the function to return the exact type of the
argument so that we have no problem in accessing the \texttt{admin} field later.
Consider the example below:
\begin{lstlisting}{language=scala}
def id[A <: {name: String}] (user: A) = user
(id [{name: String, admin: Bool}] user).admin
\end{lstlisting}

We do not have bounded polymorphism in the source language. But we can encode
that via intersection types:
\begin{lstlisting}{language=F2J}
let id[A] (user: A & {name: String}) = user in
(id [{admin: Bool}] user).admin
\end{lstlisting}
By requiring the type of the argument to be an intersection type of a type
parameter and the upper bound and passing the type information, we make sure
that we can still access the \lstinline{admin} field later.

% \cite{pierce1997intersection}

% \bruno{I don't think this has been shown. What we can say is: we can encode a
% form of bounded polymorphism with intersection types.}

% Multiple inheritance?
% Algebra -> P1,2
% Visitor -> P2

% Yanlin
% Mixin

% \begin{lstlisting}
% let merge A B (f : ExpAlg A) (g : ExpAlg B) = {
%   lit = \(x : Int). f.lit x ,, g.lit x,
%   add = \(x : A & B). \(y : A & B). f.add x y ,, g.add x y
% };
% \end{lstlisting}

\subsection{Object Algebras}

% Object algebras provide an alternative to \emph{algebraic data types}
% (ADT).\bruno{We are targeting an OO crowd. Mentioning algebraic
%   datatypes is not going to be very useful there.}

%  For example, the
% following Haskell definition of the type of simple expressions
% \begin{lstlisting}{language=haskell}
% data Exp where
%   Lit :: Int -> Exp
%   Add :: Exp -> Exp -> Exp
% \end{lstlisting}
% can be expressed by the \emph{interface} of an object algebra of
% simple expressions:
% \begin{lstlisting}{language=scala}
% trait ExpAlg[E] {
%   def lit(x: Int): E
%   def add(e1: E, e2: E): E
% }
% \end{lstlisting}
% Similar to ADT, data constructors in object algebras are represented by functions such as
% \lstinline{lit} and \lstinline{add} inside an interface \lstinline{ExpAlg}.
% Different with ADT, the type of the expression itself is abtracted by a type
% parameter \lstinline{E}.

% which can be expressed similarly in \name as:
% \begin{lstlisting}{language=F2J}
% type ExpAlg E = {
%   lit : Int -> E,
%   add : E -> E -> E
% }
% \end{lstlisting}

% Introduce Scala's intersection types

% Scala supports intersection types via the \lstinline{with} keyword. The type
% \lstinline{A with B} expresses the combined interface of \lstinline{A} and
% \lstinline{B}. The idea is similar to
% \begin{lstlisting}{language=java}
% interface AwithB extends A, B {}
% \end{lstlisting}
% in Java.
% \footnote{However, Java would require the \lstinline{A} and \lstinline{B} to be
%   concrete types, whereas in Scala, there is no such restriction.}

% The value level counterpart are functions of the type \lstinline
% {A => B => A with B}. \footnote{FIXME}

Oliveira~\cite{} noted that composition of object algebras can be cumbersome and
language support for intersection types would solve that problem. Our type
system is just a simple extension of System $ F $; yet surprisingly, it is able
to solve the limitations of using object algebras in languages such as Java and
Scala. We will illustrate this point with an step-by-step of solving the
Expression Problem~\cite{wadler1998expression}.

\paragraph{Base scenario.}
In the base scenario, we consider expressions with two variants (literal and
addition) and one operation (evaluation). Here is an interface that supports
evaluation:
\begin{lstlisting}{language=F2J}
type IEval = {eval : Int}
\end{lstlisting}
and an object algebra interface, \lstinline{ExpAlg}, for expression types with
the two variants. \lstinline{ExpAlg} is abstracted over the the type of the
interpretation, \lstinline{E}.
\begin{lstlisting}{language=F2J}
type ExpAlg[E] = {lit : Int -> E, add : E -> E -> E}
\end{lstlisting}
To illustrate the point,
\begin{lstlisting}{language=F2J}
ExpAlg[IEval]
\end{lstlisting}
will be the type of object algebras with evaluation as the interpretation, whereas
\begin{lstlisting}{language=F2J}
ExpAlg[IEval & IPrint]
\end{lstlisting}
will be the type of object algebras that support both evaluation and pretty
printing.

% In \name, record types are structural and hence any value that satisfies this
% interface is of type \lstinline{IEval} or of a subtype of \lstinline{IEval}.
% \footnote{Should be mentioned in S2.}

Having defined the interfaces, we can implement that object algebra interface
with \lstinline{evalAlg}, which is an object algebra for evluation. Contrary to
nominal type systems as in most statically typed OO languages, the interface
being implemented here, \lstinline{ExpAlg[Int]}, is not required. But we put the
type ascription nonetheless for clarity and comparison.
\begin{lstlisting}{language=F2J}
let evalAlg : ExpAlg[E] = {
  lit = \(x : Int) -> {eval = x},
  add = \(x : IEval) (y : IEval) -> {eval = x.eval + y.eval}
}
\end{lstlisting}

\paragraph{Add a subtraction variant.}
The first evolution is adding a new variant, say, subtraction. We can do so by
simply intersecting the original types and merging with the original values.
\begin{lstlisting}{language=F2J}
type SubExpAlg[E] = ExpAlg[E] & {sub : E -> E -> E}
let subEvalAlg = evalAlg ,, {sub = \(x : IEval) (y : IEval) -> { eval = x.eval - y.eval }};
\end{lstlisting}

\paragraph{Add a pretty printing operation.}
As the second evolution, we add pretty printing. Similar to how we have defined
evaluation, we can describe the pretty printing feature as:
\begin{lstlisting}{language=F2J}
type IPrint = {print : String}
\end{lstlisting}
We can implement pretty printing for expressions that support literals,
addition, and subtraction:
\begin{lstlisting}{language=F2J}
let printAlg : SubExpAlg[String] = {
  lit = \(x: Int) -> {print = x.toString()},
  add = \(x: IPrint) (y: IPrint) -> {print = x.print ++ " + " ++ y.print},
  sub = \(x: IPrint) (y: IPrint) -> {print = x.print ++ " - " ++ y.print}
}
\end{lstlisting}

\paragraph{Usage.}
Provided with the definitions above, we can then create values using the
appropriate algebras. For example:
\begin{lstlisting}{language=F2J}
let e1[E] (f: SubExpAlg[E]) = f.sub (f.lit 7) (f.lit 2)
\end{lstlisting}

The expressions are unusual in the sense that they are functions that take an
extra argument \lstinline{f}, the object algebras, and use the data constructors
provided by the object algebra (factory) \lstinline{f} such as \lstinline{lit},
\lstinline{add} and \lstinline{sub} to create values. Moreover, The algebras
themselves are abstracted over the allowed operations such as evaluation and
pretty printing by requiring the expression functions to take an extra argument
\lstinline{E}.

\begin{lstlisting}{language=F2J}
let merge [A] [B] (f : ExpAlg[A]) (g : ExpAlg[B]) = {
  lit = \(x : Int) -> f.lit x ,, g.lit x,
  add = \(x : A & B) (y : A & B) ->
          f.add x y ,, g.add x y
}
\end{lstlisting}

If we would like to have an expression that supports both evaluation and pretty
printing, we will need a mechanism to combine the evaluation and printing
algebras. Intersection types allows such composition: the \lstinline{merge}
function, which takes two expression algebras to create a combined algebra. It
does so by constructing a new expression algebra, a record whose each field is a
function that delegates the input to the two algebras taken.
\begin{lstlisting}{language=F2J}
let newAlg = merge[IEval] [IPrint] subEvalAlg printAlg in
let o1 = e1 [IEval & IPrint] newAlg in
o1.print
\end{lstlisting}
% \bruno{Don't start a sentence with \lstinline{o1}.}
Note that \lstinline{o1} is a single object created that supports both
evaluation and printing, thus achieving full feature-oriented programming.

\subsection{Visitors}

Constructing instances seems clumsy!

The visitor pattern allows adding new operations to existing structures without
modifying those structures. The type of expressions are defined as follows:

\begin{lstlisting}{language=scala}
trait Exp[A] {
  def accept(f: ExpAlg[A]): A
}

trait SubExp[A] extends Exp[A] {
  override def accept(f: SubExpAlg[A]): A
}
\end{lstlisting}

The body of \lstinline{Exp} and \lstinline{SubExp} are almost the same: they
both contain an \lstinline{accept} method that takes an algebra \lstinline{f}
and returns a value of the carrier type \lstinline{A}. The only difference is at
\lstinline{f} --- \lstinline{SubExpAlg[A]} is a subtype of
\lstinline{ExpAlg[A]}. Since \lstinline{f} appear in parameter position of
\lstinline{accept} and function parameters are contravariant, naturally we would
hope that \lstinline{SubExp[A]} is a supertype of \lstinline{Exp[A]}. However,
such subtyping relation does not fit well in Scala because inheritance implies
subtyping in such languages \footnote{It is still possible to encode
  contravariant parameter types in Scala but doing so would require some
  technique.\bruno{what technique?}}. As \lstinline{SubExp[A]} extends \lstinline{Exp[A]}, the former
becomes a subtype of the latter.

Such limitation does not exist in \name. For example, we can define the similar interfaces \lstinline{Exp} and \lstinline{SubExp}:
\begin{lstlisting}{language=F2J}
type Exp    A = { accept: forall A. ExpAlg A -> A };
type SubExp A = { accept: forall A. SubExpAlg A -> A };
\end{lstlisting}
Then by the typing judgment it holds that \lstinline{SubExp} is a supertype of
\lstinline{Exp}. This relation gives desired results. To give a concrete example:

A is called is the \emph{interpretation}. It works for any interpretation you want.

First we define two data constructors for simple expressions:
\begin{lstlisting}{language=F2J}
let lit (n : Int): Exp A = {
  accept = /\A. \(f : ExpAlg A). f.lit n
};

let add (e1 : Exp) (e2 : Exp): Exp A = {
  accept = /\A. \(f : ExpAlg A).
             f.add (e1.accept A f) (e2.accept A f)
};
\end{lstlisting}

Suppose later we decide to augment the expressions with subtraction:
\begin{lstlisting}{language=F2J}
let sub (e1 : SubExp) (e2 : SubExp): SubExp A =
  { accept = /\A. \(f : SubExpAlg A).
               f.sub (e1.accept A f) (e2.accept A f) };
\end{lstlisting}

One big benefit of using the visitor pattern is that programmers is able to
write in the same way that would do in Haskell.
For example, \lstinline{e2 = sub (lit 2) (lit 3)} defines an expression.

Another important property that does not exist in Scala is that programmer is
able to pass \lstinline{lit 2}, which is of type \lstinline{Exp A}, to
\lstinline{sub}, which expects a \lstinline{SubExp A} because of the subtyping
relation we have. After all, it is known statically that \lstinline{lit 2} can
be passed into \lstinline{sub} and nothing will go
wrong.\bruno{Subtyping needs to be much more emphasized! See Modular
  Visitor Components! }

% \subsection{Yanlin stuff}
% \bruno{This can be dropped.}

% This subsection presents yet another lightweight solution to the Expression
% Problem, inspired by the recent work by Wang. It has been shown that
% contravariant return types allows refinement of the types of extended
% expressions.

% First, we define the type of expressions that support evaluation and implement
% two constructors:
% \begin{lstlisting}
% type Exp = { eval: Int }
% let lit (n: Int) = { eval = n }
% let add (e1: Exp) (e2: Exp)
%   = { eval = e1.eval + e2.eval }
% \end{lstlisting}

% If we would like to add a new operation, say pretty printing, it is nothing more
% than refining the original \lstinline{Exp} interface by \emph{intersecting} the
% original type with the new \lstinline{print} interface using the \lstinline{&}
% primitive and \emph{merging} the original data constructors using the \lstinline{,,}
% primitive.
% \begin{lstlisting}
% type ExpExt = Exp & { print: String }
% let litExt (n: Int) = lit n ,, { print = n.toString() }
% let addExt (e1: ExpExt) (e2: ExpExt)
%   = add e1 e2 ,,
%     { print = e1.print.concat(" + ").concat(e2.print) }
% \end{lstlisting}

% Now we can construct expressions using the constructors defined above:
% \begin{lstlisting}
% let e1: ExpExt = addExt (litExt 2) (litExt 3)
% let e2: Exp = add (lit 2) (lit 4)
% \end{lstlisting}
% \lstinline{e1} is an expression capable of both evaluation and printing, while
% \lstinline{e2} supports evaluation only.

% We can also add a new variant to our expression:
% \begin{lstlisting}
% let sub (e1: Exp) (e2: Exp) = { eval = e1.eval - e2.eval }
% let subExt (e1: ExpExt) (e2: ExpExt)
%   = sub e1 e2 ,, { print = e1.print.concat(" - ").concat(e2.print) }
% \end{lstlisting}

% Finally we are able to manipulate our expressions with the power of both
% subtraction and pretty printing.
% \begin{lstlisting}
% (subExt e1 e1).print
% \end{lstlisting}

\subsection{Mixins}

\bruno{Still not convinced by this section. Change to the record-based example.}
Mixins are useful programming technique wildly adopted in dynamic programming
languages such as JavaScript and Ruby. But obviously it is the programmers'
responsbility to make sure that the mixin does not try to access methods or
fields that are not present in the base class.

In Haskell, one is also able to write programs in mixin style using records.
However, this approach has a serious drawback: since there is no subtyping in
Haskell, it is not possible to refine the mixin by adding more fields to the
records. This means that the type of the family of the mixins has to be
determined upfront, which undermines extensibility.

\name is able to overcome both of the problems: it allows composing mixins
that (1) extends the base behavior, (2) while ensuring type safety.

The figure defines a mini mixin library. The apostrophe in front of types
denotes call-by-name arguments similar to the \lstinline{=>} notation in the
Scala language.

\begin{lstlisting}{language=F2J}
type Mixin S = 'S -> 'S -> S;
let zero S (super : 'S) (this : 'S) : S = super;
let rec mixin S (f : Mixin S) : S
  = let m = mixin S in f (\ (_ : Unit). m f) (\ (_ : Unit). m f);
let extends S (f : Mixin S) (g : Mixin S) : Mixin S
  = \ (super : 'S). \ (this  : 'S). f (\ (d : Unit). g super this) this;
\end{lstlisting}

We define a factorial function in mixin style and make a \lstinline{noisy} mixin
that prints ``Hello'' and delegates to its superclass. Then the two functions
are composed using the \lstinline{mixin} and \lstinline{extends} combinators.
The result is the \lstinline{noisyFact} function that prints ``Hello'' every
time it is called and computes factorial.
\begin{lstlisting}{language=F2J}
let fact (super : 'Int -> Int) (this : 'Int -> Int) : Int -> Int
  = \ (n : Int). if n == 0 then 1 else n * this (n - 1)
let noisy (super : 'Int -> Int) (this : 'Int -> Int) : Int -> Int
  = \ (n : Int). { println("Hello"); super n }
let noisyFact = mixin (Int -> Int) (extends (Int -> Int) foolish fact)
noisy 5
\end{lstlisting}

% \subsection{Composing Mixins and Object Algebras}
