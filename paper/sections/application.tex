\section{Application}

Multiple inheritance?

% Algebra -> P1,2
% Visitor -> P2

% Yanlin
% Mixin

% #include ../src/Algebra.sf haskell @merge
\begin{minted}{haskell}
let merge A B (f : ExpAlg A) (g : ExpAlg B) = {
  lit = \(x : Int). f.lit x ,, g.lit x,
  add = \(x : A & B). \(y : A & B). f.add x y ,, g.add x y
};
\end{minted}
% #end

This section shows that the System F plus intersection types are enough for
encoding extensible designs, and even improve on those designs. In particular,
System FI has two main advantages over existing languages:

\begin{itemize}
\item It supports dynamic composition of intersecting values.
\item It supports contravariant parameter types in the subtyping relation.
\end{itemize}

Various solutions have been proposed to deal with the extensibility problems and
many rely on heavyweight language features such as abstract methods and classes
in Java.

These two features can be used to improve existing designs of modular programs.

% Introduce the expression problem

The expression problem refers to the difficulty of adding a new operations and a
new data variant without changing or duplicating existing code in statically
typed functional languages.

There has been recently a lightweight solution to the expression problem that
takes advantage of covariant return types in Java. We show that FI is able to
solve the expression problem in the same spirit. The
A)

\subsection{Object Algebras}

Object algebra provides an alternative to \emph{algebraic data types} (ADT). For example, the
following Haskell definition of the type of simple expressions
\begin{minted}{haskell}
data Exp where
  Lit :: Int -> Exp
  Add :: Exp -> Exp -> Exp
\end{minted}
can be expressed by the \emph{interface} of an object algebra of simple expressions:
\begin{minted}{scala}
trait ExpAlg[E] {
  def lit(x: Int): E
  def add(e1: E, e2: E): E
}
\end{minted}
Similar to ADT, data constructors in object algebras are represented by functions such as
\lstinline{lit} and \lstinline{add} inside an interface \lstinline{ExpAlg}.
Different with ADT, the type of the expression itself is abtracted by a type
parameter \lstinline{E}.

which can be expressed similarly in \systemfi as:
\begin{minted}{haskell}
type ExpAlg E = {
  lit : Int -> E,
  add : E -> E -> E
}
\end{minted}

Scala supports intersection types via the \lstinline{with} keyword. \lstinline{A with B}
is the combined interface of \lstinline{A} and \lstinline{B}. The
value level counterpart is functions of the type \lstinline {A => B => A with B}.

Our type system is an fairely simple extension of System F; yet surprisingly, it
is able to solve the limitations of using object algebras in languages such as
Java and Scala. We will illustrate this point with an step-by-step of solving
the expression problem using \systemFI.

Oliveira noted that composition of object algebras are cumbersome.

We first define an interface that supports the evaluation operation:

% #include ../src/Algebra.sf haskell @base
\begin{minted}{haskell}
type IEval  = { eval : Int };
type ExpAlg E = { lit : Int -> E, add : E -> E -> E };
let evalAlg = {
  lit = \(x : Int). { eval = x },
  add = \(x : IEval). \(y : IEval). { eval = x.eval + y.eval }
};
\end{minted}
% #end

The interface is just a type synonym \lstinline{IEval}. In \systemFI, record
types are structural and hence any value that satisfies this interface is of
type \lstinline{IEval} or of a subtype of \lstinline{IEval}.

In the following, \lstinline{ExpAlg} is an object algebra interface of
expressions with literal and addition case. And \lstinline{evalAlg} is an object
algebra for evluation of those expressions, which has type \lstinline{ExpAlg Int}

% #include ../src/Algebra.sf haskell @variant
\begin{minted}{haskell}
type SubExpAlg E = (ExpAlg E) & { sub : E -> E -> E };
let subEvalAlg = evalAlg ,, { sub = \ (x : IEval). \ (y : IEval). { eval = x.eval - y.eval } };
\end{minted}
% #end

Next, we define an interface that supports pretty printing.

% #include ../src/Algebra.sf haskell @operation
\begin{minted}{haskell}
type IPrint = { print : String };
let printAlg = {
  lit = \(x : Int). { print = x.toString() },
  add = \(x : IPrint). \(y : IPrint). { print = x.print.concat(" + ").concat(y.print) },
  sub = \(x : IPrint). \(y : IPrint). { print = x.print.concat(" - ").concat(y.print) }
};
\end{minted}
% #end

Provided with the definitions above, we can then create values using the
appropriate algebras. For example:
defines two expressions.

The expressions are unusual in the sense that they are functions that take an
extra argument \lstinline{f}, the object algebras, and use the data constructors
provided by the object algebra (factory) \lstinline{f} such as \lstinline{lit},
\lstinline{add} and \lstinline{sub} to create values. Moreover, The algebras
themselves are abstracted over the allowed operations such as evaluation and
pretty printing by requiring the expression functions to take an extra argument
\lstinline{E}.

% #include ../src/Algebra.sf haskell @merge
\begin{minted}{haskell}
let merge A B (f : ExpAlg A) (g : ExpAlg B) = {
  lit = \(x : Int). f.lit x ,, g.lit x,
  add = \(x : A & B). \(y : A & B). f.add x y ,, g.add x y
};
\end{minted}
% #end

If we would like to have an expression that supports both evaluation and pretty
printing, we will need a mechanism to combine the evaluation and printing
algebras. Intersection types allows such composition: the \lstinline{merge}
function, which takes two expression algebras to create a combined algebra. It
does so by constructing a new expression algebra, a record whose each field is a
function that delegates the input to the two algebras taken.

% #include ../src/Algebra.sf haskell @usage
\begin{minted}{haskell}
let newAlg = merge IEval IPrint subEvalAlg printAlg in
(e1 (IEval & IPrint) newAlg).print
\end{minted}
% #end

\lstinline{e1} is a single object created that supports both evaluation and
printing, thus achieving full feature-oriented programming.

\subsection{From Algebras Back to Visitors}

The visitor pattern allows adding new operations to existing structures without
modifying those structures.

% #include ../src/Visitor.sf haskell
\begin{minted}{haskell}
type ExpAlg E = { lit : Int -> E, add : E -> E -> E };
type Exp = { accept : forall A. ExpAlg A -> A };

type LitAdd A = { lit : Int -> A, add : A -> A -> A };

let lit (n : Int) = {
  accept = /\A. \(f : LitAdd A). f.lit n
};

let add (e1 : Exp) (e2 : Exp) = {
  accept = /\A. \(f : LitAdd A). f.add (e1.accept A f) (e2.accept A f)
};

let evalAlg = {
  lit = \(x : Int). x,
  add = \(x : Int). \(y : Int). x + y
};
let e1 = add (lit 2) (lit 3);
-- e1.accept Int evalAlg

type SubExpAlg E = (ExpAlg E) & { sub : E -> E -> E };
type ExpExt = { accept : forall A. SubExpAlg A -> A };

type LitAddSub A = LitAdd A & { sub : A -> A -> A };

let sub (e1 : ExpExt) (e2 : ExpExt) =
  { accept = /\A. \(f : LitAddSub A).
               f.sub (e1.accept A f) (e2.accept A f) };

-- Contravariant param type, programmer-friendly usage
let e2 = sub (lit 2) (lit 3);

-- Note that Exp <: ExpExt
let f (x : ExpExt) = 1;
-- let g (x : Exp) = 1;
e2
\end{minted}
% #end

One big benefit of using the visitor pattern is that programmers is able to
write in the same way that would do in Haskell. For example,
\lstinline{e2 = sub (lit 2) (lit 3)}
defines an expression.

However, there is the extra task of defining an \lstinline{Exp} interface.

% \subsection{Yanlin}

% Mixin goes last

\subsection{Mixins}

\lstinputlisting{../src/Mixin.sf}

In Haskell, one is able to write programs in mixin style using records. However,
this approach has a serious drawback: it is not possible to refine the mixin by
adding more fields to the records. This means that the type of the family of the
mixins has to be determined upfront.

The figure defines a mini mixin library. The apostrophe in front of types
denotes call-by-name arguments similar to the \lstinline{=>} notation in the
Scala language.

\subsection{Composing Mixins and Object Algebras}
