A concern raised by all reviewers is nondeterminism.

The rules presented are nondeterministic mainly for simplicity, since it is
unnatural to describe the order of applying rules in a deductive system. But it
is easy to get a deterministic result by imposing an order in the
implementation. We will illustrate this idea by using examples given by Reviewer
1. As noted,

({x=1},,{x=2}).x

can evaluate to either 1 or 2 because ({x=1},,{x=2}) is of an intersection type,
for which both rules, (select1) and (select2), are applicable (copied below).

t . l = t
--------------- (select1)
t1 & t2 . l = t

t . l = t
--------------- (select2)
t1 & t2 . l = t

However, in our implementation, whenever this case happens, the right component
of & and ,, will take precedence. In other words, the (select2) rule is tried
first. Only after it fails, the (select1) rule is tried. Therefore,
({x=1},,{x=2}).x can only evaluate to 2. And likewise, ({x=1},,{x="hi"}).x will
evaluate to "hi" and will be of type String.

More generally, three pairs of rules in our system that cause nondeterminism can
be implemented with the same fashion. That means that (sub-and2) is also favored
to (sub-and1), and (restrict2) to (restrict1). This approach is also covered in
Section 5.4 of our paper.
