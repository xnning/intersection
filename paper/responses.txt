* Nondeterminism

A concern raised by all reviewers is nondeterminism.

The rules presented are nondeterministic mainly for simplicity, since it is
unnatural to describe the order of applying rules in a deductive system. But it
is easy to get a deterministic result by imposing an order in the
implementation. We will illustrate this idea by using examples given by Reviewer
1. As noted,

({x=1},,{x=2}).x

can evaluate to either 1 or 2 because ({x=1},,{x=2}) is of an intersection type,
for which both rules, (select1) and (select2), are applicable (copied below).

t . l = t
--------------- (select1)
t1 & t2 . l = t

t . l = t
--------------- (select2)
t1 & t2 . l = t

However, in our implementation, whenever this case happens, the right component
of & and ,, will take precedence. In other words, the (select2) rule is tried
first. Only after it fails, the (select1) rule is tried. Therefore,
({x=1},,{x=2}).x can only evaluate to 2. And likewise, ({x=1},,{x="hi"}).x will
evaluate to "hi" and will be of type String.

More generally, three pairs of rules in our system that cause nondeterminism can
be implemented with the same fashion. That means that (sub-and2) is also favored
to (sub-and1), and (restrict2) to (restrict1). This approach is also covered in
Section 5.4 of our paper.

* Usage of restriction

Restriction is useful to support standard OOP idioms for code reuse, like method
overriding. For example, based on a print printer (printAlg) shown in Section
3.1, we can override the Add case such that "(+ 2 3)" is printed instead of "2 +
3":

let sexpPrintAlg = printAlg \ add ,, {
  add = \(x: IPrint) (y: IPrint) -> { print = "(+ " ++ x.print ++ y.print ++ ")" }
};
...

* Coq proofs

The Coq script proves reflexivity and transitivity of subtyping
without using any admit.

However, we were a bit slopy forgot to clean up some experiments after
the transitivity proof. Please ignore the code after line 207, which
is where all the 25 admits are. The proofs for type-soundness are not
mechanized, they are manual and fully presented in the appendix.

* Technical novelty

The main goal of our work was to find a minimal core calculus that
could support existing extensible designs in the literature. Even if
that calculus already existed, we would still write an OOPSLA paper
illustrating why that calculus would have applications to solve the
extensibility problems and how it could be a foundation towards a
better OO language. So, there is more to our paper than just the
formalisation of F& (we invite the reviewer to read our list of
contributions in the introduction again).

Having said that the formalisation of F& does have some interesting as
there are some design choices to be made when adding polymorphism. In
particular, we chose not to have bounded quantifiers in the language,
where most previous work explored systems combining intersection types
with bounded polymorphism. See also the first item on related work.
