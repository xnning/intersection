\documentclass[preprint]{sigplanconf}

\input{packages.tex}
\input{macros.tex}

\input{rule_as_macros/orthogonality.tex}
\input{rule_as_macros/sub.tex}
\input{rule_as_macros/typing.tex}
% \input{rule_as_macros/target.tex}
\input{rule_as_macros/wellformedness.tex}

\newcommand{\name}{{\bf $F_{\&}$}\xspace}

\newcommand{\target}{{\bf f}\xspace}
\newcommand{\Target}{{\bf f}\xspace}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{\name}

% Coherence for well-typed terms.

\begin{figure}
  \[
  \begin{array}{l}
    \begin{array}{llrll}
      \text{Types}
      & T & \Coloneqq & \alpha     & \text{Type variable} \\
      &         & \mid & \bot            & \text{Bottom type} \\
      &        & \mid & A \to B         & \text{Function type}\\
      &         & \mid & \for {\alpha * B} A   & \text{Universal quantification} \\
      &         & \mid & A \intersect B  & \text{Intersection type} \\
%      &         & \mid & \constraints {A \disjoint B} C & \text{Disjoint constraint} \\
      % &         & \mid & \recordType l A & \text{Record type} \\
%     \\
%     \text{Types}
%     & A, B, C, D & \Coloneqq & \alpha     & \text{Type variable} \\
%     &  & \mid & A \intersect B  & \text{Intersection type} \\
%     &         & \mid & A \intersect B  & \text{Intersection type} \\
%     &         & \mid & T  & \text{Atomic type} \\

      \\
      \text{Expressions}
      & e & \Coloneqq & x            & \text{Variable} \\
%      &   & \mid & \top              & \text{Top} \\
      &   & \mid & \lam x A e        & \text{Lambda} \\
      &   & \mid & \app {e_1} {e_2}  & \text{Application} \\
      &   & \mid & \blam {\alpha * A}  e    & \text{Big lambda} \\
      &   & \mid & \tapp e A         & \text{Type application} \\
      &   & \mid &  e_1 \mergeOp e_2 & \text{Merge} \\
      % &   & \mid & {\_}                 & \text{Disjointness evidence}
%      &   & \mid & \assume {(A \disjoint B)} e & \text{Constraint intro} \\
%      &   & \mid & \app e {\_}                 & \text{Constraint elim} \\
      % &   & \mid & \recordCon l e    & \text{Record} \\
      % &   & \mid & e.l               & \text{Record selection} \\
      % &   & \mid & e \restrictOp l   & \text{Record restriction} \\

      \\
      \text{Contexts}
      & \Gamma & \Coloneqq & \epsilon         & \\
      &        & \mid & \Gamma, \alpha * A       & \\
      &        & \mid & \Gamma, x \hast A     & \\
%      &        & \mid & \Gamma, A \disjoint B & \\

      % \\
      \text{Sugar} & \blam {\alpha} e & \equiv & \blam {\alpha * \bot} e & \\
                   & e : A &  \equiv & (\lambda z : A . z) e &
    \end{array}
  \end{array}
  \]
  \caption{Syntax.}
\end{figure}

% \begin{figure*}
%   \caption{Disjointness between types.}
% \end{figure*}

% \begin{figure*}
%   \input{rule_in_figures/wellformedness.tex}
%   \caption{Well-formedness of types.}
% \end{figure*}

% \begin{figure*}
% \begin{mathpar}
% \begin{array}{l}
%   \begin{array}{llrl}
%     \text{Values} & v & \Coloneqq & \top \mid \lam x \tau e \mid \blam \alpha e \mid v_1 \mergeOp v_2 \mid \recordCon l e
%   \end{array}
% \end{array}
% \end{mathpar}
%
%   \caption{Values.}
% \end{figure*}

% \begin{figure*}

%   \begin{mathpar}
%     \begin{array}{lcl}
%       \fields {v_1 \mergeOp v_2} &=& \fields {v_1} \concatOp \fields {v_2} \\
%       \fields {\recordCon l e}   &=& [(l, e)] \\
%       \fields v                  &=& []
%     \end{array}
%   \end{mathpar}
%   \caption{\code{fields}.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \begin{array}{lcl}
%       \remove {\recordCon l e} l &=& \top \\
%       \remove {\recordCon l e \mergeOp v_2} l &=& v_2 \\
%       \remove {\recordCon l e \mergeOp v_2} {l'} &=& \recordCon l e \mergeOp \remove {v_2} {l'} \quad \quad (l \neq l') \\
%       \remove {v_1 \mergeOp \recordCon l e} l &=& v_1 \\
%       \remove {v_1 \mergeOp \recordCon l e} {l'} &=& \remove {v_1} {l'} \mergeOp \recordCon l e \quad \quad (l \neq l') \\

%       \remove v l                  &=& v
%     \end{array}

%   \end{mathpar}

%   \caption{\code{remove}.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \inferrule* [right=Cast/UpCast]
%       {\tau_1 \subtype \tau}
%       {\cast \tau {\withType v {\tau_1}} \hookrightarrow v}
%
%     \inferrule* [right=Cast/TakeLeft]
%       {\cast \tau {\withType {v_1} {\tau_1}} \hookrightarrow v}
%       {\cast \tau {\withType {v_1 \mergeOp v_2} {\tau_1 \intersect \tau_2}} \hookrightarrow v}
%
%     \inferrule* [right=Cast/TakeRight]
%       {\cast \tau {\withType {v_2} {\tau_2}} \hookrightarrow v}
%       {\cast \tau {\withType {v_1 \mergeOp v_2} {\tau_1 \intersect \tau_2}} \hookrightarrow v}
%   \end{mathpar}
%
%   \caption{Casts.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \inferrule* [right=Dyn/Val]
%       { }
%       {v \Downarrow v}
%
%     \inferrule* [right=Dyn/App]
%       {e_1 \Downarrow \lam x \tau e \\
%        e_2 \Downarrow v_2 \\
%        \cast \tau {\withType {v_2} {\tau_2}} \hookrightarrow v_3 \\
%        \subst {v_3} x e \Downarrow v}
%       {\app {e_1} {\withType {e_2} {\tau_2}} \Downarrow v}
%
%     \inferrule* [right=Dyn/TApp]
%       {e_1 \Downarrow \for \alpha e \\
%        \subst \tau \alpha e \Downarrow v}
%       {\tapp {e_1} \tau \Downarrow v}
%
%     \inferrule* [right=Dyn/Merge]
%       {e_1 \Downarrow v_1 \\ e_2 \Downarrow v_2}
%       {e_1 \mergeOp e_2 \Downarrow v_1 \mergeOp v_2}
%
%     % \inferrule* [right=Dyn/RecSelect]
%     %   {e \Downarrow v \\
%     %    (l, e_1) \; \code{`uniqueElem`} \; \fields v \\
%     %    e_1 \Downarrow v_1}
%     %   {e.l \Downarrow v_1}
%
%     % \inferrule* [right=Dyn/RecRestrict]
%     %   {e \Downarrow v \\
%     %    (l, e_1) \; \code{`uniqueElem`} \; \fields v}
%     %   {e \restrictOp l \Downarrow v \; \code{`remove`} \; l}
%   \end{mathpar}
%
%   \caption{Dynamic semantics.}
% \end{figure*}
%
% \begin{figure*}
%   \input{rule_in_figures/type-translation.tex}
%   \caption{Type translation.}
% \end{figure*}

\begin{figure}
  \begin{mathpar}
  \framebox{$ A \subtype B \yields F $} \\
  \subVar \\
%  \subTop \\
  \subFun \\
  \subForall \\
  \subAnd \\
  \subAndleft \\
  \subAndright \\
%  \subConstraint
  \end{mathpar}\footnote{miss a rule for $\bot$}
  \caption{Subtyping.}
\end{figure}


\begin{figure}
  \begin{mathpar}
    \framebox{$ A~atomic$} \\

    \inferrule* 
      {}
      {\bot~atomic}

\inferrule* 
      {}
      {A \to B~atomic}

    \inferrule*
      {}
      {\for {\alpha * B} A~atomic}

  \end{mathpar}
  \caption{Atomic types.}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \framebox{$ \isdisjoint \Gamma A B$} \\

    \inferrule* [right=DisjointRefl]
      {\alpha * B \in \Gamma}
      {\isdisjoint \Gamma \alpha B}

\inferrule* [right=DisjointSym]
      {\alpha * A \in \Gamma}
      {\isdisjoint \Gamma A \alpha}

    \inferrule* [right=DisjointSub1]
      {\isdisjoint \Gamma A C \\ \isdisjoint \Gamma B C}
      {\isdisjoint \Gamma {A \& B} {C}}

 \inferrule* [right=DisjointSub2]
      {\isdisjoint \Gamma A B \\ \isdisjoint \Gamma A C}
      {\isdisjoint \Gamma {A} {B \& C}}

\inferrule* [right=DisjointAtomic]
      {A \not<: B \\ B \not<: A \\ A~atomic \\ B~atomic}
      {\isdisjoint \Gamma {A} {B}}

  \end{mathpar}
  \caption{Disjointness.}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \framebox{$ \Gamma \turns A~type$} \\

    \inferrule* [right=WFBot]
      {}
      {\Gamma \turns \bot~type}

\inferrule* [right=WFFun]
      {\Gamma \turns A~type \\ \Gamma \turns B~type}
      {\Gamma \turns A \to B~type}

    \inferrule* [right=WFForall]
      {\Gamma, \alpha * B \turns A~type}
      {\Gamma \turns \for {\alpha * B} A~type}

 \inferrule* [right=WFVar]
      {\alpha * A \in \Gamma}
      {\Gamma \turns \alpha~type}

\inferrule* [right=WFInter]
      {\Gamma \turns A~type \\ \Gamma \turns B~type \\ \isdisjoint \Gamma A B}
      {\Gamma \turns A \intersect B type}

  \end{mathpar}
  \caption{Well-formed types.}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \framebox{$ \hastype \Gamma e A \yields E $} \\
    \ruleVar \and
%    \ruleTop \and
    \ruleLam \and
    \ruleApp \and
    \ruleBLam \and
    \ruleTApp \and
    \ruleMerge \and
%    \ruleConstraintIntro \and
%    \ruleConstraintElim
    % \rulerecordConstruct \and
    % \ruleRecSelect \and \ruleRecRestrict
  \end{mathpar}

  % % Selection
  % \begin{mathpar}
  %   \framebox{$\judgeSelect {\tau_1} l \tau_2 \yields C$} \and
  %   \ruleGet \and \ruleGetLeft \and \ruleGetRight
  % \end{mathpar}
  %
  % % Restriction
  % \begin{mathpar}
  %   \framebox{$\judgeRestrict {\tau_1} l \tau_2 \yields C$} \and
  %   \ruleRestrict \and \ruleRestrictLeft \and \ruleRestrictRight
  % \end{mathpar}

  \caption{Typing.}
\end{figure}

\subsection{``Testsuite'' of examples}

\begin{enumerate}

\item $\lambda (x : Int * Int). (\lambda (z : Int) . z)~x$: This
  example should not type-check because it leads to an ambigous choice
  in the body of the lambda. In the current system the well-formedness
  checks forbid such example.

\item $\Lambda A.\Lambda B.\lambda (x:A).\lambda (y:B). (\lambda (z:A)
  . z) (x,,y)$: This example should not type-check because it is not
  guaranteed that the instantiation of A and B produces a well-formed
  type. The TyMerge rule forbids it with the disjointness check.

\item $\Lambda A.\Lambda B * A.\lambda (x:A).\lambda (y:B). (\lambda
  (z:A) . z) (x,,y)$: This example should type-check because B is
  guaranteed to be disjoint with A. Therefore instantiation should
  produce a well-formed type.

\item $(\lambda (z:Int) . z) ((1,,'c'),,(2,False))$: This example
  should not type-check, since it leads to an ambigous lookup of
  integers (can either be 1 or 2). The definition of disjointness is
  crutial to prevent this example from type-checking. When
  type-checking the large merge, the disjointness predicate will
  detect that more than one integer exists in the merge.

\item $(\lambda (f: Int \to Int \& Bool) . \lambda (g : Int \to Char \& Bool) . ((f,,g) : Int \to Bool)$: 
  This example
  should not type-check, since it leads to an ambigous lookup of
  functions. It shows that in order to check disjointness 
  of functions we must also check disjointness of the subcomponents. 

\end{enumerate}

\subsection{Achieving Coherence}

The crutial challenge lies in the generation of coercions, which can lead 
to different results due to multiple possible choices in the rules that 
can be used. In particular the rules SubAnd1 and SubAnd2 overlap and 
can result in coercions that are not equivalent. A simple example is:

$(\lambda (x:Int) . x) (1,,2)$

The result of this program can be either 1 or 2 depending on whether 
we chose SubAnd1 or SubAnd2. 

Therefore the challenge of coherence lies in ensuring that, for any given 
types A and B, the result of $A <: B$ always leads to the same (or semantically 
equivalent) coercions. 

It is clear that, in general, the following does not hold:

$if~A <: B \leadsto C1~and~A <: B \leadsto C2~then~C1 = C2$

We can see this with the example above. There are two possible coercions:\\

\noindent $(Int\&Int) <: Int \leadsto \lambda (x,y). x$\\
$(Int\&Int) <: Int \leadsto \lambda (x,y). y$\\

However $\lambda (x,y). x$ and $\lambda (x,y). y$ are not semantically equivalent.

One simple observation is that the use of the subtyping relation on the 
example uses an ill-formed type ($Int\&Int$). Since the type system can prevent 
such bad uses of ill-formed types, it could be that if we only allow well-formed 
types then the uses of the subtyping relation do produce equivalent coercions. 
Therefore the we postulate the following conjecture:

$if~A <: B \leadsto C1~and~A <: B \leadsto C2~and~A, B~well~formed~then~C1 = C2$

If the following conjecture does hold then it should be easy to prove that 
the translation is coherent.

\begin{mathpar}
  \inferrule
  {}
  {\hastype \epsilon {1 \mergeOp 2} {\constraints {\integer \disjoint \integer} \integer \intersect \integer}}
\end{mathpar}

\begin{definition}{(Disjointness)}
Two sets $S$ and $T$ are \emph{disjoint} if there does not exist an element $x$, such that $x \in S$ and $x \in T$.
\end{definition}

\begin{definition}{(Disjointness)}
Two types $A$ and $B$ are \emph{disjoint} if there does not exist an expression $e$, which is not a merge, such that $\hastype \epsilon e A'$, $\hastype \epsilon e B'$, $A' \subtype A$, and $B' \subtype B$.
\end{definition}

\begin{definition}{(Disjointness)}
$A \bot B = \not \exists C. A <: C \wedge B <: C$ \\

Two types $A$ and $B$ are \emph{disjoint} if their least common supertype is $\top$.
\end{definition}

% \begin{figure}
%   % Typing
%   \begin{mathpar}
%     \framebox{$ \hastype \Gamma e A \yields E $} \\
%     \ruleVar \and
%     \ruleTop \and
%     \ruleLam \and
%     \ruleApp \and
%     \ruleBLam \and
%     \ruleTApp \and
%     \ruleMerge \and
%     \ruleDisjointAssume \and
%     \ruleDisjointCheck
%     % \rulerecordConstruct \and
%     % \ruleRecSelect \and \ruleRecRestrict
%   \end{mathpar}
%
%   % % Selection
%   % \begin{mathpar}
%   %   \framebox{$\judgeSelect {\tau_1} l \tau_2 \yields C$} \and
%   %   \ruleGet \and \ruleGetLeft \and \ruleGetRight
%   % \end{mathpar}
%   %
%   % % Restriction
%   % \begin{mathpar}
%   %   \framebox{$\judgeRestrict {\tau_1} l \tau_2 \yields C$} \and
%   %   \ruleRestrict \and \ruleRestrictLeft \and \ruleRestrictRight
%   % \end{mathpar}
%
%   \caption{Disjointness.}
% \end{figure}

\end{document}
