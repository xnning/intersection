\documentclass[preprint]{sigplanconf}

\usepackage{comment}

\input{packages.tex}
\input{macros.tex}

\input{rule_as_macros/orthogonality.tex}
\input{rule_as_macros/sub.tex}
\input{rule_as_macros/typing.tex}
% \input{rule_as_macros/target.tex}
\input{rule_as_macros/wellformedness.tex}

\newcommand{\name}{{\bf $F_{\&}$}\xspace}

\newcommand{\target}{{\bf f}\xspace}
\newcommand{\Target}{{\bf f}\xspace}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{\name}

% Coherence for well-typed terms.

\begin{figure}
  \[
  \begin{array}{l}
    \begin{array}{llrll}
      \text{Types}
      & T & \Coloneqq & \alpha     & \text{Type variable} \\
      &         & \mid & \bot            & \text{Bottom type} \\
      &        & \mid & A \to B         & \text{Function type}\\
      &         & \mid & \for {\alpha * B} A   & \text{Universal quantification} \\
      &         & \mid & A \intersect B  & \text{Intersection type} \\
%      &         & \mid & \constraints {A \disjoint B} C & \text{Disjoint constraint} \\
      % &         & \mid & \recordType l A & \text{Record type} \\
%     \\
%     \text{Types}
%     & A, B, C, D & \Coloneqq & \alpha     & \text{Type variable} \\
%     &  & \mid & A \intersect B  & \text{Intersection type} \\
%     &         & \mid & A \intersect B  & \text{Intersection type} \\
%     &         & \mid & T  & \text{Atomic type} \\

      \\
      \text{Expressions}
      & e & \Coloneqq & x            & \text{Variable} \\
%      &   & \mid & \top              & \text{Top} \\
      &   & \mid & \lam x A e        & \text{Lambda} \\
      &   & \mid & \app {e_1} {e_2}  & \text{Application} \\
      &   & \mid & \blam {\alpha * A}  e    & \text{Big lambda} \\
      &   & \mid & \tapp e A         & \text{Type application} \\
      &   & \mid &  e_1 \mergeOp e_2 & \text{Merge} \\
      % &   & \mid & {\_}                 & \text{Disjointness evidence}
%      &   & \mid & \assume {(A \disjoint B)} e & \text{Constraint intro} \\
%      &   & \mid & \app e {\_}                 & \text{Constraint elim} \\
      % &   & \mid & \recordCon l e    & \text{Record} \\
      % &   & \mid & e.l               & \text{Record selection} \\
      % &   & \mid & e \restrictOp l   & \text{Record restriction} \\

      \\
      \text{Contexts}
      & \Gamma & \Coloneqq & \epsilon         & \\
      &        & \mid & \Gamma, \alpha * A       & \\
      &        & \mid & \Gamma, x \hast A     & \\
%      &        & \mid & \Gamma, A \disjoint B & \\

      % \\
      \text{Sugar} & \blam {\alpha} e & \equiv & \blam {\alpha * \bot} e & \\
                   & e : A &  \equiv & (\lambda z : A . z) e &
    \end{array}
  \end{array}
  \]
  \caption{Syntax.}
\end{figure}

% \begin{figure*}
%   \caption{Disjointness between types.}
% \end{figure*}

% \begin{figure*}
%   \input{rule_in_figures/wellformedness.tex}
%   \caption{Well-formedness of types.}
% \end{figure*}

% \begin{figure*}
% \begin{mathpar}
% \begin{array}{l}
%   \begin{array}{llrl}
%     \text{Values} & v & \Coloneqq & \top \mid \lam x \tau e \mid \blam \alpha e \mid v_1 \mergeOp v_2 \mid \recordCon l e
%   \end{array}
% \end{array}
% \end{mathpar}
%
%   \caption{Values.}
% \end{figure*}

% \begin{figure*}

%   \begin{mathpar}
%     \begin{array}{lcl}
%       \fields {v_1 \mergeOp v_2} &=& \fields {v_1} \concatOp \fields {v_2} \\
%       \fields {\recordCon l e}   &=& [(l, e)] \\
%       \fields v                  &=& []
%     \end{array}
%   \end{mathpar}
%   \caption{\code{fields}.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \begin{array}{lcl}
%       \remove {\recordCon l e} l &=& \top \\
%       \remove {\recordCon l e \mergeOp v_2} l &=& v_2 \\
%       \remove {\recordCon l e \mergeOp v_2} {l'} &=& \recordCon l e \mergeOp \remove {v_2} {l'} \quad \quad (l \neq l') \\
%       \remove {v_1 \mergeOp \recordCon l e} l &=& v_1 \\
%       \remove {v_1 \mergeOp \recordCon l e} {l'} &=& \remove {v_1} {l'} \mergeOp \recordCon l e \quad \quad (l \neq l') \\

%       \remove v l                  &=& v
%     \end{array}

%   \end{mathpar}

%   \caption{\code{remove}.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \inferrule* [right=Cast/UpCast]
%       {\tau_1 \subtype \tau}
%       {\cast \tau {\withType v {\tau_1}} \hookrightarrow v}
%
%     \inferrule* [right=Cast/TakeLeft]
%       {\cast \tau {\withType {v_1} {\tau_1}} \hookrightarrow v}
%       {\cast \tau {\withType {v_1 \mergeOp v_2} {\tau_1 \intersect \tau_2}} \hookrightarrow v}
%
%     \inferrule* [right=Cast/TakeRight]
%       {\cast \tau {\withType {v_2} {\tau_2}} \hookrightarrow v}
%       {\cast \tau {\withType {v_1 \mergeOp v_2} {\tau_1 \intersect \tau_2}} \hookrightarrow v}
%   \end{mathpar}
%
%   \caption{Casts.}
% \end{figure*}

% \begin{figure*}
%   \begin{mathpar}
%     \inferrule* [right=Dyn/Val]
%       { }
%       {v \Downarrow v}
%
%     \inferrule* [right=Dyn/App]
%       {e_1 \Downarrow \lam x \tau e \\
%        e_2 \Downarrow v_2 \\
%        \cast \tau {\withType {v_2} {\tau_2}} \hookrightarrow v_3 \\
%        \subst {v_3} x e \Downarrow v}
%       {\app {e_1} {\withType {e_2} {\tau_2}} \Downarrow v}
%
%     \inferrule* [right=Dyn/TApp]
%       {e_1 \Downarrow \for \alpha e \\
%        \subst \tau \alpha e \Downarrow v}
%       {\tapp {e_1} \tau \Downarrow v}
%
%     \inferrule* [right=Dyn/Merge]
%       {e_1 \Downarrow v_1 \\ e_2 \Downarrow v_2}
%       {e_1 \mergeOp e_2 \Downarrow v_1 \mergeOp v_2}
%
%     % \inferrule* [right=Dyn/RecSelect]
%     %   {e \Downarrow v \\
%     %    (l, e_1) \; \code{`uniqueElem`} \; \fields v \\
%     %    e_1 \Downarrow v_1}
%     %   {e.l \Downarrow v_1}
%
%     % \inferrule* [right=Dyn/RecRestrict]
%     %   {e \Downarrow v \\
%     %    (l, e_1) \; \code{`uniqueElem`} \; \fields v}
%     %   {e \restrictOp l \Downarrow v \; \code{`remove`} \; l}
%   \end{mathpar}
%
%   \caption{Dynamic semantics.}
% \end{figure*}
%
% \begin{figure*}
%   \input{rule_in_figures/type-translation.tex}
%   \caption{Type translation.}
% \end{figure*}

\begin{figure}
  \begin{mathpar}
  \framebox{$ A \subtype B \yields F $} \\
  \subVar \\
%  \subTop \\
  \subFun \\
  \subForall \\
  \subAnd \\
  \subAndleft \\
  \subAndright \\
%  \subConstraint
  \end{mathpar}\footnote{miss a rule for $\bot$}
  \caption{Subtyping.}
\end{figure}


\begin{comment}
\begin{figure}
  \begin{mathpar}
    \framebox{$ A~atomic$} \\

    \inferrule*
      {}
      {\bot~atomic}

\inferrule*
      {}
      {A \to B~atomic}

    \inferrule*
      {}
      {\for {\alpha * B} A~atomic}

  \end{mathpar}
  \caption{Atomic types.}
\end{figure}
\end{comment}

\begin{figure}
  \begin{mathpar}
    \framebox{$ \isdisjoint \Gamma A B$} \\

    \inferrule* [right=DisjointRefl]
      {\alpha * B \in \Gamma}
      {\isdisjoint \Gamma \alpha B}

\inferrule* [right=DisjointSym]
      {\alpha * A \in \Gamma}
      {\isdisjoint \Gamma A \alpha}

    \inferrule* [right=DisjointSub1]
      {\isdisjoint \Gamma A C \\ \isdisjoint \Gamma B C}
      {\isdisjoint \Gamma {A \& B} {C}}

 \inferrule* [right=DisjointSub2]
      {\isdisjoint \Gamma A B \\ \isdisjoint \Gamma A C}
      {\isdisjoint \Gamma {A} {B \& C}}

\inferrule* [right=DisjointFun]
      {\isdisjoint \Gamma B D}
      {\isdisjoint \Gamma {A \to B} {C \to D}}\\

\inferrule* [right=DisjointForall]
      {\isdisjoint \Gamma A C}
      {\isdisjoint \Gamma {\for {\alpha * B} A} {\for {\alpha * B} C}}\\

\inferrule* [right=DisjointAtomic]
      {A \not\sim B}
      {\isdisjoint \Gamma {A} {B}}\\

\framebox{$ A \not\sim B$} \\

\inferrule* [right=NotSimBot1]
      {}
      {\bot \not\sim A \to B}

\inferrule* [right=NotSimBot2]
      {}
      {\bot \not\sim \for {\alpha * B} A}

\inferrule* [right=NotSimFunForall]
      {}
      {A \to B \not\sim \for {\alpha * B} A}

\inferrule* [right=NotSimFunForall]
      {B \not\sim A}
      {A \not\sim B}

  \end{mathpar}
  \caption{Disjointness.}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \framebox{$\istype \Gamma \tau$} \\

    \inferrule* [right=WFBot]
      { }
      {\istype \Gamma \bot}

\inferrule* [right=WFFun]
      {\istype \Gamma A \\ \istype \Gamma B}
      {\istype \Gamma {A \to B}}

    \inferrule* [right=WFForall]
      {\istype \Gamma B \\ \istype {\Gamma, \alpha * B} A}
      {\istype \Gamma {\for {\alpha * B} A}}

 \inferrule* [right=WFVar]
      {\alpha * A \in \Gamma}
      {\istype \Gamma \alpha}

\inferrule* [right=WFInter]
      {\istype \Gamma A \\ \istype \Gamma B \\ \isdisjoint \Gamma A B}
      {\istype \Gamma {A \intersect B}}

  \end{mathpar}
  \caption{Well-formed types.}
\end{figure}

\begin{figure}
  \begin{mathpar}
    \framebox{$ \hastype \Gamma e A \yields E $} \\
    \ruleVar \and
%    \ruleTop \and
    \ruleLam \and
    \ruleApp \and
    \ruleBLam \and
    \ruleTApp \and
    \ruleMerge \and
%    \ruleConstraintIntro \and
%    \ruleConstraintElim
    % \rulerecordConstruct \and
    % \ruleRecSelect \and \ruleRecRestrict
  \end{mathpar}

  % % Selection
  % \begin{mathpar}
  %   \framebox{$\judgeSelect {\tau_1} l \tau_2 \yields C$} \and
  %   \ruleGet \and \ruleGetLeft \and \ruleGetRight
  % \end{mathpar}
  %
  % % Restriction
  % \begin{mathpar}
  %   \framebox{$\judgeRestrict {\tau_1} l \tau_2 \yields C$} \and
  %   \ruleRestrict \and \ruleRestrictLeft \and \ruleRestrictRight
  % \end{mathpar}

  \caption{Typing.}
\end{figure}

\subsection{``Testsuite'' of examples}

\begin{enumerate}

\item $\lambda (x : Int * Int). (\lambda (z : Int) . z)~x$: This
  example should not type-check because it leads to an ambigous choice
  in the body of the lambda. In the current system the well-formedness
  checks forbid such example.

\item $\Lambda A.\Lambda B.\lambda (x:A).\lambda (y:B). (\lambda (z:A)
  . z) (x,,y)$: This example should not type-check because it is not
  guaranteed that the instantiation of A and B produces a well-formed
  type. The TyMerge rule forbids it with the disjointness check.

\item $\Lambda A.\Lambda B * A.\lambda (x:A).\lambda (y:B). (\lambda
  (z:A) . z) (x,,y)$: This example should type-check because B is
  guaranteed to be disjoint with A. Therefore instantiation should
  produce a well-formed type.

\item $(\lambda (z:Int) . z) ((1,,'c'),,(2,False))$: This example
  should not type-check, since it leads to an ambigous lookup of
  integers (can either be 1 or 2). The definition of disjointness is
  crutial to prevent this example from type-checking. When
  type-checking the large merge, the disjointness predicate will
  detect that more than one integer exists in the merge.

\item $(\lambda (f: Int \to Int \& Bool) . \lambda (g : Int \to Char \& Bool) . ((f,,g) : Int \to Bool)$:
  This example
  should not type-check, since it leads to an ambigous lookup of
  functions. It shows that in order to check disjointness
  of functions we must also check disjointness of the subcomponents.

\item $(\lambda (f: Int \to Int) . \lambda (g : Bool \to Int) . ((f,,g) : Bool \& Int \to Int)$:
  This example shows that whenever the return types overlap, so does the function type:
  we can always find a common subtype for the argument types.
\end{enumerate}

\subsection{Achieving Coherence}

The crutial challenge lies in the generation of coercions, which can lead
to different results due to multiple possible choices in the rules that
can be used. In particular the rules SubAnd1 and SubAnd2 overlap and
can result in coercions that are not equivalent. A simple example is:

$(\lambda (x:Int) . x) (1,,2)$

The result of this program can be either 1 or 2 depending on whether
we chose SubAnd1 or SubAnd2.

Therefore the challenge of coherence lies in ensuring that, for any given
types A and B, the result of $A <: B$ always leads to the same (or semantically
equivalent) coercions.

It is clear that, in general, the following does not hold:

$if~A <: B \leadsto C1~and~A <: B \leadsto C2~then~C1 = C2$

We can see this with the example above. There are two possible coercions:\\

\noindent $(Int\&Int) <: Int \leadsto \lambda (x,y). x$\\
$(Int\&Int) <: Int \leadsto \lambda (x,y). y$\\

However $\lambda (x,y). x$ and $\lambda (x,y). y$ are not semantically equivalent.

One simple observation is that the use of the subtyping relation on the
example uses an ill-formed type ($Int\&Int$). Since the type system can prevent
such bad uses of ill-formed types, it could be that if we only allow well-formed
types then the uses of the subtyping relation do produce equivalent coercions.
Therefore the we postulate the following conjecture:

$if~A <: B \leadsto C1~and~A <: B \leadsto C2~and~A, B~well~formed~then~C1 = C2$

If the following conjecture does hold then it should be easy to prove that
the translation is coherent.

\begin{mathpar}
  \inferrule
  {}
  {\hastype \epsilon {1 \mergeOp 2} {\constraints {\integer \disjoint \integer} \integer \intersect \integer}}
\end{mathpar}

% \begin{definition}{(Disjointness)}
% Two sets $S$ and $T$ are \emph{disjoint} if there does not exist an element $x$, such that $x \in S$ and $x \in T$.
% \end{definition}

% \begin{definition}{(Disjointness)}
% Two types $A$ and $B$ are \emph{disjoint} if there does not exist an expression $e$, which is not a merge, such that $\hastype \epsilon e A'$, $\hastype \epsilon e B'$, $A' \subtype A$, and $B' \subtype B$.
% \end{definition}

We say two types are \emph{disjoint} if they do not share a common supertype.

\begin{definition}[Disjointness]
$A \bot B = \not \exists C. A <: C \wedge B <: C$
\end{definition}

% \begin{figure}
%   % Typing
%   \begin{mathpar}
%     \framebox{$ \hastype \Gamma e A \yields E $} \\
%     \ruleVar \and
%     \ruleTop \and
%     \ruleLam \and
%     \ruleApp \and
%     \ruleBLam \and
%     \ruleTApp \and
%     \ruleMerge \and
%     \ruleDisjointAssume \and
%     \ruleDisjointCheck
%     % \rulerecordConstruct \and
%     % \ruleRecSelect \and \ruleRecRestrict
%   \end{mathpar}
%
%   % % Selection
%   % \begin{mathpar}
%   %   \framebox{$\judgeSelect {\tau_1} l \tau_2 \yields C$} \and
%   %   \ruleGet \and \ruleGetLeft \and \ruleGetRight
%   % \end{mathpar}
%   %
%   % % Restriction
%   % \begin{mathpar}
%   %   \framebox{$\judgeRestrict {\tau_1} l \tau_2 \yields C$} \and
%   %   \ruleRestrict \and \ruleRestrictLeft \and \ruleRestrictRight
%   % \end{mathpar}
%
%   \caption{Disjointness.}
% \end{figure}

\section{Polymorphism with disjoint constraint}

With a subtyping relation in a type system, bounded polymorphism extends the universal quantifier by confining the polymorphic type to be a subtype of a given type. In our type system, the forall binder also extends the parametric polymorphism, but in a different vein: the polymorphic type can only be disjoint with a given type.

\begin{itemize}
  \item \textbf{Bounded polymorphism}---the instantiation can only be the descendant of a given type
  \item \textbf{Polymorphism with disjoint constraint}---the instantiation cannot share a common ancestor with a given type
\end{itemize}

The intuition can be found in figure \ldots.

% http://tex.stackexchange.com/questions/158876/drawing-subgroup-lattices-in-tikz
\begin{figure}

% center everything in the figure
\centering
% horizontal node distance
\newcommand{\mydistance}{.6cm}
\begin{tikzpicture}[node distance=2cm]
\title{Untergruppenverband der $A_4$}
\node(A4)                           {$A_4$};
\node(V4)       [below right=2cm and 2cm of A4] {$V_4$};
\node(C31)      [below left=2cm and 0cm of A4]  {$C_3$};
\node(C32)      [left=\mydistance of C31]       {$C_3$};
\node(C33)      [left=\mydistance of C32]       {$C_3$};
\node(C34)      [left=\mydistance of C33]       {$C_3$};
\node(C22)      [below=2cm of V4]       {$C_2$};
\node(C21)      [left=\mydistance of C22]       {$C_2$};
\node(C23)      [right=\mydistance of C22]      {$C_2$};
\node(1)            [below=6cm of A4]     {$\left\{1\right\}$};
\draw(A4)       -- (V4);
\foreach \x\y in {1,2,3,4} {
    \draw (A4) -- (C3\x) node [midway, fill=white] {3};
    \draw (C3\x) -- (1);

}
\foreach \x\y in {1/2,2/3,3/4} {
    \draw(V4) -- (C2\x) node [midway, fill=white] {2};
\draw (C3\x) -- (C3\y);
\draw (C2\x) -- (1);
}
\draw(C21)      -- (C22);
\draw(C22)      -- (C23);
\end{tikzpicture}
\caption{Untergruppenverband}
\end{figure}

\section{Proof}

\subsection{Sketch of the proof}

\begin{lemma}[Unique subtype contributor] \label{unique-subtype-contributor}
If $A \intersect B \subtype C$, where $A \intersect B$ and $C$ are well-formed types, then one and only one of the following is possible:
\begin{enumerate}
\item $A \subtype C$
\item $B \subtype C$
\end{enumerate}
\end{lemma}

If $A \intersect B \subtype C$, then either $A$ or $B$ contributes to that subtyping relation, but not both. The implication of this lemma is that during the derivation, it is not possible that two rules are applicable.

\begin{proof}
Idea: First we will show that the $A \subtype C$ and $B \subtype C$ cannot hold simultaneously. Then we will show that at least one of them holds.

For the first claim, since $A \intersect B$ is well-formed, $A \disjoint B$. Then by the definition of disjointness, there does not exist a type $C$ such that $A \subtype C$ and $B \subtype C$. It follows that $A \subtype C$ and $B \subtype C$ cannot hold simultaneously.

For the second claim, let's suppose the contrary. Then it is impossible that $A \intersect B \subtype C$.
\end{proof}

The coercion of a subtyping relation $A \subtype B$ is uniquely determined.

\begin{lemma}[Unique coercion] \label{unique-coercion}
If $A \subtype B \yields {C_1}$ and $A \subtype B \yields {C_2}$, then $C_1 \equiv C_2$
\end{lemma}

\begin{proof}
By \ref{unique-subtype-contributor}.
\end{proof}

Given a source expression $e$, elaboration always produces the same target expression $E$.

\begin{theorem}[Unique elaboration] \label{unique-elaboration}
If $\hastype \Gamma e {\tau_1} \yields {E_1}$ and $\hastype \Gamma e {\tau_2} \yields {E_2}$, then $E_1 \equiv E_2$
\end{theorem}

\end{document}
