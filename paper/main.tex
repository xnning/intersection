\documentclass[preprint]{sigplanconf}

% Use packages immediately following the \documentclass command
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fixltx2e}
\usepackage{listings}
\usepackage{mdframed}
\usepackage{xcolor}

\newmdtheoremenv{theorem}{Theorem}
\newmdtheoremenv{lemma}{Lemma}

\definecolor{github}{HTML}{4183C4}

% Define macros immediately before the \begin{document} command
\input{macros/type_systems.tex}
\input{macros/systemfi.tex}
\newcommand{\FI}{\bf FI}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{\FI}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
\end{abstract}

\keywords
intersecion types, inheritance

\section{Introduction}

Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

We present a polymorphic language with intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.

This paper introduces System $F_{IR}$

\section{Overview}

There should be a section informally describing the language (System FI) through
various examples. Intersection types provide a general mechanism for ad-hoc
polymorphism.

While elaboration intersection types has been

In summary, the contributions of this paper are:

\begin{itemize}

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $e$ has type $\tau$ in the source language,
    then the translated term $|e|$ is well-typed and has type $|\tau|$ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{itemize}

Mention properties informally via examples:

%f : A & A -> A
%f x = x

Typeclasses

Intersecion types in Scala

show :: (Int -> String) \& (Float -> String)

show

\subsection{Algebras}

\subsection{Lenses}

\subsection{Embedded DSLs}

\section{System F}

The target language is System F extended with a base type Int. The syntax and
typing is completely standard. The types are function, universal quantification.

\section{System FI}

The source language, System FI, is identical to the source language described in
the previous section, except for the two additions: intersection types and
records. The formalization includes only single records and single record types as the multi-records can be desugared into the merge of multiple single records.

Dunfield has described a language that includes a ``top'' type but it does not appear in our language.

Remark. The operational semantics of FI is not presented in this paper. However,

\section{Type-Directed Translation to System F}

In this section, we present a relatively lightweight type-directed elaboration
from FI to F. The elaboration consists of four sets of rules, which are
explained below:

\begin{itemize}

\item{\bf Coercion}

  The coercion judgment $ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $ extends
  the subtyping judgment with a coercion on the right hand side of
  $ \hookrightarrow $. A coercion, which is just an expression in the target
  language, is guaranteed to have type $ \tau_1 \to \tau_2 $, as proved by Lemma
  \ref{type-coerce}. It is read ``In the environment $ \Gamma $, $ \tau_1 $ is a
  subtype of $ \tau_2 $; and if any expression $ e $ has a type $ t_1 $ that is
  a subtype of the type of $ t_2 $, the elaborated $ e $, when applied to the
  corresponding coercion $ C $, has exactly type $ |t_2| $''. For example,
  $\Gamma \vdash Int \& Bool <: Bool \yields{fst} $, where $ fst $ is the
  projection of a tuple on the first element. The coercion judgment is only used
  in the \texttt{TrApp} case.

\item{\bf Elaboration}

  The elaboration judgment $ \Gamma \vdash e : \tau \yields{E} $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. It is also standard, except for the case of
  \texttt{TrApp}, in which a coercion from the inferred type of the argument to
  the expected type of the parameter is inserted before the argument; and the
  case of \texttt{TrRcdEim} and \texttt{TrRcdUpd}, where the ``get'' and ``put''
  rules will be used. The two set of rules are explained below.

\item{\bf ``get'' rules}

  The ``get'' judgment can be thought as producing a field accessor.

\item{\bf ``put'' rules}

  The ``put'' judgment can be thought as producing a field updater.

\end{itemize}

Type-Directed Translation to System F.
Main results: type-preservation + coherence.

\section{Implementation}

We extend the implementation of the type system extended with type synonyms.

\begin{lstlisting}
type T A1 A2 = ... in
\end{lstlisting}

\section{Case Study?}

\section{Properties}

\section{Case Studies}

\section{Related work}

\begin{itemize}

\item{\bf Elaborating simply-typed lambda calculus}

  Dunfield has introduced a type system with intersection polymorphism but no
  parametric polymorphism.

\end{itemize}

Nystrom et. al. OOPSLA 06


Applications:

- Object/Fold Algebras. How to support extensibility in an easier way.

See Datatypes a la Carte

- Mixins

- Lenses? Can intersection types help with lenses? Perhaps making the
types more natural and easy to understand/use?

- Embedded DSLs? Extensibility in DSLs? Composing multiple DSL interpretations?

http://www.cs.ox.ac.uk/jeremy.gibbons/publications/embedding.pdf

\framebox{$|\tau| = T$}

\[
\begin{array}{rcl}
  |\alpha|               & = & \alpha \\
  |\tau_1 \to \tau_2|    & = & |\tau_1| \to |\tau_2| \\
  |\forall \alpha. \tau| & = & \forall \alpha. |\tau| \\
  |t_1 \& t_2|           & = & \langle |\tau_1|, |\tau_2| \rangle \\
  |\{ l : \tau \}|       & = & |\tau|
\end{array}
\]

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $$
  then $$ |\Gamma| \vdash C : |\tau_1| \to |\tau_2| $$
\end{lemma}

\begin{proof}
By structural induction on the types and the corresponding inference rule. \\

\texttt{(SubVar)}

\texttt{(SubFun)}

\texttt{(SubForall)}

\texttt{(SubAnd1)}

\texttt{(SubAnd2)}

\texttt{(SubAnd3)}

\texttt{(SubRcd)}

\end{proof}

\begin{lemma} \label{type-get}
  If $$ \Gamma \vdash_{get} \tau ; l = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau_1| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Get-Base)} $ \Gamma \vdash_{get} \{ l : \tau \} ; l = \lambda (x : |\{ l : \tau \}|). x ; \tau $ \\

By the induction hypothesis
$$ |\Gamma| \vdash \lambda (x : |\{ l : \tau \}|). x : |\{ l : \tau \}| \to |\tau| $$

\texttt{(Get-Left)} \\
\texttt{(Get-Right)} \\

\end{proof}

\begin{lemma} \label{type-put}
  If $$ \Gamma \vdash_{put} \tau ; l ; E = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Put-Base)} \\
\texttt{(Put-Left)} \\
\texttt{(Put-Right)} \\
\end{proof}

\begin{lemma} \label{preserve-wf}
  If   $$ \Gamma \vdash \tau $$
  then $$ |\Gamma| \vdash |\tau| $$
\end{lemma}

\begin{proof}
Since $$ \Gamma \vdash \tau $$
It follows from \texttt{(FI-WF)} that
  $$ \ftv{\tau} \subseteq \ftv{\Gamma} $$
And hence
  $$ \ftv{|\tau|} \subseteq \ftv{|\Gamma|} $$
By \texttt{(F-WF)} we have
  $$ \Gamma \vdash \tau $$
\end{proof}

\begin{theorem}[Type preserving translation] \label{preserve-tr}
  If   $$ \Gamma \vdash e : \tau \yields{E} $$
  then $$ |\Gamma| \vdash E : \left| \tau \right| $$
\end{theorem}

\begin{proof}
By structural induction on the expression and the corresponding inference rule. \\

\texttt{(TrVar)} $ \Gamma \vdash x : \tau \yields{x} $ \\

It follows from \texttt{(TrVar)} that
  $$ (x : \tau) \in \Gamma $$
Based on the definition of $ |\cdot| $,
  $$ (x : |\tau|) \in |\Gamma| $$
Thus we have by \texttt{(F-Var)} that
  $$ |\Gamma| \vdash x : |\tau| $$

\texttt{(TrAbs)} $ \Gamma \vdash \lambda (x : \tau_1). e : \tau_1 \to \tau_2 \yields{\lambda x : |\tau_1|. E} $ \\

It follows from \texttt{(TrAbs)} that
  $$ \Gamma, x : \tau_1 \vdash e : \tau_2 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma|, x : |\tau_1| \vdash E : |\tau_2| $$
By \texttt{(TrAbs)} we also have
  $$ \Gamma \vdash \tau_1 $$
It follows from Lemma \ref{preserve-wf} that
  $$ |\Gamma| \vdash |\tau_1| $$
Hence by \texttt{(F-Abs)} and the definition of $|\cdot|$ we have
  $$ |\Gamma| \vdash \lambda x : |\tau_1|. E : |\tau_1 \to \tau_2| $$

\texttt{(TrApp)} $ \Gamma \vdash e_1 e_2 : \tau_2 \yields{E_1 (C E_2)} $ \\

From \texttt{(TrApp)} we have
  $$ \Gamma \vdash \tau_3 <: \tau_1 \yields{C} $$
Applying Lemma \ref{type-coerce} to the above we have
  $$ |\Gamma| \vdash C : |\tau_3| \to |\tau_1| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_1 : |\tau_1| \to |\tau_2| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_2 : |\tau_3| $$
Assembling those parts using \texttt{(F-App)} we come to
  $$ |\Gamma| \vdash E_1 (C E_2) : |\tau_2| $$
\end{proof}

\texttt{(TrTAbs)} $ \Gamma \vdash \Lambda \alpha. e : \forall \alpha. \tau \yields{\forall \alpha. E} $ \\

From \texttt{(TrTAbs)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
By the induction hypothesis we have
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by \texttt{(F-TAbs)} and the definition of $|\cdot|$
  $$ \Gamma \vdash \Lambda \alpha. E : |\forall \alpha. \tau| $$


\texttt{(TrTApp)} $ \Gamma \vdash e \; \tau  : [\alpha := \tau]\tau_1 \yields{E \; |\tau|} $ \\

From \texttt{(TrTApp)} we have
  $$ \Gamma \vdash e : \forall \alpha. \tau_1 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : \forall \alpha. |\tau_1| $$
Also from \texttt{(TrTApp)} and Lemma \ref{preserve-wf} we have
  $$ |\Gamma| \vdash |\tau| $$
Then by \texttt{(F-TApp)} that
  $$ |\Gamma| \vdash E \; |\tau| : [\alpha := |\tau| ]|\tau_1| $$
Therefore
  $$ |\Gamma| \vdash E \; |\tau| : | [\alpha := \tau ] | \tau_1 | | $$

\texttt{(TrMerge)} $ \Gamma \vdash e_1 \merge e_2 : \tau_1 \& \tau_2 \yields{\langle E1, E2  \rangle}$ \\

From \texttt{(TrMerge)} and the induction hypothesis we have
  $$ |\Gamma| \vdash E_1 : |\tau_1| $$
and
  $$ |\Gamma| \vdash E_2 : |\tau_2| $$
Hence by \texttt{(F-Pair)}
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : \langle |\tau_1|, |\tau_2| \rangle $$
Hence by the definition of $|\cdot|$
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : |\tau_1 \& \tau_2| $$

\texttt{(TrRcdIntro)} $ \Gamma \vdash \{ l = e \} : \{ l : \tau \} \yields{E} $ \\

From \texttt{(TrRcdIntro)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by the definition of $|\cdot|$
  $$ |\Gamma| \vdash E : |\{ l : \tau \}| $$

\texttt{(TrRcdElim)} $ \Gamma \vdash e.l : \tau_1 \yields{C E} $ \\

From \texttt{(TrRcdElim)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdEim)}
  $$ \Gamma \vdash_{get} e ; l = C ; \tau_1 $$
Applying Lemma \ref{type-get} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau_1|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau_1| $$

\texttt{(TrRcdUpd)} $ \Gamma \vdash \rcdupd{e}{l}{e_1} : \tau \yields{C E} $ \\

From \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash_{put} t ; l; E = C ; \tau_1 $$
Applying Lemma \ref{type-put} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau| $$


\appendix
\section{Proofs}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\bibliography{references}

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}



\end{document}
