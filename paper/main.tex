\documentclass[preprint]{sigplanconf}

% Use packages immediately following the \documentclass command
% Remote packages
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fixltx2e}
\usepackage{mdframed}
\usepackage{stmaryrd}
\usepackage{xcolor}

% For documentation for the `Listings` package,
% see http://texdoc.net/texmf-dist/doc/latex/listings/listings.pdf
\usepackage{listings}

% Use the minted package to format code snippets
% Documentation: https://code.google.com/p/minted/downloads/detail?name=minted.pdf
% \usepackage{minted}


% Local packages
\usepackage{bcprules}
\usepackage{cmll}
\usepackage{mathpartir}


% Always load mathastext last
% http://mirrors.ibiblio.org/CTAN/macros/latex/contrib/mathastext/mathastext.pdf
\renewcommand\familydefault\ttdefault
\usepackage{mathastext}
\renewcommand\familydefault\rmdefault


\newmdtheoremenv{theorem}{Theorem}
\newmdtheoremenv{lemma}{Lemma}

\definecolor{github}{HTML}{4183C4}

% Define macros immediately before the \begin{document} command
\input{macros.tex}

\lstdefinelanguage{F2J}{
  morekeywords={let,type,module,end,in},
  otherkeywords={->},
  sensitive=false, % whether keywords are case sensitive
  morecomment=[l]{--},
  morestring=[b]", % `b' means inside a string delimiters are escaped by a backslash.
  morestring=[b]'
}

\lstset{ %
  language=F2J,                % choose the language of the code
  columns=flexible,
  lineskip=-1pt,
  basicstyle=\ttfamily\small,       % the size of the fonts that are used for the code
  numbers=none,                   % where to put the line-numbers
  numberstyle=\ttfamily\tiny,      % the size of the fonts that are used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  morekeywords={var},
%  frame=single,                   % adds a frame around the code
  tabsize=2,                  % sets default tabsize to 2 spaces
  captionpos=none,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting; also try caption instead of title
  escapeinside={(*}{*)},          % if you want to add a comment within your code
  keywordstyle=\ttfamily\bfseries,
% commentstyle=\color{Gray}
% stringstyle=\color{Green}
}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{\name}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
\end{abstract}

\keywords
intersecion types, inheritance
\section{Introduction}

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]

We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.

Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.

In summary, the contributions of this paper are:

\begin{itemize}

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $e$ has type $\tau$ in the source language,
    then the translated term $|e|$ is well-typed and has type $|\tau|$ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{itemize}
\section{A Taste of fi}

\begin{footnote}
  Change the examples later to something very simple.
\end{footnote}

This section provides the reader with the intuition of \name, while we postpone
the presentation of the details in later sections.

In short, \name generalizes \systemf by adding intersection polymorphism. \name terms
are elaborated into \systemF, a variant of System F. System F, or polymorphic
lambda calculus lays the foundation of functional programming languages such as
Haskell.

The type system of \name permits a subtyping relation naturally and enables
prototype-based inheritance. We will explore the usefulness of such a type
system in practice by showing various examples.

\subsection{Intersection Types}

The central addition to the type system of \systemf in \name is intersection types. What
is an intersection type? One classic view is from set-theoretic interpretation
of types: \lstinline{A \& B} stands for the intersection of the set of values of
\lstinline{A} and \lstinline{B}. The other view, adopted in this paper, regards
types as a kind of interface: a value of type \lstinline{A \& B} satisfies both
of the interfaces of \lstinline{A} and \lstinline{B}. For example,
\lstinline{eval : Int} is the interface that supports evaluation to integers,
while \lstinline{ eval : Int \& print : String } supports both evaluation and
pretty printing. Those interfaces are akin to interfaces in Java or traits in
Scala. But one key difference is that they are unnamed in \name.

Intersection types provide a simple mechanism for ad-hoc polymorphism, similar
to what type classes in Haskell achieve. The key constructs are the ``merge''
operator, denoted by ``\lstinline{,,}'', at the value level and the corresponding type
intersection operator, denoted by, ``\lstinline{\&}'' at the type level.

For example, we can define an (ad-hoc)-polymorphic \lstinline{show} function
that is able to convert integers and booleans to strings. In \name such function
can be given the type
\begin{lstlisting}
  (Int -> String) & (Bool -> String)
\end{lstlisting}
and be defined using the merge operator $ ,, $ as
\begin{lstlisting}
  let show = showInt ,, showBool
\end{lstlisting}
where \lstinline{showString} and \lstinline{showBool} are ordinary monomorphic
functions. Later suppose the integer \lstinline{1} is applied to the \lstinline{show} function,
the first component \lstinline{showInt} will be picked because the type of \lstinline{showInt}
is compatible with \lstinline{1} while \lstinline{showBool} is not.

% The merge construct in the original function is elaborated into a pair in the
% target language:

% \begin{verbatim}
% show = (showInt, showBool)
% \end{verbatim}

% In the target language where there is no intersection types, the application
% of the integer \texttt{1} to this function does not typecheck. However, we may
% rescue this situtation by inserting a coercion that extracts the first item
% out of this pair.

% Thus \texttt{show 1} in FI corresponds to \texttt{(fst show) 1} in F.

% While elaborating intersection types, this paper is the first that presents a
% type system that incorporates both parametric polymorphism and intersection
% polymorphism.

% Describe intersection types, encoding records with Intersecion types

% \lstinputlisting[linerange=-]{} % APPLY:linerange=MIXIN_LIB

\subsection{Encoding Records}

In addition to introduction of record literals using the usual notation, \name
support two more operations on records: record elimination and record update.

A record type of the form \lstinline{l : t} can be thought as a normal type \lstinline{t}
tagged by the label \lstinline{l}.

% A basic example

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICS_ADD

\lstinline{e1} and \lstinline{e2} are two expressions that support both evaluation and pretty
printing and each has type \lstinline{eval : Int, print : String}. \lstinline{add} takes
two expressions and computes their sum. Note that in order to compute a sum,
\lstinline{add} only requires that the two expressions support evaluation and hence the
type of the parameter \lstinline{eval : Int}. As a result, the type of \lstinline{e1} and
\lstinline{e2} are not exactly the same with that of the parameters of \lstinline{add}. However,
under a structural type system, this program should typecheck anyway because the
arguments being passed has more information than required. In other words,
\lstinline{eval : Int, print : String} is a subtype of \lstinline{eval : Int}.

How is this subtyping relation derived? In \name, multi-field record types are
excluded from the type system because \lstinline{eval : Int, print : String} can
be encoded as \lstinline{eval : Int \& print : String}. And by one of
subtyping rules derives that \lstinline{eval : Int \& print : String} is a
subtype of \lstinline{eval : Int}.

% This example is elaborated into the following in \systemF.

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICSELAB_ADD

\subsection{Parametric Polymorphism}

The presence of both parametric polymorphism and intersection is critical, as we
shall see in the next section, in solving modularity problems. Here is a code
snippet from the next section (The reader is not required to understand the
purpose of this code at this stage; just recognizing the two types of
polymorphism is enough.)
\begin{lstlisting}
type SubExpAlg E = (ExpAlg E) \& { sub : E -> E -> E };
let e2 E (f : SubExpAlg E) = f.sub (exp1 E f) (f.lit 2);
\end{lstlisting}
\lstinline{SubExpAlg} is a type synonym (a la Haskell) defined as the intersection of
\lstinline{ExpAlg E} and \lstinline{sub : E -> E -> E}, parametrized by a type parameter
\lstinline{E}. \lstinline{e2} exhibits parametric polymorphism as it takes a type argument
\lstinline{E}.

\input{sections/application.tex}
\input{sections/fi.tex}
\input{sections/translation.tex}

\section{Implementation}

\subsection{Type Synonyms}

We extend the implementation of the type system extended with type synonyms and
lazy arguments.

\begin{lstlisting}
type T A1 A2 = ... in
\end{lstlisting}

\subsection{Optimization}
\section{Related Work}

\begin{itemize}

\item{\bf Elaborating simply-typed lambda calculus}

  Dunfield has introduced a type system with intersection polymorphism but no
  parametric polymorphism.

\end{itemize}

Nystrom et. al. OOPSLA 06

Applications:

- Object/Fold Algebras. How to support extensibility in an easier way.

See Datatypes a la Carte

- Mixins

- Lenses? Can intersection types help with lenses? Perhaps making the
types more natural and easy to understand/use?

- Embedded DSLs? Extensibility in DSLs? Composing multiple DSL interpretations?

http://www.cs.ox.ac.uk/jeremy.gibbons/publications/embedding.pdf

\section{Conclusion}

% \acks

Acknowledgments, if needed.

\appendix

\section{Proofs}

\begin{proof}
By structural induction on the types and the corresponding inference rule. \\

\texttt{(SubVar)}

\texttt{(SubFun)}

\texttt{(SubForall)}

\texttt{(SubAnd1)}

\texttt{(SubAnd2)}

\texttt{(SubAnd3)}

\texttt{(SubRcd)}

\end{proof}

\begin{lemma} \label{type-get}
  If $$ \Gamma \vdash_{get} \tau ; l = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau_1| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Get-Base)} $ \Gamma \vdash_{get} \{ l : \tau \} ; l = \lambda (x : |\{ l : \tau \}|). x ; \tau $ \\

By the induction hypothesis
$$ |\Gamma| \vdash \lambda (x : |\{ l : \tau \}|). x : |\{ l : \tau \}| \to |\tau| $$

\texttt{(Get-Left)} \\
\texttt{(Get-Right)} \\

\end{proof}

\begin{lemma} \label{type-put}
  If $$ \Gamma \vdash_{put} \tau ; l ; E = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Put-Base)} \\
\texttt{(Put-Left)} \\
\texttt{(Put-Right)} \\
\end{proof}

\begin{lemma} \label{preserve-wf}
  If   $$ \Gamma \vdash \tau $$
  then $$ |\Gamma| \vdash |\tau| $$
\end{lemma}

\begin{proof}
Since $$ \Gamma \vdash \tau $$
It follows from \texttt{(FI-WF)} that
  $$ \ftv{\tau} \subseteq \ftv{\Gamma} $$
And hence
  $$ \ftv{|\tau|} \subseteq \ftv{|\Gamma|} $$
By \texttt{(F-WF)} we have
  $$ \Gamma \vdash \tau $$
\end{proof}

\begin{theorem}[Type preserving translation] \label{preserve-tr}
  If   $$ \Gamma \vdash e : \tau \yields{E} $$
  then $$ |\Gamma| \vdash E : \left| \tau \right| $$
\end{theorem}

\begin{proof}
By structural induction on the expression and the corresponding inference rule. \\

\texttt{(TrVar)} $ \Gamma \vdash x : \tau \yields{x} $ \\

It follows from \texttt{(TrVar)} that
  $$ (x : \tau) \in \Gamma $$
Based on the definition of $ |\cdot| $,
  $$ (x : |\tau|) \in |\Gamma| $$
Thus we have by \texttt{(F-Var)} that
  $$ |\Gamma| \vdash x : |\tau| $$

\texttt{(TrAbs)} $ \Gamma \vdash \lambda (x : \tau_1). e : \tau_1 \to \tau_2 \yields{\lambda x : |\tau_1|. E} $ \\

It follows from \texttt{(TrAbs)} that
  $$ \Gamma, x : \tau_1 \vdash e : \tau_2 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma|, x : |\tau_1| \vdash E : |\tau_2| $$
By \texttt{(TrAbs)} we also have
  $$ \Gamma \vdash \tau_1 $$
It follows from Lemma \ref{preserve-wf} that
  $$ |\Gamma| \vdash |\tau_1| $$
Hence by \texttt{(F-Abs)} and the definition of $|\cdot|$ we have
  $$ |\Gamma| \vdash \lambda x : |\tau_1|. E : |\tau_1 \to \tau_2| $$

\texttt{(TrApp)} $ \Gamma \vdash e_1 e_2 : \tau_2 \yields{E_1 (C E_2)} $ \\

From \texttt{(TrApp)} we have
  $$ \Gamma \vdash \tau_3 <: \tau_1 \yields{C} $$
Applying Lemma \ref{type-coerce} to the above we have
  $$ |\Gamma| \vdash C : |\tau_3| \to |\tau_1| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_1 : |\tau_1| \to |\tau_2| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_2 : |\tau_3| $$
Assembling those parts using \texttt{(F-App)} we come to
  $$ |\Gamma| \vdash E_1 (C E_2) : |\tau_2| $$
\end{proof}

\texttt{(TrTAbs)} $ \Gamma \vdash \Lambda \alpha. e : \forall \alpha. \tau \yields{\forall \alpha. E} $ \\

From \texttt{(TrTAbs)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
By the induction hypothesis we have
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by \texttt{(F-TAbs)} and the definition of $|\cdot|$
  $$ \Gamma \vdash \Lambda \alpha. E : |\forall \alpha. \tau| $$


\texttt{(TrTApp)} $ \Gamma \vdash e \; \tau  : [\alpha := \tau]\tau_1 \yields{E \; |\tau|} $ \\

From \texttt{(TrTApp)} we have
  $$ \Gamma \vdash e : \forall \alpha. \tau_1 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : \forall \alpha. |\tau_1| $$
Also from \texttt{(TrTApp)} and Lemma \ref{preserve-wf} we have
  $$ |\Gamma| \vdash |\tau| $$
Then by \texttt{(F-TApp)} that
  $$ |\Gamma| \vdash E \; |\tau| : [\alpha := |\tau| ]|\tau_1| $$
Therefore
  $$ |\Gamma| \vdash E \; |\tau| : | [\alpha := \tau ] | \tau_1 | | $$

% \texttt{(TrMerge)} $ \Gamma \vdash e_1 \merge e_2 : \tau_1 \& \tau_2 \yields{\langle E1, E2  \rangle}$ \\

From \texttt{(TrMerge)} and the induction hypothesis we have
  $$ |\Gamma| \vdash E_1 : |\tau_1| $$
and
  $$ |\Gamma| \vdash E_2 : |\tau_2| $$
Hence by \texttt{(F-Pair)}
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : \langle |\tau_1|, |\tau_2| \rangle $$
Hence by the definition of $|\cdot|$
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : |\tau_1 \& \tau_2| $$

\texttt{(TrRcdIntro)} $ \Gamma \vdash \{ l = e \} : \{ l : \tau \} \yields{E} $ \\

From \texttt{(TrRcdIntro)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by the definition of $|\cdot|$
  $$ |\Gamma| \vdash E : |\{ l : \tau \}| $$

\texttt{(TrRcdElim)} $ \Gamma \vdash e.l : \tau_1 \yields{C E} $ \\

From \texttt{(TrRcdElim)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdEim)}
  $$ \Gamma \vdash_{get} e ; l = C ; \tau_1 $$
Applying Lemma \ref{type-get} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau_1|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau_1| $$

% \texttt{(TrRcdUpd)} $ \Gamma \vdash \rcdupd{e}{l}{e_1} : \tau \yields{C E} $ \\

From \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash_{put} t ; l; E = C ; \tau_1 $$
Applying Lemma \ref{type-put} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau| $$


% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\bibliography{references}

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

Coppo, M., Dezani-Ciancaglini, M.: A new type-assignment for λ-terms. Archiv.
Math. Logik 19, 139–156 (1978)

\end{thebibliography}

%% #include ../src/Algebra.sf

%% #end

\end{document}
