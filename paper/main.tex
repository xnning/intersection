\documentclass[preprint]{sigplanconf}

% Use packages immediately following the \documentclass command
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fixltx2e}

% For documentation for the `Listings` package,
% see http://texdoc.net/texmf-dist/doc/latex/listings/listings.pdf
\usepackage{listings}

% Use the minted package to format code snippets
% Documentation: https://code.google.com/p/minted/downloads/detail?name=minted.pdf
\usepackage{minted}

\usepackage{mdframed}
\usepackage{xcolor}

\newmdtheoremenv{theorem}{Theorem}
\newmdtheoremenv{lemma}{Lemma}

\definecolor{github}{HTML}{4183C4}

% Define macros immediately before the \begin{document} command
\input{macros/type_systems.tex}
% \input{macros/systemfi.tex}

\newcommand{\systemf}{{\bf f~}}
\newcommand{\systemF}{{\bf f}}

\newcommand{\systemfi}{{\bf fi~}}
\newcommand{\systemFI}{{\bf fi}}

\lstdefinelanguage{F2J}{
  morekeywords={let,type,module,end,in},
  otherkeywords={->},
  sensitive=false, % whether keywords are case sensitive
  morecomment=[l]{--},
  morestring=[b]", % `b' means inside a string delimiters are escaped by a backslash.
  morestring=[b]'
}

\lstset{ %
  language=F2J,                % choose the language of the code
  columns=flexible,
  lineskip=-1pt,
  basicstyle=\ttfamily\small,       % the size of the fonts that are used for the code
  numbers=none,                   % where to put the line-numbers
  numberstyle=\ttfamily\tiny,      % the size of the fonts that are used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  morekeywords={var},
%  frame=single,                   % adds a frame around the code
  tabsize=2,                  % sets default tabsize to 2 spaces
  captionpos=none,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting; also try caption instead of title
  escapeinside={(*}{*)},          % if you want to add a comment within your code
  keywordstyle=\ttfamily\bfseries,
% commentstyle=\color{Gray}
% stringstyle=\color{Green}
}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{\systemfi}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
\end{abstract}

\keywords
intersecion types, inheritance
\section{Introduction}

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]

We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.

Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.

In summary, the contributions of this paper are:

\begin{itemize}

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $e$ has type $\tau$ in the source language,
    then the translated term $|e|$ is well-typed and has type $|\tau|$ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{itemize}
\section{A Taste of fi}

\begin{footnote}
  Change the examples later to something very simple.
\end{footnote}

This section provides the reader with the intuition of \systemFI, while we postpone
the presentation of the details in later sections.

In short, \systemfi generalizes \systemf by adding intersection polymorphism. \systemfi terms
are elaborated into \systemF, a variant of System F. System F, or polymorphic
lambda calculus lays the foundation of functional programming languages such as
Haskell.

The type system of \systemfi permits a subtyping relation naturally and enables
prototype-based inheritance. We will explore the usefulness of such a type
system in practice by showing various examples.

\subsection{Intersection Types}

The central addition to the type system of \systemf in \systemfi is intersection types. What
is an intersection type? One classic view is from set-theoretic interpretation
of types: \lstinline{A \& B} stands for the intersection of the set of values of
\lstinline{A} and \lstinline{B}. The other view, adopted in this paper, regards
types as a kind of interface: a value of type \lstinline{A \& B} satisfies both
of the interfaces of \lstinline{A} and \lstinline{B}. For example,
\lstinline{eval : Int} is the interface that supports evaluation to integers,
while \lstinline{ eval : Int \& print : String } supports both evaluation and
pretty printing. Those interfaces are akin to interfaces in Java or traits in
Scala. But one key difference is that they are unnamed in \systemFI.

Intersection types provide a simple mechanism for ad-hoc polymorphism, similar
to what type classes in Haskell achieve. The key constructs are the ``merge''
operator, denoted by ``\lstinline{,,}'', at the value level and the corresponding type
intersection operator, denoted by, ``\lstinline{\&}'' at the type level.

For example, we can define an (ad-hoc)-polymorphic \lstinline{show} function
that is able to convert integers and booleans to strings. In \systemfi such function
can be given the type
\begin{lstlisting}
  (Int -> String) & (Bool -> String)
\end{lstlisting}
and be defined using the merge operator $ ,, $ as
\begin{lstlisting}
  let show = showInt ,, showBool
\end{lstlisting}
where \lstinline{showString} and \lstinline{showBool} are ordinary monomorphic
functions. Later suppose the integer \lstinline{1} is applied to the \lstinline{show} function,
the first component \lstinline{showInt} will be picked because the type of \lstinline{showInt}
is compatible with \lstinline{1} while \lstinline{showBool} is not.

% The merge construct in the original function is elaborated into a pair in the
% target language:

% \begin{verbatim}
% show = (showInt, showBool)
% \end{verbatim}

% In the target language where there is no intersection types, the application
% of the integer \texttt{1} to this function does not typecheck. However, we may
% rescue this situtation by inserting a coercion that extracts the first item
% out of this pair.

% Thus \texttt{show 1} in FI corresponds to \texttt{(fst show) 1} in F.

% While elaborating intersection types, this paper is the first that presents a
% type system that incorporates both parametric polymorphism and intersection
% polymorphism.

% Describe intersection types, encoding records with Intersecion types

% \lstinputlisting[linerange=-]{} % APPLY:linerange=MIXIN_LIB

\subsection{Encoding Records}

In addition to introduction of record literals using the usual notation, \systemfi
support two more operations on records: record elimination and record update.

A record type of the form \lstinline{l : t} can be thought as a normal type \lstinline{t}
tagged by the label \lstinline{l}.

% A basic example

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICS_ADD

\lstinline{e1} and \lstinline{e2} are two expressions that support both evaluation and pretty
printing and each has type \lstinline{eval : Int, print : String}. \lstinline{add} takes
two expressions and computes their sum. Note that in order to compute a sum,
\lstinline{add} only requires that the two expressions support evaluation and hence the
type of the parameter \lstinline{eval : Int}. As a result, the type of \lstinline{e1} and
\lstinline{e2} are not exactly the same with that of the parameters of \lstinline{add}. However,
under a structural type system, this program should typecheck anyway because the
arguments being passed has more information than required. In other words,
\lstinline{eval : Int, print : String} is a subtype of \lstinline{eval : Int}.

How is this subtyping relation derived? In \systemFI, multi-field record types are
excluded from the type system because \lstinline{eval : Int, print : String} can
be encoded as \lstinline{eval : Int \& print : String}. And by one of
subtyping rules derives that \lstinline{eval : Int \& print : String} is a
subtype of \lstinline{eval : Int}.

% This example is elaborated into the following in \systemF.

% \lstinputlisting[linerange=-]{} % APPLY:linerange=BASICSELAB_ADD

\subsection{Parametric Polymorphism}

The presence of both parametric polymorphism and intersection is critical, as we
shall see in the next section, in solving modularity problems. Here is a code
snippet from the next section (The reader is not required to understand the
purpose of this code at this stage; just recognizing the two types of
polymorphism is enough.)
\begin{lstlisting}
type SubExpAlg E = (ExpAlg E) \& { sub : E -> E -> E };
let e2 E (f : SubExpAlg E) = f.sub (exp1 E f) (f.lit 2);
\end{lstlisting}
\lstinline{SubExpAlg} is a type synonym (a la Haskell) defined as the intersection of
\lstinline{ExpAlg E} and \lstinline{sub : E -> E -> E}, parametrized by a type parameter
\lstinline{E}. \lstinline{e2} exhibits parametric polymorphism as it takes a type argument
\lstinline{E}.

\section{Application}

Multiple inheritance?

% Algebra -> P1,2
% Visitor -> P2

% Yanlin
% Mixin

% #include ../src/Algebra.sf haskell @merge
\begin{minted}{haskell}
let merge A B (f : ExpAlg A) (g : ExpAlg B) = {
  lit = \(x : Int). f.lit x ,, g.lit x,
  add = \(x : A & B). \(y : A & B). f.add x y ,, g.add x y
};
\end{minted}
% #end

This section shows that the System F plus intersection types are enough for
encoding extensible designs, and even improve on those designs. In particular,
System FI has two main advantages over existing languages:

\begin{itemize}
\item It supports dynamic composition of intersecting values.
\item It supports contravariant parameter types in the subtyping relation.
\end{itemize}

Various solutions have been proposed to deal with the extensibility problems and
many rely on heavyweight language features such as abstract methods and classes
in Java.

These two features can be used to improve existing designs of modular programs.

% Introduce the expression problem

The expression problem refers to the difficulty of adding a new operations and a
new data variant without changing or duplicating existing code in statically
typed functional languages.

There has been recently a lightweight solution to the expression problem that
takes advantage of covariant return types in Java. We show that FI is able to
solve the expression problem in the same spirit. The
A)

\subsection{Object Algebras}

Object algebra provides an alternative to \emph{algebraic data types} (ADT). For example, the
following Haskell definition of the type of simple expressions
\begin{minted}{haskell}
data Exp where
  Lit :: Int -> Exp
  Add :: Exp -> Exp -> Exp
\end{minted}
can be expressed by the \emph{interface} of an object algebra of simple expressions:
\begin{minted}{scala}
trait ExpAlg[E] {
  def lit(x: Int): E
  def add(e1: E, e2: E): E
}
\end{minted}
Similar to ADT, data constructors in object algebras are represented by functions such as
\lstinline{lit} and \lstinline{add} inside an interface \lstinline{ExpAlg}.
Different with ADT, the type of the expression itself is abtracted by a type
parameter \lstinline{E}.

which can be expressed similarly in \systemfi as:
\begin{minted}{haskell}
type ExpAlg E = {
  lit : Int -> E,
  add : E -> E -> E
}
\end{minted}

% Introduce Scala's intersection types

Scala supports intersection types via the \lstinline{with} keyword. The type
\lstinline{A with B} expresses the combined interface of \lstinline{A} and
\lstinline{B}. The idea is similar to
\begin{minted}{java}
interface AwithB extends A, B {}
\end{minted}
in Java.
\footnote{However, Java would require the \lstinline{A} and \lstinline{B} to be
  concrete types, whereas in Scala, there is no such restriction.}

The value level counterpart is functions of the type \lstinline
{A => B => A with B}.

Our type system is an fairely simple extension of System F; yet surprisingly, it
is able to solve the limitations of using object algebras in languages such as
Java and Scala. We will illustrate this point with an step-by-step of solving
the expression problem using \systemFI.

Oliveira noted that composition of object algebras can be cumbersome and
intersection types provides a solution to that problem.

We first define an interface that supports the evaluation operation:

% #include ../src/Algebra.sf haskell @base
\begin{minted}{haskell}
type IEval  = { eval : Int };
type ExpAlg E = { lit : Int -> E, add : E -> E -> E };
let evalAlg = {
  lit = \(x : Int). { eval = x },
  add = \(x : IEval). \(y : IEval). { eval = x.eval + y.eval }
};
\end{minted}
% #end

The interface is just a type synonym \lstinline{IEval}. In \systemFI, record
types are structural and hence any value that satisfies this interface is of
type \lstinline{IEval} or of a subtype of \lstinline{IEval}.

In the following, \lstinline{ExpAlg} is an object algebra interface of
expressions with literal and addition case. And \lstinline{evalAlg} is an object
algebra for evluation of those expressions, which has type \lstinline{ExpAlg Int}

% #include ../src/Algebra.sf haskell @variant
\begin{minted}{haskell}
type SubExpAlg E = (ExpAlg E) & { sub : E -> E -> E };
let subEvalAlg = evalAlg ,, { sub = \ (x : IEval). \ (y : IEval). { eval = x.eval - y.eval } };
\end{minted}
% #end

Next, we define an interface that supports pretty printing.

% #include ../src/Algebra.sf haskell @operation
\begin{minted}{haskell}
type IPrint = { print : String };
let printAlg = {
  lit = \(x : Int). { print = x.toString() },
  add = \(x : IPrint). \(y : IPrint). { print = x.print.concat(" + ").concat(y.print) },
  sub = \(x : IPrint). \(y : IPrint). { print = x.print.concat(" - ").concat(y.print) }
};
\end{minted}
% #end

Provided with the definitions above, we can then create values using the
appropriate algebras. For example:
defines two expressions.

The expressions are unusual in the sense that they are functions that take an
extra argument \lstinline{f}, the object algebras, and use the data constructors
provided by the object algebra (factory) \lstinline{f} such as \lstinline{lit},
\lstinline{add} and \lstinline{sub} to create values. Moreover, The algebras
themselves are abstracted over the allowed operations such as evaluation and
pretty printing by requiring the expression functions to take an extra argument
\lstinline{E}.

% #include ../src/Algebra.sf haskell @merge
\begin{minted}{haskell}
let merge A B (f : ExpAlg A) (g : ExpAlg B) = {
  lit = \(x : Int). f.lit x ,, g.lit x,
  add = \(x : A & B). \(y : A & B). f.add x y ,, g.add x y
};
\end{minted}
% #end

If we would like to have an expression that supports both evaluation and pretty
printing, we will need a mechanism to combine the evaluation and printing
algebras. Intersection types allows such composition: the \lstinline{merge}
function, which takes two expression algebras to create a combined algebra. It
does so by constructing a new expression algebra, a record whose each field is a
function that delegates the input to the two algebras taken.

% #include ../src/Algebra.sf haskell @usage
\begin{minted}{haskell}
let newAlg = merge IEval IPrint subEvalAlg printAlg in
(e1 (IEval & IPrint) newAlg).print
\end{minted}
% #end

\lstinline{e1} is a single object created that supports both evaluation and
printing, thus achieving full feature-oriented programming.

\subsection{From Algebras Back to Visitors}

The visitor pattern allows adding new operations to existing structures without
modifying those structures.

% #include ../src/Visitor.sf haskell
\begin{minted}{haskell}
type ExpAlg E = { lit : Int -> E, add : E -> E -> E };
type Exp = { accept : forall A. ExpAlg A -> A };

type LitAdd A = { lit : Int -> A, add : A -> A -> A };

let lit (n : Int) = {
  accept = /\A. \(f : LitAdd A). f.lit n
};

let add (e1 : Exp) (e2 : Exp) = {
  accept = /\A. \(f : LitAdd A). f.add (e1.accept A f) (e2.accept A f)
};

let evalAlg = {
  lit = \(x : Int). x,
  add = \(x : Int). \(y : Int). x + y
};
let e1 = add (lit 2) (lit 3);
-- e1.accept Int evalAlg

type SubExpAlg E = (ExpAlg E) & { sub : E -> E -> E };
type ExpExt = { accept : forall A. SubExpAlg A -> A };

type LitAddSub A = LitAdd A & { sub : A -> A -> A };

let sub (e1 : ExpExt) (e2 : ExpExt) =
  { accept = /\A. \(f : LitAddSub A).
               f.sub (e1.accept A f) (e2.accept A f) };

-- Contravariant param type, programmer-friendly usage
let e2 = sub (lit 2) (lit 3);

-- Note that Exp <: ExpExt
let f (x : ExpExt) = 1;
-- let g (x : Exp) = 1;
e2
\end{minted}
% #end

One big benefit of using the visitor pattern is that programmers is able to
write in the same way that would do in Haskell. For example,
\lstinline{e2 = sub (lit 2) (lit 3)}
defines an expression.

However, there is the extra task of defining an \lstinline{Exp} interface.

% \subsection{Yanlin}

% Mixin goes last

\subsection{Mixins}

\lstinputlisting{../src/Mixin.sf}

In Haskell, one is able to write programs in mixin style using records. However,
this approach has a serious drawback: it is not possible to refine the mixin by
adding more fields to the records. This means that the type of the family of the
mixins has to be determined upfront.

The figure defines a mini mixin library. The apostrophe in front of types
denotes call-by-name arguments similar to the \lstinline{=>} notation in the
Scala language.

\subsection{Composing Mixins and Object Algebras}

\section{Target Language}

The target language is System F extended with a base type Int. The syntax and
typing is completely standard. The types are function, universal quantification.

\subsection{Target Syntax}

\subsection{Target Typing}

\section{Source Language}

The semantics of the source-level language is not defined formally, instead by a
translation into the target language.

The most central construct of our language is ...


The source language, System FI, is identical to the source language described in
the previous section, except for the two additions: intersection types and
records. The formalization includes only single records and single record types as the multi-records can be desugared into the merge of multiple single records.

Dunfield has described a language that includes a ``top'' type but it does not appear in our language. Our work differs from Dunfield in that ...

Remark. The operational semantics of FI is not presented in this paper. However,

\subsection{Source Syntax}

\subsection{Source Subtyping}

\subsection{Source Typing}

\section{Elaboration Typing}

In order to give the reader an intuitive idea of how the elaboration works,
let's first imagine a manual translation.

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore $ \{ eval = 4, print = ``4'' \} $ becomes
$ \{ eval = 4 \} ,, \{ print = ``4'' \} $. Merges of two values are elaborated
into just a pair of them and single-field record literals lose their field
labels during the elaboration. Hence $ \{ eval = 4 \} ,, \{ print = ``4'' \} $
becomes $ (4, ``4'') $.

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). x.\_1 $ before being applied to $ add $. We adopt a
Scala-like syntax where $ .\_1 $ denotes the projection of a tuple on the first
element, and so on.

\framebox{$|\tau| = T$}

\[
\begin{array}{rcl}
  |\alpha|               & = & \alpha \\
  |\tau_1 \to \tau_2|    & = & |\tau_1| \to |\tau_2| \\
  |\forall \alpha. \tau| & = & \forall \alpha. |\tau| \\
  |t_1 \& t_2|           & = & \langle |\tau_1|, |\tau_2| \rangle \\
  |\{ l : \tau \}|       & = & |\tau|
\end{array}
\]

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $$
  then $$ |\Gamma| \vdash C : |\tau_1| \to |\tau_2| $$
\end{lemma}

In this section, we present a relatively lightweight type-directed elaboration
from FI to F. The elaboration consists of four sets of rules, which are
explained below:

\begin{itemize}

\item{\bf Coercion}

  The coercion judgment $ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $ extends
  the subtyping judgment with a coercion on the right hand side of
  $ \hookrightarrow $. A coercion, which is just an expression in the target
  language, is guaranteed to have type $ \tau_1 \to \tau_2 $, as proved by Lemma
  \ref{type-coerce}. It is read ``In the environment $ \Gamma $, $ \tau_1 $ is a
  subtype of $ \tau_2 $; and if any expression $ e $ has a type $ t_1 $ that is
  a subtype of the type of $ t_2 $, the elaborated $ e $, when applied to the
  corresponding coercion $ C $, has exactly type $ |t_2| $''. For example,
  $\Gamma \vdash Int \& Bool <: Bool \yields{fst} $, where $ fst $ is the
  projection of a tuple on the first element. The coercion judgment is only used
  in the \texttt{TrApp} case.

\item{\bf Elaboration}

  The elaboration judgment $ \Gamma \vdash e : \tau \yields{E} $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. It is also standard, except for the case of
  \texttt{TrApp}, in which a coercion from the inferred type of the argument to
  the expected type of the parameter is inserted before the argument; and the
  case of \texttt{TrRcdEim} and \texttt{TrRcdUpd}, where the ``get'' and ``put''
  rules will be used. The two set of rules are explained below.

\item{\bf ``get'' rules}

  The ``get'' judgment can be thought as producing a field accessor.

\item{\bf ``put'' rules}

  The ``put'' judgment can be thought as producing a field updater.

\end{itemize}

Type-Directed Translation to System F.
Main results: type-preservation + coherence.

\section{Implementation}

\subsection{Type Synonyms}

We extend the implementation of the type system extended with type synonyms and
lazy arguments.

\begin{lstlisting}
type T A1 A2 = ... in
\end{lstlisting}

\subsection{Optimization}
\section{Related Work}

\begin{itemize}

\item{\bf Elaborating simply-typed lambda calculus}

  Dunfield has introduced a type system with intersection polymorphism but no
  parametric polymorphism.

\end{itemize}

Nystrom et. al. OOPSLA 06

Applications:

- Object/Fold Algebras. How to support extensibility in an easier way.

See Datatypes a la Carte

- Mixins

- Lenses? Can intersection types help with lenses? Perhaps making the
types more natural and easy to understand/use?

- Embedded DSLs? Extensibility in DSLs? Composing multiple DSL interpretations?

http://www.cs.ox.ac.uk/jeremy.gibbons/publications/embedding.pdf

\section{Conclusion}

\acks

Acknowledgments, if needed.

\appendix

\section{Proofs}

\begin{proof}
By structural induction on the types and the corresponding inference rule. \\

\texttt{(SubVar)}

\texttt{(SubFun)}

\texttt{(SubForall)}

\texttt{(SubAnd1)}

\texttt{(SubAnd2)}

\texttt{(SubAnd3)}

\texttt{(SubRcd)}

\end{proof}

\begin{lemma} \label{type-get}
  If $$ \Gamma \vdash_{get} \tau ; l = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau_1| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Get-Base)} $ \Gamma \vdash_{get} \{ l : \tau \} ; l = \lambda (x : |\{ l : \tau \}|). x ; \tau $ \\

By the induction hypothesis
$$ |\Gamma| \vdash \lambda (x : |\{ l : \tau \}|). x : |\{ l : \tau \}| \to |\tau| $$

\texttt{(Get-Left)} \\
\texttt{(Get-Right)} \\

\end{proof}

\begin{lemma} \label{type-put}
  If $$ \Gamma \vdash_{put} \tau ; l ; E = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Put-Base)} \\
\texttt{(Put-Left)} \\
\texttt{(Put-Right)} \\
\end{proof}

\begin{lemma} \label{preserve-wf}
  If   $$ \Gamma \vdash \tau $$
  then $$ |\Gamma| \vdash |\tau| $$
\end{lemma}

\begin{proof}
Since $$ \Gamma \vdash \tau $$
It follows from \texttt{(FI-WF)} that
  $$ \ftv{\tau} \subseteq \ftv{\Gamma} $$
And hence
  $$ \ftv{|\tau|} \subseteq \ftv{|\Gamma|} $$
By \texttt{(F-WF)} we have
  $$ \Gamma \vdash \tau $$
\end{proof}

\begin{theorem}[Type preserving translation] \label{preserve-tr}
  If   $$ \Gamma \vdash e : \tau \yields{E} $$
  then $$ |\Gamma| \vdash E : \left| \tau \right| $$
\end{theorem}

\begin{proof}
By structural induction on the expression and the corresponding inference rule. \\

\texttt{(TrVar)} $ \Gamma \vdash x : \tau \yields{x} $ \\

It follows from \texttt{(TrVar)} that
  $$ (x : \tau) \in \Gamma $$
Based on the definition of $ |\cdot| $,
  $$ (x : |\tau|) \in |\Gamma| $$
Thus we have by \texttt{(F-Var)} that
  $$ |\Gamma| \vdash x : |\tau| $$

\texttt{(TrAbs)} $ \Gamma \vdash \lambda (x : \tau_1). e : \tau_1 \to \tau_2 \yields{\lambda x : |\tau_1|. E} $ \\

It follows from \texttt{(TrAbs)} that
  $$ \Gamma, x : \tau_1 \vdash e : \tau_2 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma|, x : |\tau_1| \vdash E : |\tau_2| $$
By \texttt{(TrAbs)} we also have
  $$ \Gamma \vdash \tau_1 $$
It follows from Lemma \ref{preserve-wf} that
  $$ |\Gamma| \vdash |\tau_1| $$
Hence by \texttt{(F-Abs)} and the definition of $|\cdot|$ we have
  $$ |\Gamma| \vdash \lambda x : |\tau_1|. E : |\tau_1 \to \tau_2| $$

\texttt{(TrApp)} $ \Gamma \vdash e_1 e_2 : \tau_2 \yields{E_1 (C E_2)} $ \\

From \texttt{(TrApp)} we have
  $$ \Gamma \vdash \tau_3 <: \tau_1 \yields{C} $$
Applying Lemma \ref{type-coerce} to the above we have
  $$ |\Gamma| \vdash C : |\tau_3| \to |\tau_1| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_1 : |\tau_1| \to |\tau_2| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_2 : |\tau_3| $$
Assembling those parts using \texttt{(F-App)} we come to
  $$ |\Gamma| \vdash E_1 (C E_2) : |\tau_2| $$
\end{proof}

\texttt{(TrTAbs)} $ \Gamma \vdash \Lambda \alpha. e : \forall \alpha. \tau \yields{\forall \alpha. E} $ \\

From \texttt{(TrTAbs)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
By the induction hypothesis we have
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by \texttt{(F-TAbs)} and the definition of $|\cdot|$
  $$ \Gamma \vdash \Lambda \alpha. E : |\forall \alpha. \tau| $$


\texttt{(TrTApp)} $ \Gamma \vdash e \; \tau  : [\alpha := \tau]\tau_1 \yields{E \; |\tau|} $ \\

From \texttt{(TrTApp)} we have
  $$ \Gamma \vdash e : \forall \alpha. \tau_1 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : \forall \alpha. |\tau_1| $$
Also from \texttt{(TrTApp)} and Lemma \ref{preserve-wf} we have
  $$ |\Gamma| \vdash |\tau| $$
Then by \texttt{(F-TApp)} that
  $$ |\Gamma| \vdash E \; |\tau| : [\alpha := |\tau| ]|\tau_1| $$
Therefore
  $$ |\Gamma| \vdash E \; |\tau| : | [\alpha := \tau ] | \tau_1 | | $$

% \texttt{(TrMerge)} $ \Gamma \vdash e_1 \merge e_2 : \tau_1 \& \tau_2 \yields{\langle E1, E2  \rangle}$ \\

From \texttt{(TrMerge)} and the induction hypothesis we have
  $$ |\Gamma| \vdash E_1 : |\tau_1| $$
and
  $$ |\Gamma| \vdash E_2 : |\tau_2| $$
Hence by \texttt{(F-Pair)}
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : \langle |\tau_1|, |\tau_2| \rangle $$
Hence by the definition of $|\cdot|$
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : |\tau_1 \& \tau_2| $$

\texttt{(TrRcdIntro)} $ \Gamma \vdash \{ l = e \} : \{ l : \tau \} \yields{E} $ \\

From \texttt{(TrRcdIntro)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by the definition of $|\cdot|$
  $$ |\Gamma| \vdash E : |\{ l : \tau \}| $$

\texttt{(TrRcdElim)} $ \Gamma \vdash e.l : \tau_1 \yields{C E} $ \\

From \texttt{(TrRcdElim)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdEim)}
  $$ \Gamma \vdash_{get} e ; l = C ; \tau_1 $$
Applying Lemma \ref{type-get} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau_1|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau_1| $$

% \texttt{(TrRcdUpd)} $ \Gamma \vdash \rcdupd{e}{l}{e_1} : \tau \yields{C E} $ \\

From \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash_{put} t ; l; E = C ; \tau_1 $$
Applying Lemma \ref{type-put} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau| $$


% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\bibliography{references}

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

Coppo, M., Dezani-Ciancaglini, M.: A new type-assignment for λ-terms. Archiv.
Math. Logik 19, 139–156 (1978)

\end{thebibliography}

%% #include ../src/Algebra.sf

%% #end

\end{document}
