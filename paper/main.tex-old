\documentclass[preprint]{sigplanconf}

% Use packages immediately following the \documentclass command
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fixltx2e}
\usepackage{listings}
\usepackage{mdframed}
\usepackage{xcolor}

\newmdtheoremenv{theorem}{Theorem}
\newmdtheoremenv{lemma}{Lemma}

\definecolor{github}{HTML}{4183C4}

% Define macros immediately before the \begin{document} command
\input{macros/type_systems.tex}
\input{macros/systemfi.tex}

\newcommand{\FI}{{\bf FI} }
\newcommand{\F}{{\bf F} }

\newcommand{\FIend}{{\bf FI}}
\newcommand{\Fend}{{\bf F}}

% "define" code highlights for Java and Scala
\lstdefinelanguage{JavaScala}{
  morekeywords={public,int,interface,implements,default,
    abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\lstset{ %
language=JavaScala,                % choose the language of the code
columns=flexible,
lineskip=-1pt,
basicstyle=\ttfamily\small,       % the size of the fonts that are used for the code
numbers=none,                   % where to put the line-numbers
numberstyle=\ttfamily\tiny,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1 each line will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
morekeywords={var},
%  frame=single,                   % adds a frame around the code
tabsize=2,                  % sets default tabsize to 2 spaces
captionpos=none,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting; also try caption instead of title
escapeinside={(*}{*)},          % if you want to add a comment within your code
keywordstyle=\ttfamily\bfseries,
% commentstyle=\color{Gray},
% stringstyle=\color{Green}
}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{\FI}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle

\begin{abstract}
\end{abstract}

\keywords
intersecion types, inheritance

\section{Introduction}

-- Compare Scala:
-- merge[A,B] = new A with B

-- type IEval  = { eval :  Int }
-- type IPrint = { print : String }

-- F[\_]

We present a polymorphic calculus containing intersection types and records, and show
how this language can be used to solve various common tasks in functional
programming in a nicer way.

Intersection types provides a power mechanism for functional programming, in
particular for extensibility and allowing new forms of composition.

Prototype-based programming is one of the two major styles of object-oriented
programming, the other being class-based programming which is featured in
languages such as Java and C\#. It has gained increasing popularity recently
with the prominence of JavaScript in web applications. Prototype-based
programming supports highly dynamic behaviors at run time that are not possible
with traditional class-based programming. However, despite its flexibility,
prototype-based programming is often criticized over concerns of correctness and
safety. Furthermore, almost all prototype-based systems rely on the fact that
the language is dynamically typed and interpreted.

This paper introduces System $F_{IR}$

\section{A Primer on FI}

% State novelty

While elaborating intersection types is not a new idea, this paper is the first
that presents a type system that incorporates both parametric polymorphism and
intersection polymorphism and explores the usefulness of such a type system in
practice.

\subsection{Intersection types}

\FI is an thin extension on top of \F that is elaborated into \Fend, a variant
of System F. System F, or polymorphic lambda calculus lays the foundation of
functional programming languages such as Haskell.

% Describe intersection types, encoding records with Intersecion types

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% What is an intersection type?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The central addition to the type system of \F in \FI is intersection types. What
is an intersection type? One classic view is from set-theoretic interpretation
of types: $ A \& B $ stands for the intersection of the set of values of $ A $
and $ B $. The other view, adopted in this paper, regards types as a kind of
interface: a value of type $ A \& B $ satisfies both of the interfaces of $ A $
and $ B $. For example, $ { eval : Int } $ is the interface that supports
evaluation to integers, while $ { eval : Int } \& { print : String } $ supports
both evaluation and pretty printing. Those interfaces are akin to interfaces in
Java or traits in Scala. But one key difference is that they are unnamed in \FIend.

% \lstinputlisting[linerange=-]{} % APPLY:linerange=MIXIN_LIB

In addition to introduction of record literals, FI support two more operations
on records: record elimination and record update.

This section informally presents \FI programs and the elaboration.

\subsection{Encoding records with intersection types}

% A basic example

As our first example, the following illustrates the key features of the type
system of \FI as well as the elaboration of \FI expressions into \F ones.

\lstinputlisting[linerange=2-6]{../src/Basics.sf} % APPLY:linerange=BASICS_ADD

$ e1 $ and $ e2 $ are two expressions that support both evaluation and pretty
printing and each has type $ \{ eval : Int, print : String \} $. $ add $ takes
two expressions and computes their sum. Note that in order to compute a sum,
$ add $ only requires that the two expressions support evaluation and hence the
type of the parameter $ \{ eval : Int \} $. As a result, the type of $ e1 $ and
$ e2 $ are not exactly the same with that of the parameters of $ add $. However,
under a structural type system, this program should typecheck anyway because the
arguments being passed has more information than required. In other words,
$ \{ eval : Int, print : String \} $ is a subtype of $ \{ eval : Int \} $.

How is this subtyping relation derived? In \FIend, multi-field record types are
excluded from the type system because $ \{ eval : Int, print : String \} $ can
be encoded as $ \{ eval : Int \} \& \{ print : String \} $. And by one of
subtyping rules derives that $ \{ eval : Int \} \& \{ print : String \} $ is a
subtype of $ \{ eval : Int \} $.

This example is elaborated into the following in \Fend.

\lstinputlisting[linerange=2-6]{../src/BasicsElab.sf} % APPLY:linerange=BASICSELAB_ADD

In order to give the reader an intuitive idea of how the elaboration works,
let's first imagine a manual translation.

First, multi-field record literals are desugared into merges of single-field
record literals. Therefore $ \{ eval = 4, print = ``4'' \} $ becomes
$ \{ eval = 4 \} ,, \{ print = ``4'' \} $. Merges of two values are elaborated
into just a pair of them and single-field record literals lose their field
labels during the elaboration. Hence $ \{ eval = 4 \} ,, \{ print = ``4'' \} $
becomes $ (4, ``4'') $.

Finally, $ e1 $ and $ e2 $ are both coerced by a projection function
$ \\(x:(Int,String)). x.\_1 $ before being applied to $ add $. We adopt a
Scala-like syntax where $ .\_1 $ denotes the projection of a tuple on the first
element, and so on.


\subsection{Using FI for modularity}

% Introduce the expression problem

The expression problem refers to the difficulty of adding a new operations and a
new data variant without changing or duplicating existing code in statically
typed functional languages.

There has been recently a lightweight solution to the expression problem that
takes advantage of covariant return types in Java. We show that FI is able to
solve the expression problem in the same spirit. The
A)

% OA

Object algebras allow one to modularly extend the base

We first define the interface capable of evaluation $ IEVAL $.

\lstinputlisting[linerange=10-14]{../src/Algebra.sf} % APPLY:linerange=EXPALG
\lstinputlisting[linerange=22-28]{../src/Algebra.sf} % APPLY:linerange=SUBEXPALG
\lstinputlisting[linerange=44-44]{../src/Algebra.sf} % APPLY:linerange=NEWALG
\lstinputlisting[linerange=37-40]{../src/Algebra.sf} % APPLY:linerange=MERGE

The merge operator $ ,, $ is used in the definition of $ merge $.

\lstinputlisting[linerange=48-48]{../src/Algebra.sf} % APPLY:linerange=PRINT

% Mixin

In Haskell, one is able to write programs in mixin style using records. However,
this approach has a serious drawback: it is not possible to refine the mixin by
adding more fields to the records. This means that the type of the family of the
mixins has to be determined upfront.



Combining mixins and OAs


% Modular visitor components




There should be a section informally describing the language (System FI) through
various examples. Intersection types provide a general mechanism for ad-hoc
polymorphism.

While elaboration intersection types has been

In summary, the contributions of this paper are:

\begin{itemize}

\item{elaboration typing rules which given a source expression with intersection
    types, typecheck and translate it into an ordinary F term. Prove a type
    preservation result: if a term $e$ has type $\tau$ in the source language,
    then the translated term $|e|$ is well-typed and has type $|\tau|$ in the
    target language.}

\item{present an algorithm for detecting incoherence which can be very important
    in practice.}

\item{explores the connection between intersection types and object algebra by
    showing various examples of encoding object algebra with intersection
    types.}

\end{itemize}


Mention properties informally via examples:

%f : A & A -> A
%f x = x

Typeclasses

Intersecion types in Scala


Examples in this paper are written with a Haskell-like syntax. Consider a
\texttt{show} function that converts either integers or booleans to strings. In
FI it can be given the type:

\begin{verbatim}
show :: (Int -> String) & (Bool -> String)
\end{verbatim}

And can be defined as:

\begin{verbatim}
show = showInt ,, showBool
\end{verbatim}

where \texttt{showString} and \texttt{showBool} are ordinary monomorphic
functions.

The merge construct in the original function is elaborated into a pair in the
target language:

\begin{verbatim}
show = (showInt, showBool)
\end{verbatim}

In the target language where there is no intersection types, the application of
the integer \texttt{1} to this function does not typecheck. However, we may
rescue this situtation by inserting a coercion that extracts the first item out
of this pair.

Thus \texttt{show 1} in FI corresponds to \texttt{(fst show) 1} in F.

\subsection{Algebras}

\subsection{Lenses}

\subsection{Embedded DSLs}

\section{System F}

The target language is System F extended with a base type Int. The syntax and
typing is completely standard. The types are function, universal quantification.

\section{System FI}

The source language, System FI, is identical to the source language described in
the previous section, except for the two additions: intersection types and
records. The formalization includes only single records and single record types as the multi-records can be desugared into the merge of multiple single records.

Dunfield has described a language that includes a ``top'' type but it does not appear in our language.

Remark. The operational semantics of FI is not presented in this paper. However,

\section{Type-Directed Translation to System F}

In this section, we present a relatively lightweight type-directed elaboration
from FI to F. The elaboration consists of four sets of rules, which are
explained below:

\begin{itemize}

\item{\bf Coercion}

  The coercion judgment $ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $ extends
  the subtyping judgment with a coercion on the right hand side of
  $ \hookrightarrow $. A coercion, which is just an expression in the target
  language, is guaranteed to have type $ \tau_1 \to \tau_2 $, as proved by Lemma
  \ref{type-coerce}. It is read ``In the environment $ \Gamma $, $ \tau_1 $ is a
  subtype of $ \tau_2 $; and if any expression $ e $ has a type $ t_1 $ that is
  a subtype of the type of $ t_2 $, the elaborated $ e $, when applied to the
  corresponding coercion $ C $, has exactly type $ |t_2| $''. For example,
  $\Gamma \vdash Int \& Bool <: Bool \yields{fst} $, where $ fst $ is the
  projection of a tuple on the first element. The coercion judgment is only used
  in the \texttt{TrApp} case.

\item{\bf Elaboration}

  The elaboration judgment $ \Gamma \vdash e : \tau \yields{E} $ extends the
  typing judgment with an elaborated expression on the right hand side of
  $ \hookrightarrow $. It is also standard, except for the case of
  \texttt{TrApp}, in which a coercion from the inferred type of the argument to
  the expected type of the parameter is inserted before the argument; and the
  case of \texttt{TrRcdEim} and \texttt{TrRcdUpd}, where the ``get'' and ``put''
  rules will be used. The two set of rules are explained below.

\item{\bf ``get'' rules}

  The ``get'' judgment can be thought as producing a field accessor.

\item{\bf ``put'' rules}

  The ``put'' judgment can be thought as producing a field updater.

\end{itemize}

Type-Directed Translation to System F.
Main results: type-preservation + coherence.

\section{Implementation}

We extend the implementation of the type system extended with type synonyms and
lazy arguments.

\begin{lstlisting}
type T A1 A2 = ... in
\end{lstlisting}

\section{Case Study?}

\section{Properties}

\section{Case Studies}

\section{Related work}

\begin{itemize}

\item{\bf Elaborating simply-typed lambda calculus}

  Dunfield has introduced a type system with intersection polymorphism but no
  parametric polymorphism.

\end{itemize}

Nystrom et. al. OOPSLA 06


Applications:

- Object/Fold Algebras. How to support extensibility in an easier way.

See Datatypes a la Carte

- Mixins

- Lenses? Can intersection types help with lenses? Perhaps making the
types more natural and easy to understand/use?

- Embedded DSLs? Extensibility in DSLs? Composing multiple DSL interpretations?

http://www.cs.ox.ac.uk/jeremy.gibbons/publications/embedding.pdf

\framebox{$|\tau| = T$}

\[
\begin{array}{rcl}
  |\alpha|               & = & \alpha \\
  |\tau_1 \to \tau_2|    & = & |\tau_1| \to |\tau_2| \\
  |\forall \alpha. \tau| & = & \forall \alpha. |\tau| \\
  |t_1 \& t_2|           & = & \langle |\tau_1|, |\tau_2| \rangle \\
  |\{ l : \tau \}|       & = & |\tau|
\end{array}
\]

\begin{lemma} \label{type-coerce}
  If $$ \Gamma \vdash \tau_1 <: \tau_2 \yields{C} $$
  then $$ |\Gamma| \vdash C : |\tau_1| \to |\tau_2| $$
\end{lemma}

\begin{proof}
By structural induction on the types and the corresponding inference rule. \\

\texttt{(SubVar)}

\texttt{(SubFun)}

\texttt{(SubForall)}

\texttt{(SubAnd1)}

\texttt{(SubAnd2)}

\texttt{(SubAnd3)}

\texttt{(SubRcd)}

\end{proof}

\begin{lemma} \label{type-get}
  If $$ \Gamma \vdash_{get} \tau ; l = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau_1| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Get-Base)} $ \Gamma \vdash_{get} \{ l : \tau \} ; l = \lambda (x : |\{ l : \tau \}|). x ; \tau $ \\

By the induction hypothesis
$$ |\Gamma| \vdash \lambda (x : |\{ l : \tau \}|). x : |\{ l : \tau \}| \to |\tau| $$

\texttt{(Get-Left)} \\
\texttt{(Get-Right)} \\

\end{proof}

\begin{lemma} \label{type-put}
  If $$ \Gamma \vdash_{put} \tau ; l ; E = C ; \tau_1 $$
  then $$ |\Gamma| \vdash C : |\tau| \to |\tau| $$
\end{lemma}

\begin{proof}
By structural induction on the type and the corresponding inference rule. \\

\texttt{(Put-Base)} \\
\texttt{(Put-Left)} \\
\texttt{(Put-Right)} \\
\end{proof}

\begin{lemma} \label{preserve-wf}
  If   $$ \Gamma \vdash \tau $$
  then $$ |\Gamma| \vdash |\tau| $$
\end{lemma}

\begin{proof}
Since $$ \Gamma \vdash \tau $$
It follows from \texttt{(FI-WF)} that
  $$ \ftv{\tau} \subseteq \ftv{\Gamma} $$
And hence
  $$ \ftv{|\tau|} \subseteq \ftv{|\Gamma|} $$
By \texttt{(F-WF)} we have
  $$ \Gamma \vdash \tau $$
\end{proof}

\begin{theorem}[Type preserving translation] \label{preserve-tr}
  If   $$ \Gamma \vdash e : \tau \yields{E} $$
  then $$ |\Gamma| \vdash E : \left| \tau \right| $$
\end{theorem}

\begin{proof}
By structural induction on the expression and the corresponding inference rule. \\

\texttt{(TrVar)} $ \Gamma \vdash x : \tau \yields{x} $ \\

It follows from \texttt{(TrVar)} that
  $$ (x : \tau) \in \Gamma $$
Based on the definition of $ |\cdot| $,
  $$ (x : |\tau|) \in |\Gamma| $$
Thus we have by \texttt{(F-Var)} that
  $$ |\Gamma| \vdash x : |\tau| $$

\texttt{(TrAbs)} $ \Gamma \vdash \lambda (x : \tau_1). e : \tau_1 \to \tau_2 \yields{\lambda x : |\tau_1|. E} $ \\

It follows from \texttt{(TrAbs)} that
  $$ \Gamma, x : \tau_1 \vdash e : \tau_2 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma|, x : |\tau_1| \vdash E : |\tau_2| $$
By \texttt{(TrAbs)} we also have
  $$ \Gamma \vdash \tau_1 $$
It follows from Lemma \ref{preserve-wf} that
  $$ |\Gamma| \vdash |\tau_1| $$
Hence by \texttt{(F-Abs)} and the definition of $|\cdot|$ we have
  $$ |\Gamma| \vdash \lambda x : |\tau_1|. E : |\tau_1 \to \tau_2| $$

\texttt{(TrApp)} $ \Gamma \vdash e_1 e_2 : \tau_2 \yields{E_1 (C E_2)} $ \\

From \texttt{(TrApp)} we have
  $$ \Gamma \vdash \tau_3 <: \tau_1 \yields{C} $$
Applying Lemma \ref{type-coerce} to the above we have
  $$ |\Gamma| \vdash C : |\tau_3| \to |\tau_1| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_1 : |\tau_1| \to |\tau_2| $$
Also from \texttt{(TrApp)} and the induction hypothesis
  $$ |\Gamma| \vdash E_2 : |\tau_3| $$
Assembling those parts using \texttt{(F-App)} we come to
  $$ |\Gamma| \vdash E_1 (C E_2) : |\tau_2| $$
\end{proof}

\texttt{(TrTAbs)} $ \Gamma \vdash \Lambda \alpha. e : \forall \alpha. \tau \yields{\forall \alpha. E} $ \\

From \texttt{(TrTAbs)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
By the induction hypothesis we have
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by \texttt{(F-TAbs)} and the definition of $|\cdot|$
  $$ \Gamma \vdash \Lambda \alpha. E : |\forall \alpha. \tau| $$


\texttt{(TrTApp)} $ \Gamma \vdash e \; \tau  : [\alpha := \tau]\tau_1 \yields{E \; |\tau|} $ \\

From \texttt{(TrTApp)} we have
  $$ \Gamma \vdash e : \forall \alpha. \tau_1 \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : \forall \alpha. |\tau_1| $$
Also from \texttt{(TrTApp)} and Lemma \ref{preserve-wf} we have
  $$ |\Gamma| \vdash |\tau| $$
Then by \texttt{(F-TApp)} that
  $$ |\Gamma| \vdash E \; |\tau| : [\alpha := |\tau| ]|\tau_1| $$
Therefore
  $$ |\Gamma| \vdash E \; |\tau| : | [\alpha := \tau ] | \tau_1 | | $$

\texttt{(TrMerge)} $ \Gamma \vdash e_1 \merge e_2 : \tau_1 \& \tau_2 \yields{\langle E1, E2  \rangle}$ \\

From \texttt{(TrMerge)} and the induction hypothesis we have
  $$ |\Gamma| \vdash E_1 : |\tau_1| $$
and
  $$ |\Gamma| \vdash E_2 : |\tau_2| $$
Hence by \texttt{(F-Pair)}
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : \langle |\tau_1|, |\tau_2| \rangle $$
Hence by the definition of $|\cdot|$
  $$ |\Gamma| \vdash \langle E_1, E_2 \rangle : |\tau_1 \& \tau_2| $$

\texttt{(TrRcdIntro)} $ \Gamma \vdash \{ l = e \} : \{ l : \tau \} \yields{E} $ \\

From \texttt{(TrRcdIntro)} we have
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Thus by the definition of $|\cdot|$
  $$ |\Gamma| \vdash E : |\{ l : \tau \}| $$

\texttt{(TrRcdElim)} $ \Gamma \vdash e.l : \tau_1 \yields{C E} $ \\

From \texttt{(TrRcdElim)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdEim)}
  $$ \Gamma \vdash_{get} e ; l = C ; \tau_1 $$
Applying Lemma \ref{type-get} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau_1|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau_1| $$

\texttt{(TrRcdUpd)} $ \Gamma \vdash \rcdupd{e}{l}{e_1} : \tau \yields{C E} $ \\

From \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash e : \tau \yields{E} $$
And by the induction hypothesis that
  $$ |\Gamma| \vdash E : |\tau| $$
Also from \texttt{(TrRcdUpd)}
  $$ \Gamma \vdash_{put} t ; l; E = C ; \tau_1 $$
Applying Lemma \ref{type-put} to the above we have
  $$ |\Gamma| \vdash C : |\tau| \to |\tau|  $$
Hence by \texttt{(F-App)} we have
  $$ |\Gamma| \vdash C E : |\tau| $$


\appendix
\section{Proofs}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\bibliography{references}

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}



\end{document}
