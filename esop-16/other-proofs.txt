Definition "G ⊢ A * B".
    forall s in Inst_G(A) and
           t in Inst_G(B)
    there does not exist a type u such that
    s <: u and t <: u.


    A2 <: A1  B1 <: B2
    -------------------------- (Sub-Forall)
    ∀(α * A1). B1 <: ∀(α * A2). B2

    (contravariant)


    Γ, α * A1&A2 ⊢ B1 * B2
    --------------------------------- (Dis-Forall)
    Γ ⊢ ∀(α * A1). B1 * ∀(α * A2). B2

    if Γ ⊢ A *i B then Γ ⊢ A * B

    2. Proof sketch of algorithm == specification for forall types:

    (=>)

    Suppose the contrary. Then by specification, either:

    C = forall a * A3 . B3:

      ∀α * A1. B1 <: ∀α * A3. B3
      ∀α * A2. B2 <: ∀α * A3. B3

      Then by inversion,
      A3 <: A1 and B1 <: B3
      A3 <: A2 and B2 <: B3

    Then by specification, B1 and B2 are not disjoint in the empty env.
    B1 and B2 are not disjoint in Γ, α * A1&A2
    by i.h., "Γ, α * A1&A2 ⊢ B1 * B2" => Γ, α * A1&A2 ⊢ B1 * B2
    Contradiction.

    or,

    C=C1&C2

      ∀α * A1. B1 <: C1&C2 <: ... <: ∀α * A3. B3
      ∀α * A2. B2 <: C1&C2 <: ... <: ∀α * A3. B3


    (<=)

    Int, Int => Int
    Int&Bool, Bool => Int&Bool

    If ∀α * A1. B1 and ∀α * A2. B2 are disjoint in Γ ,
    it must be the case that B1 and B2 are disjoint.

        (Otherwise, let C be the type such that B1 <: C and B2 <: C.
        then ∀α * (A1&A2). C is a common supertype of ∀α * A1. B1 and ∀α * A2. B2. Contradiction.)

    It follows by the i.h.

    Int <: Int&Int
