* no top type; or refinement types (reviewers 1&2)

As mentioned in the conclusion, having a top type requires a 
minor modification to the specification: 

A*B=not exists C. A<:C and B<:C and C/=top 

Top would make the metatheory more messy, but would not add
fundamental difficulties. Our intention in the paper was to present a
simple system that already illustrates the key issues of disjointness.

Admittedly, dealing with refinement types such as even_integer and
odd_integer seems more challenging.  We have thought about refinement
types and it was unclear how to deal with them.

#reviewer 1

"In most OO languages, _all_ types have a common supertype...I'd
imagine that in practice most types would still share some common
supertypes...Hence I don't believe that the "solution" suggested in
Sec. 8 will work very well."

There is some confusion here. It is true that the merge operator does
not allow merging objects with common supertypes.  **However** this
does not mean that our system (or extensions in Section 8) prevents
"multiple-inheritance" of two objects sharing a common supertype. See
end of section 3.4, where an example (counter) of multiple inheritance with
a common supertype:

{incr: () -> Counter}

is presented. In this case (following the trait model!) we need to
choose the implementation of incr for the resulting object composed
with the merge operator.

#reviewer 2

"Do the authors know if this approach works for recursively defined objects?"

Defining LinkedList in the traditional OO style requires recursive
types. Extending the notion of disjointness to recursive types needs
further research.

We can define LinkedList in a style similar to case classes in
Scala. For example, the following LinkedList supports construction and
membership test.

type LinkedList={member:Int -> Bool}

trait Nil {self:LinkedList->
  member(y:Int)=False
}

trait Cons(x:Int, next: LinkedList) {self:LinkedList->
  member(y:Int)= x==y||next.member(y)
}

#reviewer 3

*lambda&

"the solution seems much more powerful than simply forbidding
non-overlapping intersections"

No it is not! lambda& rejects intersections that are accepted 
in our system:

{Int -> Char, Int -> Bool}

This example violates the well-formdeness conditions (see Section 3.2)
of lambda&.  So clearly the conditions imposed by lambda& (even for
the special case of functions) does not subsume disjoint
intersections.

"The problem of coherence with intersection types was studied in the 90's
by Castagna in the language lambda-&"

No it wasn't! Castagna work on lambda& studied the overloading problem
for functions and focused only on the “merge” (in our sense) of
functions. Our work considers a system with arbitrary
intersections/merges and tries to present a coherent subset of
that. Although lambda& can encode records, it is unclear how to encode
arbitrary merges. One failed attempt to encode arbitrary merges in
lambda& is to consider a record with multiple labels of the same
trivial name. For example, encoding 1,,’c’ as

{Res -> 1, Res ->‘c’}

(where Res is an atomic type). However this is also rejected in
lambda&, since it violates the well-formedness conditions.

* Traits: 

Our point is not to argue that traits can be encoded with records; rather we
show that, in the same way that Dunfield calculus can be viewed as a
foundational calculus that can encode various language features (including
records); our calculus can be viewed as a foundational calculus that
generalizes records with non-overlapping fields. As such it can model
constructs such as traits, that rely on such non-overlapping conditions.
Dunfield's calculus alone would not be able to encode traits (it misses the
checks for conflicts). So, if the goal is to use a system with intersection
types and a merge operator to model traits, some additional work is needed:
that's what our system does.
