\section{The \name Calculus}
\label{sec:fi}

\bruno{It may be worthwhile to discuss the issue with function
  application. I think the way we deal with function application is
  not as convenient, but it doesn't remove expressive power: we can
  always extract, by hand, the right function before using it in a
  function application. However this way we don't have ambiguity
  problems that arize from having a more ``clever'' function
  application.}
\bruno{Don't forget to make sure that we formalize the same thing here
and in Coq!}

This section presents the syntax, subtyping, typing, as well as the (incoherent)
semantics of \name: a calculus with intersection types and a merge operator.
This calculus is similar to Dunfield's calculus~\cite{dunfield2014elaborating}.
The minor differences are that the coercions are target language terms and that
a term of intersection type may be used as a function directly.\bruno{George,
you need to explain this to me. I am not entirely sure that I understand what
you mean.} Section~\ref{sec:disjoint} introduces \name, which shows the
necessary changes for supporting disjoint intersection types and ensuring
coherence.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} shows the syntax. The differences to
$\lambda$-calculus, highlighted in gray, are intersection types $A \inter B$ at
the type-level and the ``merges'' $e_1 \mergeop e_2$ at the term level.

\begin{figure}[t]
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B, C & \Coloneqq & \code{Int} & \\
        &         & \mid      & A \to B    & \\
        &         & \mid      & \highlight{$A \inter B$}  & \\

        \\
        \text{Terms}
        & e & \Coloneqq & i            & \\
        &   & \mid & x                 & \\
        &   & \mid & \lamty x A e      & \\
        &   & \mid & \app {e_1} {e_2}  & \\
        &   & \mid & \highlight{$e_1 \mergeop e_2$}  & \\

        \\
        \text{Contexts}
        & \Gamma & \Coloneqq & \cdot
                   \mid \Gamma, x \oftype A  & \\
      \end{array}
    \end{array}
  \]

  \caption{\name syntax.}
  \label{fig:fi-syntax}
\end{figure}\bruno{Figures should be on top!}

\paragraph{Types.} Metavariables $A$, $B$ range over types. Types include
function types $A \to B$. $A \inter B$ denotes the intersection of types $A$ and
$B$. We also include integer types $\code{Int}$.

\paragraph{Terms.} Metavariables $e$ range over terms.  Terms include standard
constructs: variables $x$; abstraction of terms over variables of a given type
$\lamty x A e$; and application of terms $e_1$ to terms $e_2$, written $\app
{e_1} {e_2}$. The expression $e_1 \mergeop e_2$ is the \emph{merge} of two terms
$e_1$ and $e_2$. Merges of terms correspond to intersections of types $A \inter
B$. In addition, we also include integer literals $i$.

\paragraph{Contexts.} Typing contexts $ \Gamma $ track bound variables $x$ with their type $A$.

% We use $\subst {A} \alpha {B}$
% to denote the capture-avoiding substitution of $A$ for $\alpha$ inside $B$ and
% $\ftv \cdot$ for sets of free type variables.

In order to focus on the key features that make this language interesting, we do
not include other forms such as type constants and fixpoints here. However they
can be included in the formalization in standard ways and we are using them in
discussions and examples. The formalization of nonessential features such as
records and record operations can be found in the appendix.

% \paragraph{Discussion.} A natural question the reader might ask is that why we
% have excluded union types from the language. The answer is we found that
% intersection types alone are enough support extensible designs.

\subsection{Subtyping}

% In some calculi, the subtyping relation is external to the language: those
% calculi are indifferent to how the subtyping relation is defined. In \name, we
% take a syntactic approach, that is, subtyping is due to the syntax of types.
% However, this approach does not preclude integrating other forms of subtyping
% into our system. One is ``primitive'' subtyping relations such as natural
% numbers being a subtype of integers. The other is nominal subtyping relations
% that are explicitly declared by the programmer.

\begin{figure}
  \begin{mathpar}
    \formsub \\
    \rulesubvar \and \rulesubfun \and \rulesubinter \and
    \rulesubinterl \and \rulesubinterr
  \end{mathpar}

  \begin{mathpar}
    \formwf \\
    \rulewffun \and \rulewfinter
  \end{mathpar}

  \begin{mathpar}
    \formt \\
    \ruletlam \and \ruletapp \and
    \ruletmerge
  \end{mathpar}

  \caption{The type system of \name.}
  \label{fig:fi-type}
\end{figure}

% Intersection types introduce natural subtyping relations among types. For
% example, $ \code{Int} \inter \tybool $ should be a subtype of $ \code{Int} $, since the former
% can be viewed as either $ \code{Int} $ or $ \tybool $. To summarize, the subtyping rules
% are standard except for three points listed below:
% \begin{enumerate}
% \item $ A_1 \inter A_2 $ is a subtype of $ A_3 $, if \emph{either} $ A_1 $ or
%   $ A_2 $ are subtypes of $ A_3 $,

% \item $ A_1 $ is a subtype of $ A_2 \inter A_3 $, if $ A_1 $ is a subtype of
%   both $ A_2 $ and $ A_3 $.

% \item $ \recordType {l_1} {A_1} $ is a subtype of $ \recordType {l_2} {A_2} $, if
%   $ l_1 $ and $ l_2 $ are identical and $ A_1 $ is a subtype of $ A_2 $.
% \end{enumerate}
% The first point is captured by two rules $ \reflabelsubinterl $ and
% $ \reflabelsubinterr $, whereas the second point by $ \reflabelsubinter $.
% Note that the last point means that record types are covariant in the type of
% the fields.

The subtyping rules of the form $A \subtype B$ are shown in the top part of
Figure~\ref{fig:fi-type}. At the moment, the reader is advised to ignore the
gray-shaded part in the rules, which will be explained later. The rule
\reflabel{\labelsubfun} says that a function is contravariant in its parameter
type and covariant in its return type. The three rules dealing with
intersection types are just what one would expect when interpreting types as
sets. Under this interpretation, for example, the rule \reflabel{\labelsubinter}
says that if $A_1$ is both the subset of $A_2$ and the subset of $A_3$, then
$A_1$ is also the subset of the intersection of $A_2$ and $A_3$.

\paragraph{Metatheory.} As other sane subtyping relations, we can show that
subtyping defined by $\subtype$ is also reflexive and transitive.

\begin{lemma}[Subtyping is reflexive] \label{lemma:sub-refl}
  For all type $ A $, $ A \subtype A $.
\end{lemma}

\begin{lemma}[Subtyping is transitive] \label{lemma:sub-trans}
  If $ A_1 \subtype A_2 $ and $ A_2 \subtype A_3 $,
  then $ A_1 \subtype A_3 $.
\end{lemma}

For the corresponding mechanized proofs in Coq, we refer the reader to the
supplementary materials submitted with the paper.

\subsection{Typing}

The well-formedness rules are shown in the middle part of
Figure~\ref{fig:fi-type}. In addition to the standard rules,
\reflabel{\labelwfinter} is also not surprising. The typing rules are shown in
the bottom part of the figure. Again, the reader is advised to ignore the
gray-shaded part here, as these parts will be explained later. The typing
judgment is of the form: \[ \jtype \Gamma e A \] It reads: ``in the typing
context $\Gamma$, the term $e$ is of type $A$''. The standard rules are those
for variables \reflabel{\labeltvar} and lambda abstractions
\reflabel{\labeltlam}. \reflabel{\labeltmerge} means that a merge $e_1 \mergeop
e_2$, is assigned an intersection type composed of the resulting types of $e_1$
and $e_2$.

\subsection{Semantics}

We define the dynamic semantics of the call-by-value \name by means of
a type-directed translation to an extension of $\lambda$-calculus with pairs.
%The type-directed translation is also shown in
%Figure~\ref{}, where the resulting System F terms are highlighted in
%gray.


\paragraph{Target Language.}
The syntax and typing of our target language is unsurprising. The syntax of the
target language is shown in Figure~\ref{fig:f-syntax}. The highlighted part
shows its difference with $\lambda$-calculus. The typing rules can be found
in the appendix.

% \bruno{Does the target language does need unit? Any rules generating units? I
% don't think so, so it can be dropped.}

\paragraph{Key Idea of the Translation.}
This translation turns merges into usual pairs, similar to Dunfield's
elaboration approach~\cite{dunfield2014elaborating}.
For example, \[ 1 \mergeop \code{"one"} \] becomes \pair 1
{\code{"one"}}. In usage, the pair will be coerced according to type
information. For example, consider the function application: \[ \app {(\lamty x
\tystring x)} {(1 \mergeop \code{"one"})} \] This expression will be translated to \[ \app
{(\lamty x \tystring x)} {(\app {(\lamty x {\pair \code{Int} \tystring} {\proj 2 x})}
{\pair 1 {\code{"one"}}})} \] The coercion in this case is $(\lamty x {\pair
\code{Int} \tystring} {\proj 2 x})$. It extracts the second item from the pair, since
the function expects a $\tystring$ but the translated argument is of type $\pair
\code{Int} \tystring$.


\begin{figure}[h]
  \[
    \begin{array}{llrl}
      \text{Types}    & T & \Coloneqq & {T_1} \to {T_2} \\
                      &   & \mid      & \highlight {$ \pair {T_1} {T_2} $} \\
      \text{Terms}    & E & \Coloneqq & x \\
                      &   & \mid      & \lamty x T E \\
                      &   & \mid      & \app {E_1} {E_2} \\
                      &   & \mid      & \highlight {$ \pair {E_1} {E_2} $} \\
                      &   & \mid      & \highlight {$ \proj k E $} \quad k \in \{ 1, 2 \} \\
      \text{Contexts} & G & \Coloneqq & \cdot \mid G, x \oftype T \\
    \end{array}
  \]
  \caption{Target language syntax.}
  \label{fig:f-syntax}
\end{figure}

\paragraph{Type and Context Translation.}

Figure~\ref{fig:type-and-context-translation} defines the type translation
function $\im \cdot$ from \name types $A$ to target language types $T$. The
notation $\im \cdot$ is also overloaded for context translation from \name
contexts $\Gamma$ to target language contexts $G$.

\begin{figure}[h]
  \framebox{$\im A = T$}

  \begin{align*}
    \im {A_1 \to A_2}    &= \im {A_1} \to \im {A_2} \\
    \im {A_1 \inter A_2} &= \pair {\im {A_1}} {\im {A_2}} \\
  \end{align*}

  \framebox{$\im \Gamma = G$}

  \begin{align*}
    \im \cdot                      &= \cdot \\
    \im {\Gamma, \alpha \oftype A} &= \im \Gamma, \alpha \oftype \im A
  \end{align*}

  \caption{Type and context translation.}
  \label{fig:type-and-context-translation}
\end{figure}

% The rules given in this section are identical with those in
% Section~\ref{sec:fi}, except for the light blue part. The translation consists
% of four sets of rules, which are explained below:

\paragraph{Coercive subtyping.}

The judgment
\[
A_1 \subtype A_2 \yields E
\]
extends the subtyping judgment in Figure~\ref{fig:fi-type} with a coercion
on the right hand side of $ \yields {} $. A coercion $ E $ is just an term
in the target language and is ensured to have type
$ \im {A_1} \to \im {A_2} $ (by Lemma~\ref{lemma:sub}). For example,
\[
\code{Int} \inter \tybool \subtype \tybool \yields {\lamty x {\im {\code{Int} \inter \tybool}} {\proj 2 x}}
\]
generates a coercion function with type: $\code{Int} \inter \tybool \to \tybool$.

In \reflabel{\labelsubfun}, we elaborate the subtyping of
parameter and return types by $\eta$-expanding $f$ to $\lamty x {\im {A_3}}
{\app f x}$, applying $E_1$ to the argument and $E_2$ to the result. Rules
\reflabel{\labelsubinterl}, \reflabel{\labelsubinterr}, and
\reflabel{\labelsubinter} elaborate intersection types.
\reflabel{\labelsubinter} uses both coercions to form a pair. Rules
\reflabel{\labelsubinterl} and \reflabel{\labelsubinterr} reuse the coercion
from the premises and create new ones that cater to the changes of the argument
type in the conclusions. Note that the two rules are overlapping and
hence a program can be elaborated differently, depending on which rule
is used. Finally, all rules produce type-correct coercions:

%But in the implementation one usually applies the rules sequentially with
%pattern matching, essentially defining a deterministic order of lookup.

% if we know $A_1$ is a subtype of $A_3$ and $C$ is a coercion from $A_1$
% to $A_3$, then we can conclude that $A_1 \inter A_2$ is also a subtype
% of $A_3$ and the new coercion is a function that takes a value $ x $ of type
% $A_1\inter A_2$, project $x$ on the first item, and apply $ C $ to it.

\begin{restatable}[Subtyping rules produce type-correct coercions]{lemma}{lemmasub}
  \label{lemma:sub}
  If $ A_1 \subtype A_2 \yields E $, then $ \jtype \cdot E {\im {A_1} \to \im {A_2}} $.
\end{restatable}

\begin{proof}
  By a straightforward induction on the derivation\footnote{The proofs of major lemmata and theorems can be found in the appendix.\bruno{where??}}.
\end{proof}

\paragraph{The translation judgment.} The translation judgment $\jtype \Gamma e
A \yields E$ extends the typing judgment with an elaborated term on the right
hand side of $\yields {}$. The translation ensures that $E$ has type $\im A$. In
\name, one may pass more information to a function than what is required; but
not in ordinary $\lambda$-calculus. To account for this difference, in \reflabel{\labeltapp}, the
coercion $E$ from the subtyping relation is applied to the argument.
\reflabel{\labeltmerge} straighforwardly translates merges into pairs.

The type-directed translation is type-safe. This property is captured
by the following two theorems.

\begin{restatable}[Type preservation]{theorem}{typepreservation}
  \label{theorem:type-preservation}

  If $ \jtype \Gamma e A \yields E $,
  then $ \jtype {\im \Gamma} E {\im A} $.
\end{restatable}

\begin{proof}
  (Sketch) By structural induction on the term and the corresponding
  inference rule.
\end{proof}

\begin{theorem}[Type safety]
  If $e$ is a well-typed \name term, then $e$ evaluates to some $\lambda$-calculus
  value $v$.
\end{theorem}

\begin{proof}
  Since we define the dynamic semantics of \name in terms of the composition of
  the type-directed translation and the dynamic semantics of $\lambda$-calculus, type safety follows immediately.
\end{proof}
