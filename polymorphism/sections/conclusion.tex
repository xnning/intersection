\section{Conclusion and Future Work}
\label{sec:conclusion}


This paper described \name: a System $F$-based language that combines
intersection types, parametric polymorphism and a merge operator.
The language is proved to be type-safe and coherent.
To ensure coherence the type system accepts only
disjoint intersections. To provide flexibility in the presence of parametric polymorphism,
universal quantification is extended with
disjointness constraints. We believe that disjoint intersection types
and disjoint quantification are intuitive, and at the same time
expressive.

%We implemented the core functionalities of the \namedis as part of a JVM-based
%compiler. Based on the type system of \namedis, we have built an ML-like
%source language compiler that offers interoperability with Java (such as object
%creation and method calls). The source language is loosely based on the more
%general System $F_{\omega}$ and supports a
%number of other features, including records, mutually recursive
%\code{let} bindings, type aliases, algebraic data types, pattern matching, and
%first-class modules that are encoded using \code{letrec} and records.

For the future, we intend to improve our source language
and show the power of disjoint intersection types and disjoint
quantification in large case studies.
We are also interested in extending our work to systems with union types and/or 
a $\bot$ type. 
\joao{simplify this paragraph?}
However, introducing the latter is not compatible with our disjointness rule
\reflabel{\labeldisvar} and well-formedness of contexts.
Had we introduced it in \name, we could derive non-sensical statements as in 
$\jdis \Gamma \alpha \alpha$, for some variable $\alpha$, under some well-formed context $\Gamma$.
In \name, such statement is not derivable since we would have to use \reflabel{\labeldisvar} with the 
type $A$ as a sub-type of $\alpha$, i.e. an (n-ary) intersection containing $\alpha$.
Well-formedness of environments guarantees that this will never happen, since $\alpha$ is not in
scope of itself. 
However, by introducing $\bot$ we may now construct such derivation, as $A$ can now be $\bot$: a valid
sub-type of $\alpha$ which does not contain $\alpha$.
This suggests that adding $\bot$ is not as straightforward as initially perceived.
%In fact, had \name included a $\bot$ type, then introducing any \emph{bottom-like} type 
%(i.e. $\bot \inter A$, for any type $A$) can lead to this undesired behaviour.
Since introducing it is not strictly necessary to the system's formalization; adds 
substantial complexity in our system; and its practical application is not clear, we left this
as an open problem for future work. 

\begin{comment}
Some immediate topics for
further improvement of the results in this paper are discussed next.

\paragraph{Union types.}

If a type system ever contains union types (the counterpart of intersection
types), with the following standard subtyping rules,
\begin{mathpar}
  \inferrule* [right=Sub\_Union\_1]
    { }
    {A \subtype A \union B}

  \inferrule* [right=Sub\_Union\_2]
    { }
    {B \subtype A \union B}
\end{mathpar}
then no two types $A$ and $B$ can ever be disjoint, since there always exists
the type $A \union B$, which is their common supertype. So it is reasonable to
conjecture that such system cannot be coherent.
\bruno{I wouldn't say this is a motivation: it sounds like we caould
  not support union types, when I think this is not true. For example
we could say something like: there does not exist an \emph{atomic} C ...}


\paragraph{Implementation.}

We implemented the core functionalities of the \namedis as part of a JVM-based
compiler. Based on the type system of \namedis, we built an ML-like
source language compiler that offers interoperability with Java (such as object
creation and method calls). The source language is loosely based on the more
general System $F_{\omega}$ and supports a
number of other features, including records, mutually recursive
\code{let} bindings, type aliases, algebraic data types, pattern matching, and
first-class modules that are encoded using \code{letrec} and records.

Relevant to this paper are the three phases in the compiler, which
collectively turn source programs into System $F$:

\begin{enumerate}
\item A \emph{typechecking} phase that checks the usage of \namedis features and
  other source language features against an abstract syntax tree that follows
  the source syntax.

\item A \emph{desugaring} phase that translates well-typed source terms into
  \namedis terms. Source-level features such as multi-field records, type aliases
  are removed at this phase. The resulting program is just an \namedis term
  extended with some other constructs necessary for code generation.

\item A \emph{translation} phase that turns well-typed \namedis terms into System
  $F$ ones.
\end{enumerate}

Phase 3 is what we have formalized in this paper.


\paragraph{Reduce the number of coercions.}

Our translation inserts a coercion (many of them are identity functions)
whenever subtyping occurs during a function application, which could mean
notable run-time overhead. In the current implementation, we introduced a
partial evaluator with three simple rewriting rules to eliminate the redundant
identity functions as another compiler phase after the translation. In another
version of our implementation, partial evaluation is weaved into the process of
translation so that the unwanted identity functions are not introduced during
the translation. Besides, since the order of the two types in a binary
intersection does not matter, we may normalize them to avoid unnecessary
coercions.
\end{comment}
