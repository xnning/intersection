\section{The \name Calculus}
\label{sec:fi}

This section presents the syntax, subtyping, and typing of \name: 
a calculus with intersection types, parametric polymorphism and a merge operator. 
This calculus is an extension of \oldname, which in its turn is heavily based
on Dunfield's calculus~\cite{dunfield2014elaborating}. 
We will show that \name is type-safe and it preserves the coherent semantics of
\oldname.
%Section~\ref{sec:disjoint} introduces \namedis, which shows the necessary changes
%for supporting disjoint intersection types and disjoint
%quantification and ensuring coherence.
Section~\ref{sec:disjoint} introduces the necessary changes to the disjointness
concept in order to retain coherence.

All the meta-theory has been mechanized in Coq, which we refer to the supplementary
materials submitted with the paper.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} shows the syntax of \name. 
The differences to \oldname are highlighted in gray.
%are intersection types $A \inter B$ at the
%type-level and the ``merges'' $e_1 \mergeop e_2$ at the term level.

%TODO merge this figure with figure 5 (text too)
\begin{figure}
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B & \Coloneqq & \top                        & \\
        &      & \mid & \tyint                           & \\
        &      & \mid & A \to B                          & \\
        &      & \mid & A \inter B                       & \\
        &      & \mid & \highlight{$\alpha$}             & \\
        &      & \mid & \highlight{$\fordis \alpha A B$} & \\

        \\
        \text{Terms}
        & e & \Coloneqq & ()                           & \\
        &   & \mid & i                                 & \\
        &   & \mid & x                                 & \\
        &   & \mid & \lamty x A e                      & \\
        &   & \mid & \app {e_1} {e_2}                  & \\
        &   & \mid & e_1 \mergeop e_2                  & \\
        &   & \mid & \highlight{$\blamdis \alpha A e$} & \\
        &   & \mid & \highlight{$\tapp e A$}           & \\

        \\
        \text{Contexts}
        & \Gamma & \Coloneqq & \cdot
                   \mid \Gamma, \alpha \highlight{\disjoint $A$}
                   \mid \Gamma, x \oftype A  & \\
      \end{array}
    \end{array}
  \]

  \caption{\name syntax.}
  \label{fig:fi-syntax}
\end{figure}

\paragraph{Types.} 
Metavariables $A$, $B$ range over types. 
Types include all constructs in \oldname: a top type $\top$; 
the type of integers $\tyint$;
function types $A \to B$; and intersection types $A \inter B$.
This calculus is extended with two standard constructs in System $F$: 
type variables $\alpha$ and type abstraction $\for \alpha A$. 
The latter includes an extra disjointness constraint tied to the type 
variable $\alpha$.

\paragraph{Terms.} 
Metavariables $e$ range over terms.  
Terms include all constructs in \oldname: a unit type $\unit$; an integer literal $i$;
a variable $x$, abstraction of terms over variables of
a given type $\lamty x A e$; application of terms $e_1$ to terms $e_2$, written
$\app {e_1} {e_2}$; and the \emph{merge} of terms $e_1$ and $e_2 $ denoted as 
$e1 \merge e2$, corresponding to intersections of types $A \inter B$.
This calculus is extended with two standard constructs in System $F$:
abstraction of type variables over terms $\blam \alpha e$; and
and application of terms to types $\tapp e A$. 
The former includes an extra disjointness constraint tied to the type 
variable $\alpha$.
%If one regards $e_1$ and $e_2$ as objects, their merge will respond to
%every method that one or both of them have.

\paragraph{Contexts.} Typing contexts $ \Gamma $ track bound type variables
$\alpha$ with disjointness cosntraint $A$; and variables $x$ with their type $A$. 
We use $\subst {A} \alpha {B}$
to denote the capture-avoiding substitution of $A$ for $\alpha$ inside $B$ and
$\ftv \cdot$ for sets of free type variables. % TODO are we using this anywhere?

In order to focus on the key features that make this language interesting, we do
not include other forms such as type constants and fixpoints here. 
However they can be included in the formalization in
standard ways and we are using them in discussions and examples. %TODO are we?

% \paragraph{Discussion.} A natural question the reader might ask is that why we
% have excluded union types from the language. The answer is we found that
% intersection types alone are enough support extensible designs.

\subsection{Subtyping}

% In some calculi, the subtyping relation is external to the language: those
% calculi are indifferent to how the subtyping relation is defined. In \name, we
% take a syntactic approach, that is, subtyping is due to the syntax of types.
% However, this approach does not preclude integrating other forms of subtyping
% into our system. One is ``primitive'' subtyping relations such as natural
% numbers being a subtype of integers. The other is nominal subtyping relations
% that are explicitly declared by the programmer.


%\begin{figure}
%  \begin{mathpar}
%    \formsub \\
%    \rulesubvar \and \rulesubfun \and \rulesubforall \and \rulesubinter \and
%    \rulesubinterl \and \rulesubinterr
%  \end{mathpar}
%
%  \begin{mathpar}
%    \formwf \\
%    \rulewfvar \and \rulewffun \and \rulewfforall \and \rulewfinter
%  \end{mathpar}
%
%  \begin{mathpar}
%    \formt \\
%    \ruletvar \and \ruletlam \and \ruletapp \and \ruletblam \and \rulettapp \and
%    \ruletmerge
%  \end{mathpar}
%
%  \caption{The type system of \name.}
%  \label{fig:fi-type}
%\end{figure}

\begin{figure}
  \begin{mathpar}
    \framebox{$\jatomic A$} \\

    \inferrule*{}{\jatomic {A \to B}}

    \inferrule*{}{\jatomic \alpha}

    \inferrule*{}{\jatomic {\fordis \alpha B A}}
  \end{mathpar}

  \begin{mathpar}
    \formsub \\ \rulesubtop \and \rulesubint \and \rulesubvar \and \rulesubfun \and
    \rulesubinter \and  \rulesubinterlcoerce \and \rulesubinterrcoerce \and
    \rulesubforallext 
  \end{mathpar}

  \caption{Subtyping rules of \name.}
  \label{fig:fi-subtype}
\end{figure}


% Intersection types introduce natural subtyping relations among types. For
% example, $ \tyint \inter \tybool $ should be a subtype of $ \tyint $, since the former
% can be viewed as either $ \tyint $ or $ \tybool $. To summarize, the subtyping rules
% are standard except for three points listed below:
% \begin{enumerate}
% \item $ A_1 \inter A_2 $ is a subtype of $ A_3 $, if \emph{either} $ A_1 $ or
%   $ A_2 $ are subtypes of $ A_3 $,

% \item $ A_1 $ is a subtype of $ A_2 \inter A_3 $, if $ A_1 $ is a subtype of
%   both $ A_2 $ and $ A_3 $.

% \item $ \recordType {l_1} {A_1} $ is a subtype of $ \recordType {l_2} {A_2} $, if
%   $ l_1 $ and $ l_2 $ are identical and $ A_1 $ is a subtype of $ A_2 $.
% \end{enumerate}
% The first point is captured by two rules $ \reflabelsubinterl $ and
% $ \reflabelsubinterr $, whereas the second point by $ \reflabelsubinter $.
% Note that the last point means that record types are covariant in the type of
% the fields.

The subtyping rules of the form $A \subtype B$ are shown in 
Figure~\ref{fig:fi-subtype}. 
At the moment, the reader is advised to ignore the
gray-shaded part in the rules, which will be explained later. 
The first three rules are rather straightforward: \reflabel{\labelsubtop}
says that every type is a subtype of $\top$; \reflabel{\labelsubint} and 
\reflabel{\labelsubvar} define subtyping as a reflexive relation on integers and
type variables.
The rule \reflabel{\labelsubfun} says that a function is contravariant in 
its parameter type and covariant in its return type. 
The three rules dealing with intersection types are just what one would expect 
when interpreting types as sets. 
Under this interpretation, for example, the rule \reflabel{\labelsubinter}
says that if $A_1$ is both the subset of $A_2$ and the subset of $A_3$, then
$A_1$ is also the subset of the intersection of $A_2$ and $A_3$.
The ordinary hypothesis are necessary to ensure coherence, as explained in ....
We will come back to this in the next section.
Finally, in \reflabel{\labelsubforall} a universal quantifier ($\forall$) 
is covariant in its body, and contravariant in its disjointness constraints.
As with the subtyping relation defined in ..., we can show that subtyping
defined by $\subtype$ is also reflexive and transitive.

%TODO example showing contravariance in disjointness constraints goes here or in the overview section?

%\paragraph{Metatheory.} As other standard subtyping relations, we can show that
%subtyping defined by $\subtype$ is also reflexive and transitive.
%
%\begin{lemma}[Subtyping is reflexive] \label{lemma:sub-refl}
%  For all type $ A $, $ A \subtype A $.
%\end{lemma}
%
%\begin{lemma}[Subtyping is transitive] \label{lemma:sub-trans}
%  If $ A_1 \subtype A_2 $ and $ A_2 \subtype A_3 $,
%  then $ A_1 \subtype A_3 $.
%\end{lemma}

\subsection{Typing}

\begin{figure}
  \begin{mathpar}
    \formwf \\ \rulewftop \and \rulewfint \and \rulewfvardis \and \rulewffun \and 
    \rulewfforalldis \and \rulewfinterdis
  \end{mathpar}

%  \begin{mathpar}
%    \formt \\ \ruletvar \and \ruletlam \and \ruletapp \and
%    \ruletblam \and \rulettapp \and \ruletmergedis 
%  \end{mathpar}

  \begin{mathpar}
    \formbi \\ \brulettop \and \bruletint \and \bruletvar \and \bruletapp \and
    \brulettappdis \and \bruletmergedis \and \bruletann 
  \end{mathpar}

  \begin{mathpar}
    \formbc \\ \bruletlam \and  \bruletblamdis \and \bruletsub
  \end{mathpar}

  \caption{Type system of \name.}
  \label{fig:fi-type}
\end{figure}


The well-formedness rules are shown in the top part of
Figure~\ref{fig:fi-type}. 
In addition to the original rules, \reflabel{\labelwfforall} is not surprising. 
Note how we ensure the well-formedness of the constraint. 
%TODO couldn't we drop this constraint?
The typing rules are shown in the bottom part of the figure. 
Again, the reader is advised to ignore the
gray-shaded part here, as these parts will be explained later. 
The typing judgements are of the form: $\jcheck \Gamma e A$ and  
$\jinfer \Gamma e A$.
They read: ``in the typing context $\Gamma$, the term $e$ can be checked to
type $A$' or inferred to type $A$, respectively.' 
The rules that are ported from \oldname are the
check rules for $\top$ \reflabel{\labelttop}, integers \reflabel{\labeltint}, 
variables \reflabel{\labeltvar},  application \reflabel{\labeltapp}, merge operator  
\reflabel{\labeltmerge}, annotations \reflabel{\labeltann}; and infer rules
for lambda abstractions \reflabel{\labeltlam}, and the subsumption rule 
\reflabel{\labeltsub}.
The new rules, inspired on the standard System-$F$, are the check rule for
type application \reflabel{\labelttapp}, and the infer rule for type abstraction
\reflabel{\labeltblam}.
The former is no different from the standard rule for type application while
the latter has an extra hypothesis ensuring that the type to be instantiated is
compatible (i.e. disjoint) with the constraint associated with the abstracted 
variable.
This is extremely important, as it will retain the desired coherence of our 
type-system.
For the ease of discussion, also in \reflabel{\labeltblam}, we require the 
type variable introduced by the quantifier to be fresh. 
For programs with type variable shadowing, this requirement can be met 
straighforwardly by variable renaming.
%TODO add some discussion why


