\section{The \name Calculus}
\label{sec:fi}

This section presents the syntax, subtyping, and typing of \name: 
a calculus with intersection types, parametric polymorphism, records and a merge operator. 
This calculus is an extension of \oldname and Dunfield's
calculus~\cite{dunfield2014elaborating}, which are simply typed
calculus with intersection types and a merge operator.
%The novelty of \name is the support of coherence in the presence of
%polymorphism. As discussed in Section~\ref{overview} retaining
%coherence, while having an expressive form of polymorphism is non-trvial.
%Section~\ref{sec:disjoint} introduces \namedis, which shows the necessary changes
%for supporting disjoint intersection types and disjoint
%quantification and ensuring coherence.
Section~\ref{sec:disjoint} introduces the necessary changes to the
definition of disjointness in order to retain coherence.

All the meta-theory has been mechanized in Coq, which is available in
the supplementary materials submitted with the paper.

\subsection{Syntax}

Figure~\ref{fig:fi-syntax} shows the syntax of \name. 
The differences to \oldname are highlighted in gray.
%are intersection types $A \inter B$ at the
%type-level and the ``merges'' $e_1 \mergeop e_2$ at the term level.

%TODO merge this figure with figure 5 (text too)
\begin{figure}[t]\bruno{too much space waisted in having one construct
  per line}
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B & \Coloneqq & \top                        & \\
        &      & \mid & \tyint                           & \\
        &      & \mid & A \to B                          & \\
        &      & \mid & A \inter B                       & \\
        &      & \mid & \highlight{$\alpha$}             & \\
        &      & \mid & \highlight{$\fordis \alpha A B$} & \\
        &      & \mid & \highlight{$\recordType l A$}    & \\

        \\
        \text{Terms}
        & e & \Coloneqq & ()                           & \\
        &   & \mid & i                                 & \\
        &   & \mid & x                                 & \\
        &   & \mid & \lamty x A e                      & \\
        &   & \mid & \app {e_1} {e_2}                  & \\
        &   & \mid & e_1 \mergeop e_2                  & \\
        &   & \mid & \highlight{$\blamdis \alpha A e$} & \\
        &   & \mid & \highlight{$\tapp e A$}           & \\
        &   & \mid & \highlight{$\recordCon l e$}      & \\
        &   & \mid & \highlight{$\recordProj e l$}     & \\

        \\
        \text{Contexts}
        & \Gamma & \Coloneqq & \cdot
                   \mid \Gamma, \highlight{$\alpha \disjoint A$}
                   \mid \Gamma, x \oftype A  & \\
      \end{array}
    \end{array}
  \]

  \caption{\name syntax.}
  \label{fig:fi-syntax}
\end{figure}

\paragraph{Types.} 
Metavariables $A$, $B$ range over types. 
Types include all constructs in \oldname: a top type $\top$; 
the type of integers $\tyint$;
function types $A \to B$; and intersection types $A \inter B$.
Types are extended with two standard constructs of System $F$: 
type variables $\alpha$ and type abstraction $\fordis \alpha A B$. 
The latter lifts the System $F$'s quantification into \emph{disjoint quantification}:
it includes an extra disjointness constraint tied to a type variable $\alpha$.
Finally, the syntax for the singleton record at type level consists of a label $l$ and
an associated type $A$.

\paragraph{Terms.} 
Metavariables $e$ range over terms.  
Terms include all constructs in \oldname: a unit type $\unit$; an integer literal $i$;
a variable $x$, abstraction of terms over variables of
a given type $\lamty x A e$; application of terms $e_1$ to terms $e_2$, written
$\app {e_1} {e_2}$; and the \emph{merge} of terms $e_1$ and $e_2 $ denoted as 
$e1 \mergeop e2$, corresponding to intersections of types $A \inter B$.
Terms are extended with two standard constructs in System $F$:
abstraction of type variables over terms $\blamdis \alpha A e$; and
and application of terms to types $\tapp e A$. 
The former also includes an extra disjointness constraint tied to the type 
variable $\alpha$, due to disjoint quantification.
%If one regards $e_1$ and $e_2$ as objects, their merge will respond to
%every method that one or both of them have.
The syntax for the singleton record at term level consists of a label $l$ and
an associated term $e$.
Finally, the accessor for a label $l$ in term $e$ is denoted as $\recordProj e l$.

\paragraph{Contexts.} Typing contexts $ \Gamma $ track bound type variables
$\alpha$ with disjointness constraints $A$; and variables $x$ with their type $A$. 
We use $\subst {A} \alpha {B}$
to denote the capture-avoiding substitution of $A$ for $\alpha$ inside $B$ and
$\ftv \cdot$ for sets of free type variables. % TODO are we using this anywhere?

In order to focus on the key features that make this language interesting, we do
not include other forms such as type constants and fixpoints here. 
However they can be included in the formalization in
standard ways and we are using them in discussions and examples. %TODO are we?

% \paragraph{Discussion.} A natural question the reader might ask is that why we
% have excluded union types from the language. The answer is we found that
% intersection types alone are enough support extensible designs.

\subsection{Subtyping}

% In some calculi, the subtyping relation is external to the language: those
% calculi are indifferent to how the subtyping relation is defined. In \name, we
% take a syntactic approach, that is, subtyping is due to the syntax of types.
% However, this approach does not preclude integrating other forms of subtyping
% into our system. One is ``primitive'' subtyping relations such as natural
% numbers being a subtype of integers. The other is nominal subtyping relations
% that are explicitly declared by the programmer.


%\begin{figure}
%  \begin{mathpar}
%    \formsub \\
%    \rulesubvar \and \rulesubfun \and \rulesubforall \and \rulesubinter \and
%    \rulesubinterl \and \rulesubinterr
%  \end{mathpar}
%
%  \begin{mathpar}
%    \formwf \\
%    \rulewfvar \and \rulewffun \and \rulewfforall \and \rulewfinter
%  \end{mathpar}
%
%  \begin{mathpar}
%    \formt \\
%    \ruletvar \and \ruletlam \and \ruletapp \and \ruletblam \and \rulettapp \and
%    \ruletmerge
%  \end{mathpar}
%
%  \caption{The type system of \name.}
%  \label{fig:fi-type}
%\end{figure}

\begin{figure}[t]\bruno{Space can be better used. SRec and SAlpha can be side-by-side.}
  \begin{mathpar}
    \framebox{$\jatomic A$} \\

    \inferrule*{}{\jatomic {A \to B}}

    \inferrule*{}{\jatomic \alpha}

    \inferrule*{}{\jatomic {\fordis \alpha B A}}

    \inferrule*{}{\jatomic {\recordType l A}}
  \end{mathpar}

  \begin{mathpar}
    \formsub \\ \rulesubtop \and \rulesubint \and \rulesubvar \and \rulesubfun \and
    \rulesubinter \and  \rulesubinterlcoerce \and \rulesubinterrcoerce \and
    \rulesubforallext \and \rulesubrec
  \end{mathpar}

  \caption{Subtyping rules of \name.}
  \label{fig:fi-subtype}
\end{figure}\bruno{Be consistent with the names for the various
  variables used. In S$\forall$, you are using $E$ and $E_{d}$, which is
  not consistent. Just use $E_1$ and $E_2$}


% Intersection types introduce natural subtyping relations among types. For
% example, $ \tyint \inter \tybool $ should be a subtype of $ \tyint $, since the former
% can be viewed as either $ \tyint $ or $ \tybool $. To summarize, the subtyping rules
% are standard except for three points listed below:
% \begin{enumerate}
% \item $ A_1 \inter A_2 $ is a subtype of $ A_3 $, if \emph{either} $ A_1 $ or
%   $ A_2 $ are subtypes of $ A_3 $,

% \item $ A_1 $ is a subtype of $ A_2 \inter A_3 $, if $ A_1 $ is a subtype of
%   both $ A_2 $ and $ A_3 $.

% \item $ \recordType {l_1} {A_1} $ is a subtype of $ \recordType {l_2} {A_2} $, if
%   $ l_1 $ and $ l_2 $ are identical and $ A_1 $ is a subtype of $ A_2 $.
% \end{enumerate}
% The first point is captured by two rules $ \reflabelsubinterl $ and
% $ \reflabelsubinterr $, whereas the second point by $ \reflabelsubinter $.
% Note that the last point means that record types are covariant in the type of
% the fields.

The subtyping rules of the form $A \subtype B$ are shown in 
Figure~\ref{fig:fi-subtype}. 
At the moment, the reader is advised to ignore the
gray-shaded part in the rules, which will be explained later. 
The first three rules are rather straightforward: \reflabel{\labelsubtop}
says that every type is a subtype of $\top$; \reflabel{\labelsubint} and 
\reflabel{\labelsubvar} define subtyping as a reflexive relation on integers and
type variables.
The rule \reflabel{\labelsubfun} says that a function is contravariant in 
its parameter type and covariant in its return type. 
The three rules dealing with intersection types are just what one would expect 
when interpreting types as sets. 
Under this interpretation, for example, the rule \reflabel{\labelsubinter}
says that if $A_1$ is both the subset of $A_2$ and the subset of $A_3$, then
$A_1$ is also the subset of the intersection of $A_2$ and $A_3$.
The $ordinary$ conditions are necessary to ensure coherence~\cite{icfppaper}.
We will come back to this in the next section.

In \reflabel{\labelsubforall} a universal quantifier ($\forall$) 
is covariant in its body, and contravariant in its disjointness constraints.
Finally, \reflabel{\labelsubrec} says records are covariant within their fields' types.
Subtyping is reflexive and transitive.\bruno{State as lemmas here,
  since this is new.}

%TODO example showing contravariance in disjointness constraints goes here or in the overview section?

%\paragraph{Metatheory.} As other standard subtyping relations, we can show that
%subtyping defined by $\subtype$ is also reflexive and transitive.
%
%\begin{lemma}[Subtyping is reflexive] \label{lemma:sub-refl}
%  For all type $ A $, $ A \subtype A $.
%\end{lemma}
%
%\begin{lemma}[Subtyping is transitive] \label{lemma:sub-trans}
%  If $ A_1 \subtype A_2 $ and $ A_2 \subtype A_3 $,
%  then $ A_1 \subtype A_3 $.
%\end{lemma}

\subsection{Typing}\bruno{The TBLam is in chekc mode, why?}

\begin{figure}[t]
  \begin{mathpar}
    \formwf \\ \rulewftop \and \rulewfint \and \rulewfvardis \and \rulewffun \and 
    \rulewfforalldis \and \rulewfinterdis \and \rulewfrec
  \end{mathpar}

%  \begin{mathpar}
%    \formt \\ \ruletvar \and \ruletlam \and \ruletapp \and
%    \ruletblam \and \rulettapp \and \ruletmergedis 
%  \end{mathpar}

  \begin{mathpar}
    \formbi \\ \brulettop \and \bruletint \and \bruletvar \and \bruletann \and 
    \bruletapp \and \brulettappdis \and \bruletmergedis \and \bruletrec \and 
    \bruletprojr 
  \end{mathpar}

  \begin{mathpar}
    \formbc \\ \bruletlam \and  \bruletblamdis \and \bruletsub
  \end{mathpar}

  \caption{Type system of \name.}
  \label{fig:fi-type}
\end{figure}

\paragraph{Well-formedness}
The well-formedness rules are shown in the top part of Figure~\ref{fig:fi-type}. 
The new rules are \reflabel{\labelwfvar} and
\reflabel{\labelwfforall}. 
Their definition is quite straightforward, but note how we ensure the well-formedness 
of the constraint in the latter. 

\paragraph{Disjoint quantification.} A disjoint quantification is introduced by
the big lambda $\blamdis \alpha A e$ and eliminated by the usual type application 
$\tapp e A$. 
The constraint is added to the context with this rule. 
During a type application, the type system makes sure that the type argument
satisfies the disjointness constraint.
We will explain next the rules that compose the type-system.


\paragraph{Typing rules}\bruno{Mention bi-directional type-checking here.}
%TODO couldn't we drop this constraint?
The typing rules are shown in the bottom part of the figure. 
Again, the reader is advised to ignore the
gray-shaded part here, as these parts will be explained later. 
The typing judgements are of the form: $\jcheck \Gamma e A$ and  
$\jinfer \Gamma e A$.
They read: ``in the typing context $\Gamma$, the term $e$ can be checked to
type $A$' or inferred to type $A$, respectively.' 
The rules that are ported from \oldname are the
check rules for $\top$ \reflabel{\labelttop}, integers \reflabel{\labeltint}, 
variables \reflabel{\labeltvar},  application \reflabel{\labeltapp}, merge operator  
\reflabel{\labeltmerge}, annotations \reflabel{\labeltann}; and infer rules
for lambda abstractions \reflabel{\labeltlam}, and the subsumption rule 
\reflabel{\labeltsub}.
The new rules, inspired on the standard System $F$, are the check rule for
type application \reflabel{\labelttapp}, and the infer rule for type abstraction
\reflabel{\labeltblam}.
The former is no different from the standard rule for type application while
the latter has an extra hypothesis ensuring that the type to be instantiated is
compatible (i.e. disjoint) with the constraint associated with the abstracted variable.
This is extremely important, as it will retain the desired coherence of our 
type-system.
For the ease of discussion, also in \reflabel{\labeltblam}, we require the 
type variable introduced by the quantifier to be fresh. 
For programs with type variable shadowing, this requirement can be met 
straighforwardly by variable renaming.
%TODO add some discussion why
Finally, $\reflabel{\labeltrec}$ and $\reflabel{\labeltprojr}$ deal with record types.
The former infers a type for a record with label $l$ if it can infer a type for the
inner expression; the latter says if one can infer a record type $\recordType l A$ 
from an expression $e$, then it is safe to access the field $l$, and infering type $A$.

