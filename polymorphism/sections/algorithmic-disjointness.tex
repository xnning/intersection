\section{Disjointness} \label{sec:alg-dis}

Section~\ref{sec:fi} presented a type system with disjoint
intersection types and disjoint quantification that we will prove to be
both type-safe and coherent. 
However, before we can prove such properties, it is necessary to introduce our
new version of disjointness, considering polymorphism and disjointness quantificaton.
%In constrast with \oldname, we no longer use a specification for disjointness, as
%that would require variable unification.
This section first presents the set of rules for determining whether two types are disjoint. 
The set of rules is algorithmic and an implementation is easily derived from them. 
After, it will show a few important properties regarding substitution, which will turn out
to be crucial to ensure type-safety.
Finally, it will discuss the bounds of disjoint quantification and what implications
they have on \name.

\begin{comment}
\subsection{Derivation of the Algorithmic Rules}

In this subsection, we illustrate how to derive the algorithmic disjointness
rules by showing a detailed example for functions. For the ease of discussion,
first we introduce some notation.

\begin{definition}[Set of common supertypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  supertypes} by \[ \commonsuper(A,B) \] In other words, a type $C \in \;
  \commonsuper(A,B)$ if and only  if $A \subtype C$ and $B \subtype C$.
\end{definition}

\begin{example}
  $\commonsuper(\tyint,\tychar)$ is empty, since $\tyint$ and $\tychar$
  share no common supertype.
\end{example}

Parellel to the notion of the set of common supertypes is the notion of the set
of common subtypes.

\begin{definition}[Set of common subtypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  subtypes} by \[ \commonsub(A,B) \] In other words, a type $C \in \; \commonsub(A,B)$
  if and only  if $C \subtype A$ and $C \subtype B$.
\end{definition}

\begin{example}
  $\commonsub(\tyint,\tychar)$ is an infinite set which contains $\tyint \inter
  \tychar$, $\tychar \inter \tyint$, $(\tyint \inter \tybool) \inter \tychar$
  and so on. But the type $\tybool$ is not inside, since it is not a subtype of
  $\tyint$ or $\tychar$.
\end{example}


\paragraph{Shorthand notation.} For brevity, we will use \[ \mathcal{A} \to
\mathcal{B} \] as a shorthand for the \emph{set} of types of the form $A \to B$,
where $A \in \mathcal{A}$ and $B \in \mathcal{B}$. The same shorthand applies to
all other constructors of types, in addition to functions, as well. As a simple
example,  \[ \{ \tyint, \tystring \} \to \{ \tyint, \tychar \} \] is a shorthand for \[ \{
\tyint \to \tyint, \tyint \to \tychar, \tystring \to \tyint, \tystring \to \tychar \} \]


Recall that we say two types $A$ and $B$ are disjoint if they do not share a
common supertype. Therefore, determining if two types $A$ and $B$ are disjoint
is the same as determining if $\commonsuper(A,B)$ is empty.

\paragraph{Determining disjointness of functions.} Now let's dive into the case
where both $A$ and $B$ are functions and consider how to compute
$\commonsuper(A_1 \to A_2, B_1 \to B_2)$. By the subtyping rules, the supertype
of a function must also be a function.\george{Nah... only after normalization.
If not, it can also be $\inter$} Let $C_1 \to C_2$ be a common supertype
of $A_1 \to A_2$ and $B_1 \to B_2$. Then it must satisfy the following:
\begin{mathpar}
  \inferrule
    {C_1 \subtype A_1 \\ A_2 \subtype C_2}
    {A_1 \to A_2 \subtype C_1 \to C_2}

  \inferrule
    {C_1 \subtype B_1 \\ B_2 \subtype C_2}
    {B_1 \to B_2 \subtype C_1 \to C_2}
\end{mathpar}
From which we see that $C_1$ is a common subtype of $A_1$ and $B_1$ and that
$C_2$ is a common supertype of $A_2$ and $B_2$. Therefore, we can write:
\[ \commonsuper(A_1 \to A_2, B_1 \to B_2) \ = \ \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \]
By definition, $\commonsub(A_1,B_1) \to \commonsuper(A_2,B_2)$ is not empty if and only if both
$\commonsub(A_1,B_1)$ and $\commonsuper(A_2,B_2)$ is nonempty. However, note
that with intersection types, $\commonsub(A_1,B_1)$ is always nonempty because
$A_1 \inter B_1$ belongs to $\commonsub(A_1,B_1)$. Therefore, the problem of
determining if $\commonsuper(A_1 \to A_2, B_1 \to B_2)$ is empty reduces to the
problem of determining if $\commonsuper(B_1 \to B_2)$ is empty, which is, by
definition, if $B_1$ and $B_2$ are disjoint. Finally, we have derived a rule for
functions:
\begin{mathpar}
  \ruledisfun
\end{mathpar}

The analysis needed for determining if types with other constructors are
disjoint is similar. Below are the major results of the recursive definitions for
$\commonsuper$:
\begin{align*}
  \commonsuper(A_1 \to A_2, B_1 \to B_2) &= \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \\
  \commonsuper({A_1 \inter A_2, B})      &= \commonsuper(A_1, B) \cup \commonsuper(A_1,B) \\
  \commonsuper({A, B_1 \inter B_2})      &= \commonsuper(A, B_1) \cup \commonsuper(A,B_2)
\end{align*}\george{Missing the forall case. But we're just going to
  drop the formulae.}
\end{comment}

\subsection{Algorithmic Rules}

\begin{figure}[!t]
  \begin{mathpar}
    \formdis \\
    \ruledistop \and \ruledistopsym \and 
    \ruledisvar \and \ruledissym \and \ruledisforallext \and 
    \ruledisfun \and \ruledisinterl \and \ruledisinterr \and 
    \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    \ruleaxintfun \and \ruleaxintforalldis \and \ruleaxfunforalldis \and \ruleaxsym
  \end{mathpar}

  \caption{Algorithmic Disjointness.}
  \label{fig:disjointness}
\end{figure}

The rules for the disjointness judgement are shown in
Figure~\ref{fig:disjointness}, which consists of two judgements.
 
\paragraph{Main judgement.} The judgement $\jdis \Gamma A B$ says
two types $A$ and $B$ are disjoint in a context $\Gamma$.
The top five rules are novel in relation to the algorithm described in \oldname.
\reflabel{\labeldistop} and \reflabel{\labeldistopsym} say that any type is disjoint to 
$\top$.
\reflabel{\labeldisvar} is the base rule and \reflabel{\labeldissym} is its twin rule 
\bruno{I think we should change the names of the rules. Perhaps 
follow the subtyping relation and use the letter ``D''. Say $D_{\top}$ for the 
disjointness rule for top.}. 
\joao{added lines on top of axioms, this already cleans up a bit.}
Both rules state that a type variable is disjoint to some type $A$, if $\Gamma$ contains any
subtype of the corresponding disjointness constraint. 
This rule is a specialization of the more general lemma:

\[ \inferrule {\jwf \Gamma {A \disjoint B} \\ B \subtype C }
              {\jwf \Gamma {A \disjoint C}} \]
The lemma states that if a type $A$ is disjoint to $B$ under $\Gamma$, then it is also disjoint
to any supertype of $B$. % TODO show example here?
The rule for disjoint quantification \reflabel{\labeldisforall} is the last novel rule. 
It adds a constraint composed of the intersection both constraints into $\Gamma$ and checks for 
disjointness in the bodies under that environment.
To illustrate this rule, consider the following two types:
\[ (\forall (\alpha * \tyint).~\tyint \& \alpha) \qquad 
(\forall (\alpha * \tychar). ~\tychar \& \alpha) \]
The question is under which conditions are those two types disjoint.
In the first type $\alpha$ cannot be instantiated with $\tyint$ and in
the second case $\alpha$ cannot be instantiated with $\tychar$.
Therefore for both bodies to be disjoint, $\alpha$ cannot be instantiated with either $\tyint$ 
or $\tychar$. 
The rule for disjoint quantification captures this fact by requiring the bodies of disjoint 
quantification to be checked for disjointness under both constraints.
The reader might notice how this intersection does not necessarily need to be well-formed,
in the sense that the types that compose it might not be disjoint.
The explanation for this underlies in the fact that disjointness is only necessary to guarantee
the coherence of elaboration.
Introducing arbitrary intersection types in the environment is not problematic, as the disjointness
relation does not rely on the target term produced by the subtyping relation.
The remaining rules are identical to the original rules, and we will only briefly explain them.
The rule for functions \reflabel{\labeldisfun} says that two function
types are disjoint if and only if their return types are disjoint. 
The rules dealing with intersection types (\reflabel{\labeldisinterl}
and \reflabel{\labeldisinterr}) say that an intersection is disjoint to some type $B$, whenever
both of their components are also disjoint to $B$.
Finally, the rule \reflabel{\labeldisax} says two types are considered disjoint if they are
judged to be disjoint by the axiom rules, which are explained below.

\paragraph{Axioms.} Axiom rules take care of two types with different language constructs.
Just as in ..., these rules capture the set of rules is that $A \disjointax B$ holds for all 
two types of different constructs unless any of them is an intersection type.
Note that disjointness with the $\top$ type is already captured by {\reflabel{\labeldistop}}
and {\reflabel{\labeldistopsym}}.

\subsection{Substitution metatheory}

Disjointness will not only play a fundamental role in ensuring coherence, but also in 
ensuring the type-safety of our system.
Since the type-system is only allowed to instantiate a type variable with 
other types which are disjoint to the variable's disjointness constraint, one might ask:
what are the exact implications of mixing substitution with disjoint intersection types? 
We will next dive into this question in greater detail.


\paragraph{Disjoint substitutions}
One rule of thumb in disjoint intersection types states that, if a type $A$ is 
disjoint to a type $B$, then the intersection $A \inter B$ is well-typed.
However, during type instantiation (i.e. when type substitution should be stable), both types
$A$ and $B$ can change.
It should follow naturally that this instantiation won't produce an ill-formed type $A \inter B$,
or, more generally, disjointness should be stable under substitution. 
Let us illustrate with an example, showing why disjointness judgements are not invariant with
respect to free variable substitution.
In other words, why a careless substitution can violate the disjoint constraint in the context. 
Consider the following judgement, where in the context $\alpha
\disjoint \tyint$, $\alpha$ and $\tyint$ are disjoint:
\[ \jdis {\alpha \disjoint \tyint} \alpha \tyint \]
After the substitution of $\tyint$ for $\alpha$ on the two types, the sentence
\[ \jdis {\alpha \disjoint \tyint} \tyint \tyint \]
is no longer true since $\tyint$ is clearly not disjoint with itself.
This explains the need to ensure that during type-instantiation the target of the substitution  
is compatible with the disjointness constraint associated with the variable. 

Now, more formally, we can show following lemma holds: 

\joao{missing WFEnv premisses}
\begin{lemma}[Disjointness is stable under substitution]
  \label{lemma:orthosubst}

  If $(x \disjoint C) \in \Gamma$ and $\jdis \Gamma C D$, 
  then $\jdis {\Gamma \subst C x} {A \subst C x} {B \subst C x}$,
\end{lemma}
where $\Gamma \subst C x$ means substituting $x$ by $C$ in the co-domain of the environment.

\begin{proof}
  By induction on the disjointness derivation of $C$ and $D$.
  Special attention is necessary for the variable case: it was necessary to prove stability
  of substitution for the subtyping relation.
  It was also needed to show that, if $C$ and $D$ do not contain any variable $x$, then it is
  safe to make a substitution in the co-domain in the environment.
\end{proof}


\bruno{This explanation is too brief. Firstly you want to formally state the substitution 
lemma here, and then expand the explanation including some aspects that made the 
proof non-trivial, and perhaps a discussion about which bounds to chose ($\top$ or $\bot$).}

\paragraph{Well-formedness substitution stability}
Typically polymorphic systems with explicit instantiation are required to be shown that their
types are stable under substitution, in order to avoid ill-formed types.
In the presence of disjoint quantification, we cannot prove such property.
However, a weaker version of that property -- but strong enough for our type-system's metatheory 
-- can be proven, namely:

\joao{again, missing WFEnv premises}
\begin{lemma}[Types are stable under substitution]
  \label{lemma:wfsubst}

  If $\jwf \Gamma A$ and $\jwf \Gamma B$ and $(x \disjoint C) \in \Gamma$ 
  and $\jdis \Gamma B C$, then $\jwf {\Gamma \subst x B} {A \subst x B}$.
\end{lemma}

%\begin{restatable}[Instantiation]{lemma}{instantiation}
%  \label{lemma:instantiation}
%
%  If $\jwf {\Gamma, \alpha \disjoint B} C$, $\jwf \Gamma A$, $\jdis \Gamma A B$
%  then $\jwf \Gamma {\subst A \alpha C}$.
%\end{restatable}

\begin{proof}
By induction on the well-formedness derivation of $A$.
The intersection case requires the use of Lemma~\ref{lemma:orthosubst}.
Also, the variable case required proving that if $x$ does not occur free in $A$, and it is safe
to substitute it in the co-domain of $\Gamma$, then it is safe to perform the substitution.
\end{proof}

This lemma enables us to show that all types produced by the type-system are well-typed.
More formally, we have that:

\begin{restatable}[Well-formed typing]{lemma}{wellformedtyping}
  \label{lemma:wellformed-typing}

  If $\jcheck \Gamma e A$, then $\jwf \Gamma A$. 

  If $\jinfer \Gamma e A$, then $\jwf \Gamma A$.
\end{restatable}

\begin{proof}
  By induction on the derivation and applying
  Lemma~\ref{lemma:wfsubst} in the case of \reflabel{\labelttapp}.
\end{proof}

Even though the meta-theory is consistent with the expected results, there is still an open
question that remains unanswered: what exactly are the bounds of disjoint quantification?
In other words, which type(s) might be used to allow unrestricted instantiation, and which
one(s) might be used to completely restrict instantiation?
As one might expected, the answer is tightely related to subtyping, as we will show next. 

\subsection{Bounds of disjoint quantification}
As we have mentioned previously, substitution raises the question of what range of types can be 
instantiated for a given variable, under a given context.

\paragraph{Most liberal bound}
The system we are describing must be complete with respect to System-$F$, meaning that any
program accepted by System-$F$ should also be accepted by \name.
Since System-$F$ does not contain disjointness quantification, it is necessary for \name to 
include a type which is disjoint to every other type (i.e. the most liberal constraint): $\top$.
Thus, the System-$F$'s type $\forall \alpha. {T_F}$ (where ${T_F}$ is some other type), is
equivalent to \name's $\fordis \alpha \top {T_i}$, where ${T_i}$ is an equivalent translation of
$T_{F}$.

\paragraph{Most restrictive bound}
Inversely, the most restrictive type should be $\bot$, as one might think of $\bot$ as specific 
as the infinite intersection.
In other words, $\bot$ is not disjoint to any type, except top-like types.
However, introducing $\bot$ is not compatible with our disjointness rule
\reflabel{\labeldisvar} and well-formedness of contexts.
Let us take a closer look, by supposing that we wish to derive $\jdis \Gamma x x$, for some variable 
$x$, under some well-formed context $\Gamma$.
For this end, we want to use \reflabel{\labeldisvar} with the type $A$ as a sub-type of $x$, 
i.e. an (n-ary) intersection containing $x$.
Well-formedness of environments guarantees that this will never happen, since $x$ is not in
scope of itself. 
Thus, without a $\bot$ type, a derivation for that statement does not exist. 
However, by introducing $\bot$ we are now able to derive it, since $A$ can now be $\bot$: a valid
sub-type of $x$ which does not contain $x$.
In fact, introducing any \emph{bottom-like} type (i.e. $\bot \inter B$) can lead to this
undesired behaviour.
Since defining the lower bound is not strictly necessary to our formalization; introduces 
substantial complexity in our system; and its practical application is still not clear, we left this
as an open problem for future work. 
