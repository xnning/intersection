\section{Disjointness} \label{sec:alg-dis}

Section~\ref{sec:fi} presented a type system with disjoint
intersection types and disjoint quantification that we will prove to be
both type-safe and coherent. 
However, before we can prove such properties, it is necessary to introduce our
new version of disjointness, considering polymorphism and disjointness quantificaton.
%In constrast with \oldname, we no longer use a specification for disjointness, as
%that would require variable unification.
This section first presents the set of rules for determining whether two types are disjoint. 
The set of rules is algorithmic and an implementation is easily derived from them. 
After, it will show a few important properties regarding substitution, which will turn out
to be crucial to ensure type-safety.
Finally, it will discuss the bounds of disjoint quantification and what implications
they have on \name, with a special focus on the $\top$ type and an hypothetical $\bot$ type.

\begin{comment}
\subsection{Derivation of the Algorithmic Rules}

In this subsection, we illustrate how to derive the algorithmic disjointness
rules by showing a detailed example for functions. For the ease of discussion,
first we introduce some notation.

\begin{definition}[Set of common supertypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  supertypes} by \[ \commonsuper(A,B) \] In other words, a type $C \in \;
  \commonsuper(A,B)$ if and only  if $A \subtype C$ and $B \subtype C$.
\end{definition}

\begin{example}
  $\commonsuper(\tyint,\tychar)$ is empty, since $\tyint$ and $\tychar$
  share no common supertype.
\end{example}

Parellel to the notion of the set of common supertypes is the notion of the set
of common subtypes.

\begin{definition}[Set of common subtypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  subtypes} by \[ \commonsub(A,B) \] In other words, a type $C \in \; \commonsub(A,B)$
  if and only  if $C \subtype A$ and $C \subtype B$.
\end{definition}

\begin{example}
  $\commonsub(\tyint,\tychar)$ is an infinite set which contains $\tyint \inter
  \tychar$, $\tychar \inter \tyint$, $(\tyint \inter \tybool) \inter \tychar$
  and so on. But the type $\tybool$ is not inside, since it is not a subtype of
  $\tyint$ or $\tychar$.
\end{example}


\paragraph{Shorthand notation.} For brevity, we will use \[ \mathcal{A} \to
\mathcal{B} \] as a shorthand for the \emph{set} of types of the form $A \to B$,
where $A \in \mathcal{A}$ and $B \in \mathcal{B}$. The same shorthand applies to
all other constructors of types, in addition to functions, as well. As a simple
example,  \[ \{ \tyint, \tystring \} \to \{ \tyint, \tychar \} \] is a shorthand for \[ \{
\tyint \to \tyint, \tyint \to \tychar, \tystring \to \tyint, \tystring \to \tychar \} \]


Recall that we say two types $A$ and $B$ are disjoint if they do not share a
common supertype. Therefore, determining if two types $A$ and $B$ are disjoint
is the same as determining if $\commonsuper(A,B)$ is empty.

\paragraph{Determining disjointness of functions.} Now let's dive into the case
where both $A$ and $B$ are functions and consider how to compute
$\commonsuper(A_1 \to A_2, B_1 \to B_2)$. By the subtyping rules, the supertype
of a function must also be a function.\george{Nah... only after normalization.
If not, it can also be $\inter$} Let $C_1 \to C_2$ be a common supertype
of $A_1 \to A_2$ and $B_1 \to B_2$. Then it must satisfy the following:
\begin{mathpar}
  \inferrule
    {C_1 \subtype A_1 \\ A_2 \subtype C_2}
    {A_1 \to A_2 \subtype C_1 \to C_2}

  \inferrule
    {C_1 \subtype B_1 \\ B_2 \subtype C_2}
    {B_1 \to B_2 \subtype C_1 \to C_2}
\end{mathpar}
From which we see that $C_1$ is a common subtype of $A_1$ and $B_1$ and that
$C_2$ is a common supertype of $A_2$ and $B_2$. Therefore, we can write:
\[ \commonsuper(A_1 \to A_2, B_1 \to B_2) \ = \ \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \]
By definition, $\commonsub(A_1,B_1) \to \commonsuper(A_2,B_2)$ is not empty if and only if both
$\commonsub(A_1,B_1)$ and $\commonsuper(A_2,B_2)$ is nonempty. However, note
that with intersection types, $\commonsub(A_1,B_1)$ is always nonempty because
$A_1 \inter B_1$ belongs to $\commonsub(A_1,B_1)$. Therefore, the problem of
determining if $\commonsuper(A_1 \to A_2, B_1 \to B_2)$ is empty reduces to the
problem of determining if $\commonsuper(B_1 \to B_2)$ is empty, which is, by
definition, if $B_1$ and $B_2$ are disjoint. Finally, we have derived a rule for
functions:
\begin{mathpar}
  \ruledisfun
\end{mathpar}

The analysis needed for determining if types with other constructors are
disjoint is similar. Below are the major results of the recursive definitions for
$\commonsuper$:
\begin{align*}
  \commonsuper(A_1 \to A_2, B_1 \to B_2) &= \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \\
  \commonsuper({A_1 \inter A_2, B})      &= \commonsuper(A_1, B) \cup \commonsuper(A_1,B) \\
  \commonsuper({A, B_1 \inter B_2})      &= \commonsuper(A, B_1) \cup \commonsuper(A,B_2)
\end{align*}\george{Missing the forall case. But we're just going to
  drop the formulae.}
\end{comment}

\subsection{Algorithmic Rules}

\begin{figure}[!t]
  \begin{mathpar}
    \formdis \\
    \ruledistop \and \ruledistopsym \and 
    \ruledisvar \and \ruledissym \and \ruledisforallext \and 
    \ruledisfun \and \ruledisinterl \and \ruledisinterr \and 
    \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    \ruleaxintfun \and \ruleaxintforalldis \and \ruleaxfunforalldis \and \ruleaxsym
  \end{mathpar}

  \caption{Algorithmic Disjointness.}
  \label{fig:disjointness}
\end{figure}

The rules for the disjointness judgement are shown in
Figure~\ref{fig:disjointness}, which consists of two judgements.
 
\paragraph{Main judgement.} The judgement $\jdis \Gamma A B$ says
two types $A$ and $B$ are disjoint in a context $\Gamma$.
The top five rules are novel in relation to the algorithm described in \oldname.
\reflabel{\labeldistop} and \reflabel{\labeldistopsym} say that any type is disjoint to 
$\top$.
\reflabel{\labeldisvar} is the base rule and \reflabel{\labeldissym} is its twin rule 
Both rules state that a type variable is disjoint to some type $A$, if $\Gamma$ contains any
subtype of the corresponding disjointness constraint. 
This rule is a specialization of the more general lemma:
\joao{can we give this a name, as it is re-stated later? i.e. covariance of disjointness?}

\[ \inferrule {\jwf \Gamma {A \disjoint B} \\ B \subtype C }
              {\jwf \Gamma {A \disjoint C}} \]
The lemma states that if a type $A$ is disjoint to $B$ under $\Gamma$, then it is also disjoint
to any supertype of $B$. 
Note how these two variable rules would allow one to prove $x \disjoint x$, for a given type 
variable $x$.
However, since we are assuming that all contexts are well-formed, it is not possible to make
such derivation as $x$ cannot occur free in $A$. 
The rule for disjoint quantification \reflabel{\labeldisforall} is the last novel rule. 
It adds a constraint composed of the intersection both constraints into $\Gamma$ and checks for 
disjointness in the bodies under that environment.
To illustrate this rule, consider the following two types:
\[ (\forall (\alpha * \tyint).~\tyint \& \alpha) \qquad 
(\forall (\alpha * \tychar). ~\tychar \& \alpha) \]
The question is under which conditions are those two types disjoint.
In the first type $\alpha$ cannot be instantiated with $\tyint$ and in
the second case $\alpha$ cannot be instantiated with $\tychar$.
Therefore for both bodies to be disjoint, $\alpha$ cannot be instantiated with either $\tyint$ 
or $\tychar$. 
The rule for disjoint quantification captures this fact by requiring the bodies of disjoint 
quantification to be checked for disjointness under both constraints.
The reader might notice how this intersection does not necessarily need to be well-formed,
in the sense that the types that compose it might not be disjoint.
The explanation for this underlies in the fact that disjointness is only necessary to guarantee
the coherence of elaboration.
Introducing arbitrary intersection types in the environment is not problematic, as the disjointness
relation does not rely on the target term produced by the subtyping relation.
The remaining rules are identical to the original rules, and we will only briefly explain them.
The rule for functions \reflabel{\labeldisfun} says that two function
types are disjoint if and only if their return types are disjoint. 
The rules dealing with intersection types (\reflabel{\labeldisinterl}
and \reflabel{\labeldisinterr}) say that an intersection is disjoint to some type $B$, whenever
both of their components are also disjoint to $B$.
Finally, the rule \reflabel{\labeldisax} says two types are considered disjoint if they are
judged to be disjoint by the axiom rules, which are explained below.

\paragraph{Axioms.} Axiom rules take care of two types with different language constructs.
These rules capture the set of rules is that $A \disjointax B$ holds for all 
two types of different constructs unless any of them is an intersection type, a type variable,
or $\top$.
Note that disjointness with type variables is already captured by \reflabel{\labeldisvar} and 
\reflabel{\labeldissym}, and disjointness with the $\top$ type is already captured by 
{\reflabel{\labeldistop}} and {\reflabel{\labeldistopsym}}.

\subsection{Substitution metatheory}

Disjointness will not only play a fundamental role in ensuring coherence, but also in 
ensuring the type-safety of our system.
Since the type-system is only allowed to instantiate a type variable with 
other types which are disjoint to the variable's disjointness constraint, one might ask:
what are the exact implications of mixing substitution with disjoint intersection types? 
We will next dive into this question in greater detail.


\paragraph{Disjoint substitutions}
One rule of thumb in disjoint intersection types is that, if a type $A$ is 
disjoint to a type $B$, then the intersection $A \inter B$ is well-typed.
However, during type instantiation (i.e. when type substitution should be stable), both types
$A$ and $B$ can change.
It should follow naturally that this instantiation won't produce an ill-formed type $A \inter B$,
or, more generally, disjointness should be stable under substitution. 
Let us illustrate with an example, showing why disjointness judgements are not invariant with
respect to free variable substitution.
In other words, why a careless substitution can violate the disjoint constraint in the context. 
Consider the following judgement, where in the context $\alpha
\disjoint \tyint$, $\alpha$ and $\tyint$ are disjoint:
\[ \jdis {\alpha \disjoint \tyint} \alpha \tyint \]
After the substitution of $\tyint$ for $\alpha$ on the two types, the sentence
\[ \jdis {\alpha \disjoint \tyint} \tyint \tyint \]
is no longer true since $\tyint$ is clearly not disjoint with itself.
This explains the need to ensure that during type-instantiation the target of the substitution  
is compatible with the disjointness constraint associated with the variable. 

Now, more formally, we can show following lemma holds: 

\begin{lemma}[Disjointness is stable under substitution]
  \label{lemma:orthosubst}

  If $(x \disjoint C) \in \Gamma$ and $\jdis \Gamma C D$, 
  then $\jdis {\subst C x \Gamma} {\subst C x A} {\subst C x B}$,
\end{lemma}

\begin{proof}
  By induction on the disjointness derivation of $C$ and $D$.
  Special attention for the variable case, where it was necessary to prove stability
  of substitution for the subtyping relation.
  It was also needed to show that, if $C$ and $D$ do not contain any variable $x$, then it is
  safe to make a substitution in the co-domain of the environment.
\end{proof}

\paragraph{Well-formedness substitution stability}
Typically polymorphic systems with explicit instantiation are required to be shown that their
types are stable under substitution, in order to avoid ill-formed types.
In the presence of disjoint quantification, we cannot prove such property.
However, a weaker version of that property -- but strong enough for our type-system's metatheory 
-- can be proven, namely:

\begin{lemma}[Types are stable under substitution]
  \label{lemma:wfsubst}

  If $\jwf \Gamma A$ and $\jwf \Gamma B$ and $(x \disjoint C) \in \Gamma$ 
  and $\jdis \Gamma B C$, then $\jwf {\subst B x \Gamma} {\subst B x A}$.
\end{lemma}

%\begin{restatable}[Instantiation]{lemma}{instantiation}
%  \label{lemma:instantiation}
%
%  If $\jwf {\Gamma, \alpha \disjoint B} C$, $\jwf \Gamma A$, $\jdis \Gamma A B$
%  then $\jwf \Gamma {\subst A \alpha C}$.
%\end{restatable}

\begin{proof}
By induction on the well-formedness derivation of $A$.
The intersection case requires the use of Lemma~\ref{lemma:orthosubst}.
Also, the variable case required proving that if $x$ does not occur free in $A$, and it is safe
to substitute it in the co-domain of $\Gamma$, then it is safe to perform the substitution.
\end{proof}

This lemma enables us to show that all types produced by the type-system are well-typed.
More formally, we have that:

\begin{restatable}[Well-formed typing]{lemma}{wellformedtyping}
  \label{lemma:wellformed-typing}

  If $\jcheck \Gamma e A$, then $\jwf \Gamma A$. 

  If $\jinfer \Gamma e A$, then $\jwf \Gamma A$.
\end{restatable}

\begin{proof}
  By induction on the derivation and applying
  Lemma~\ref{lemma:wfsubst} in the case of \reflabel{\labelttapp}.
\end{proof}

Even though the meta-theory is consistent with the expected results, there is still a
question that remains unanswered: what exactly are the bounds of disjoint quantification?
In other words, which type(s) might be used to allow unrestricted instantiation, and which
one(s) might be used to completely restrict instantiation?
As one might expect, the answer is tightely related to subtyping, as we will show next. 

\subsection{Bounds of disjoint quantification}
Substitution raises the question of what range of types can be instantiated for a given variable, 
under a given context.
To get a feeling about this, let us restate a lemma, which we used to justify the rule 
for disjointness of variables:

\[ \inferrule {\jwf \Gamma {A \disjoint B} \\ B \subtype C }
              {\jwf \Gamma {A \disjoint C}} \]

If one takes $A$ as some variable $x$, and $B$ as some disjointness constraint bound to it in 
the environment, then we can ask how many suitable types are there to instantiate $x$ with? 
Before we answer this, let us ask first how many options are there for $C$, depending on the 
shape of $B$?
Given that the cardinality of \name's types is infinite, for the sake of this example we will 
restrict the type universe to a finite number of 
primitive types (i.e. $\tyint$, $\tystring$, etc), disjoint intersections of these types,
$\top$ and $\bot$.
Having this in mind, we can answer the second question: the number of choices for $C$ is directly 
proportional to the number of intersections present in $B$.
For example, taking $B$ as $\tyint$ leads $C$ to be either $\top$ or $\tyint$; whereas $B$ as 
$\tyint \inter \tystring$ leaves $C$ as either $\top$, $\tyint$ or $\tystring$.
However, as the choices for $C$ grows, the less choices we are left to instantiate 
the variable $x$, since $x$ must be disjoint to all possible $C$'s. 
Thus, to answer the first question, the options for instantiating $x$ are inversely proportional 
to the number of intersections present in $B$.
As an analogy, one might think of a disjointness constraint as a list of (forbidden) types, where 
primitive types are the singleton list and each $\inter$ is the concatenation operator
\footnote{Since we require constraints to be well-formed, one might consider them as set of
forbidden types (as opposed to a list).}.

We can now turn our attention to the two extreme cases, namely $\top$ 
(i.e. the 0-ary intersection) and $\bot$ (i.e. the infinite intersection) 
\footnote{$\bot$ would not add anything to the hypothetical finite type 
system, however it can be seen as the infinite intersection in \name.}.
Following the same logic, we may conclude that $\top$ as the associated constraint leaves $x$ with 
the most options for instantiation whereas $\bot$ will deliver the least options.
We will discuss their role in our system next.

\paragraph{The most liberal bound}
It is easy to see that $\top$ is the most liberal type since it is disjoint to everything. 
This means that the $\top$ type actually plays an important role in our system, since the latter 
must be complete with respect to System $F$. 
In other words, any program accepted by System $F$ should also be accepted by \name.
Since System $F$ does not contain disjointness quantification, $\top$ comes in handy:
the System $F$'s type $\forall \alpha. {T_F}$ (where ${T_F}$ is some other type), is
equivalent to \name's type $\fordis \alpha \top {T_i}$, where ${T_i}$ is also an equivalent 
translation of $T_{F}$.
\joao{should we include here a simple example? i.e. the identity function?}

\paragraph{The most restrictive bound}
Inversely, the most restrictive type is $\bot$, as it is not disjoint to any type, except top-like 
types. \joao{is this true? I'm not sure about what (bot \& top) means.}
However, introducing $\bot$ is not compatible with our disjointness rule
\reflabel{\labeldisvar} and well-formedness of contexts.
Let us take a closer look, by supposing that we wish to derive $\jdis \Gamma x x$, for some variable 
$x$, under some well-formed context $\Gamma$.
In \name, we can only use \reflabel{\labeldisvar} with the type $A$ as a sub-type of $x$, 
i.e. an (n-ary) intersection containing $x$.
Well-formedness of environments guarantees that this will never happen, since $x$ is not in
scope of itself. 
Thus, without a $\bot$ type, a derivation for that statement does not exist. 
However, by introducing $\bot$ we may now construct such derivation, as $A$ can now be $\bot$: a valid
sub-type of $x$ which does not contain $x$.
In fact, had \name included a $\bot$ type, then introducing any \emph{bottom-like} type 
(i.e. $\bot \inter A$, for any type $A$) can lead to this undesired behaviour.
Since defining the lower bound is not strictly necessary to the formalization; introduces 
substantial complexity in our system; and its practical application is not clear, we left this
as an open problem for future work. 
