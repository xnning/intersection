\section{Disjointness} \label{sec:alg-dis}

Section~\ref{sec:fi} presented a type system with disjoint
intersection types and disjoint quantification that is both type-safe
and coherent. 

This section presents the set of rules for determining whether two types are disjoint. 
The set of rules is algorithmic and an implementation is easily derived from them. 
Therefore we solve the problem of finding an algorithm to compute disjointness.  

\begin{comment}
\subsection{Derivation of the Algorithmic Rules}

In this subsection, we illustrate how to derive the algorithmic disjointness
rules by showing a detailed example for functions. For the ease of discussion,
first we introduce some notation.

\begin{definition}[Set of common supertypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  supertypes} by \[ \commonsuper(A,B) \] In other words, a type $C \in \;
  \commonsuper(A,B)$ if and only  if $A \subtype C$ and $B \subtype C$.
\end{definition}

\begin{example}
  $\commonsuper(\tyint,\tychar)$ is empty, since $\tyint$ and $\tychar$
  share no common supertype.
\end{example}

Parellel to the notion of the set of common supertypes is the notion of the set
of common subtypes.

\begin{definition}[Set of common subtypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  subtypes} by \[ \commonsub(A,B) \] In other words, a type $C \in \; \commonsub(A,B)$
  if and only  if $C \subtype A$ and $C \subtype B$.
\end{definition}

\begin{example}
  $\commonsub(\tyint,\tychar)$ is an infinite set which contains $\tyint \inter
  \tychar$, $\tychar \inter \tyint$, $(\tyint \inter \tybool) \inter \tychar$
  and so on. But the type $\tybool$ is not inside, since it is not a subtype of
  $\tyint$ or $\tychar$.
\end{example}


\paragraph{Shorthand notation.} For brevity, we will use \[ \mathcal{A} \to
\mathcal{B} \] as a shorthand for the \emph{set} of types of the form $A \to B$,
where $A \in \mathcal{A}$ and $B \in \mathcal{B}$. The same shorthand applies to
all other constructors of types, in addition to functions, as well. As a simple
example,  \[ \{ \tyint, \tystring \} \to \{ \tyint, \tychar \} \] is a shorthand for \[ \{
\tyint \to \tyint, \tyint \to \tychar, \tystring \to \tyint, \tystring \to \tychar \} \]


Recall that we say two types $A$ and $B$ are disjoint if they do not share a
common supertype. Therefore, determining if two types $A$ and $B$ are disjoint
is the same as determining if $\commonsuper(A,B)$ is empty.

\paragraph{Determining disjointness of functions.} Now let's dive into the case
where both $A$ and $B$ are functions and consider how to compute
$\commonsuper(A_1 \to A_2, B_1 \to B_2)$. By the subtyping rules, the supertype
of a function must also be a function.\george{Nah... only after normalization.
If not, it can also be $\inter$} Let $C_1 \to C_2$ be a common supertype
of $A_1 \to A_2$ and $B_1 \to B_2$. Then it must satisfy the following:
\begin{mathpar}
  \inferrule
    {C_1 \subtype A_1 \\ A_2 \subtype C_2}
    {A_1 \to A_2 \subtype C_1 \to C_2}

  \inferrule
    {C_1 \subtype B_1 \\ B_2 \subtype C_2}
    {B_1 \to B_2 \subtype C_1 \to C_2}
\end{mathpar}
From which we see that $C_1$ is a common subtype of $A_1$ and $B_1$ and that
$C_2$ is a common supertype of $A_2$ and $B_2$. Therefore, we can write:
\[ \commonsuper(A_1 \to A_2, B_1 \to B_2) \ = \ \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \]
By definition, $\commonsub(A_1,B_1) \to \commonsuper(A_2,B_2)$ is not empty if and only if both
$\commonsub(A_1,B_1)$ and $\commonsuper(A_2,B_2)$ is nonempty. However, note
that with intersection types, $\commonsub(A_1,B_1)$ is always nonempty because
$A_1 \inter B_1$ belongs to $\commonsub(A_1,B_1)$. Therefore, the problem of
determining if $\commonsuper(A_1 \to A_2, B_1 \to B_2)$ is empty reduces to the
problem of determining if $\commonsuper(B_1 \to B_2)$ is empty, which is, by
definition, if $B_1$ and $B_2$ are disjoint. Finally, we have derived a rule for
functions:
\begin{mathpar}
  \ruledisfun
\end{mathpar}

The analysis needed for determining if types with other constructors are
disjoint is similar. Below are the major results of the recursive definitions for
$\commonsuper$:
\begin{align*}
  \commonsuper(A_1 \to A_2, B_1 \to B_2) &= \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \\
  \commonsuper({A_1 \inter A_2, B})      &= \commonsuper(A_1, B) \cup \commonsuper(A_1,B) \\
  \commonsuper({A, B_1 \inter B_2})      &= \commonsuper(A, B_1) \cup \commonsuper(A,B_2)
\end{align*}\george{Missing the forall case. But we're just going to
  drop the formulae.}
\end{comment}

\subsection{Disjointness specification}

TODO should this go in the overview?

A fundamental difference in comparison to the \oldname system, is the changing and 
subsequent dropping of the specification.

\subsection{Algorithmic Rules}\bruno{The labels of the first two rules
are confusing (because the notation seems mixed)}
\bruno{The definitions seem a bit ugly with all these symetrical rules
going on. Can we clean up things a bit?}

\begin{figure}[h]
  \begin{mathpar}
    \formdis \\
    \ruledistop \and \ruledistopsym \and 
    \ruledisvar \and \ruledissym \and \ruledisforallext \and 
    \ruledisfun \and \ruledisinterl \and \ruledisinterr \and 
    \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    \ruleaxintfun \and \ruleaxintforalldis \and \ruleaxfunforalldis \and \ruleaxsym
  \end{mathpar}

  \caption{Algorithmic Disjointness.}
  \label{fig:disjointness}
\end{figure}

The rules for the disjointness judgement are shown in
Figure~\ref{fig:disjointness}, which consists of two judgements.
 
\paragraph{Main judgement.} The judgement $\jdisimpl \Gamma A B$ says
two types $A$ and $B$ are disjoint in a context $\Gamma$.
The top five rules are novel in relation to the algorithm described in \oldname.
\reflabel{\labeldistop} and \reflabel{\labeldistopsym} say that any type is disjoint to 
$\top$.
\reflabel{\labeldisvar} is the base rule and \reflabel{\labeldissym} is its twin rule. 
Both rules state that a type variable is disjoint to some type $A$, if $\Gamma$ contains any
subtype of the corresponding disjointness constraint. 
This rule is a specialization of the more general lemma:

\[ \inferrule {\jwf \Gamma {A \disjoint B} \\ B \subtype C }
              {\jwf \Gamma {A \disjoint C}} \]
The lemma states that if a type $A$ is disjoint to $B$ under $\Gamma$, then it is also disjoint
to any supertype of $B$. % TODO show example here?
The rule for disjoint quantification \reflabel{\labeldisforall} is the last novel rule. 
 % TODO another example?
The rule for disjoint quantification (\reflabel{\labeldisforall}) is the last novel rule. 
It adds a constraint composed of both constraints into $\Gamma$ and checks for disjointness in 
the bodies under that environment.
To illustrate this rule, consider the following two types:
\[ (\forall (\alpha * \tyint).~\tyint \& \alpha) \qquad (\forall (\alpha * \tychar). ~\tychar \& \alpha) \]
The question is under which conditions are those two types disjoint.
In the first type $\alpha$ cannot be instantiated with $\tyint$ and in
the second case $\alpha$ cannot be instantiated with $\tychar$.
Therefore for the two bodies to be considered disjoint, $\alpha$ cannot be instantiated with either $\tyint$ 
or $\tychar$. 
The rule for disjoint quantification captures this fact by requiring the bodies of disjoint quantification 
to be checked for disjointness under both constraints.
The remaining rules are identical to the original rules, and we will only briefly explain them.
The rule for functions \reflabel{\labeldisfun} says that two function
types are disjoint if and only if their return types are disjoint. 
The rules dealing with intersection types (\reflabel{\labeldisinterl}
and \reflabel{\labeldisinterr}) say that an intersection is disjoint to some type $B$, whenever
both of their components are also disjoint to $B$.
Finally, the rule \reflabel{\labeldisax} says two types are considered disjoint if they are
judged to be disjoint by the axiom rules, which are explained below.

\paragraph{Axioms.} Axiom rules take care of two types with different language constructs.
Just as in ..., these rules capture the set of rules is that $A \disjointax B$ holds for all 
two types of different constructs unless any of them is an intersection type.
Note that disjointness with the $\top$ type is already captured by {\reflabel{\labeldistop}}
and {\reflabel{\labeldistopsym}}.

