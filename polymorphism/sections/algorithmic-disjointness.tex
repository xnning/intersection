\section{Disjointness} \label{sec:alg-dis}
Section~\ref{sec:fi} presented a type system with disjoint
intersection types and disjoint quantification. In order to prove 
both type-safe and coherence (in Section~\ref{sec:disjoint}), it is necessary to first introduce a
notion of disjointness, considering polymorphism and disjointness quantification.
%In constrast with \oldname, we no longer use a specification for disjointness, as
%that would require variable unification.
This section presents an algorithmic set of rules for determining whether two types are disjoint. 
After, it will show a few important properties regarding substitution, which will turn out
to be crucial to ensure type-safety.
Finally, it will discuss the bounds of disjoint quantification and what implications
they have on \name, with a special focus on the $\top$ type. 

\begin{comment}
\subsection{Derivation of the Algorithmic Rules}

In this subsection, we illustrate how to derive the algorithmic disjointness
rules by showing a detailed example for functions. For the ease of discussion,
first we introduce some notation.

\begin{definition}[Set of common supertypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  supertypes} by \[ \commonsuper(A,B) \] In other words, a type $C \in \;
  \commonsuper(A,B)$ if and only  if $A \subtype C$ and $B \subtype C$.
\end{definition}

\begin{example}
  $\commonsuper(\tyint,\tychar)$ is empty, since $\tyint$ and $\tychar$
  share no common supertype.
\end{example}

Parellel to the notion of the set of common supertypes is the notion of the set
of common subtypes.

\begin{definition}[Set of common subtypes]
  For any two types $A$ and $B$, we can denote the \emph{set of their common
  subtypes} by \[ \commonsub(A,B) \] In other words, a type $C \in \; \commonsub(A,B)$
  if and only  if $C \subtype A$ and $C \subtype B$.
\end{definition}

\begin{example}
  $\commonsub(\tyint,\tychar)$ is an infinite set which contains $\tyint \inter
  \tychar$, $\tychar \inter \tyint$, $(\tyint \inter \tybool) \inter \tychar$
  and so on. But the type $\tybool$ is not inside, since it is not a subtype of
  $\tyint$ or $\tychar$.
\end{example}


\paragraph{Shorthand notation.} For brevity, we will use \[ \mathcal{A} \to
\mathcal{B} \] as a shorthand for the \emph{set} of types of the form $A \to B$,
where $A \in \mathcal{A}$ and $B \in \mathcal{B}$. The same shorthand applies to
all other constructors of types, in addition to functions, as well. As a simple
example,  \[ \{ \tyint, \tystring \} \to \{ \tyint, \tychar \} \] is a shorthand for \[ \{
\tyint \to \tyint, \tyint \to \tychar, \tystring \to \tyint, \tystring \to \tychar \} \]


Recall that we say two types $A$ and $B$ are disjoint if they do not share a
common supertype. Therefore, determining if two types $A$ and $B$ are disjoint
is the same as determining if $\commonsuper(A,B)$ is empty.

\paragraph{Determining disjointness of functions.} Now let's dive into the case
where both $A$ and $B$ are functions and consider how to compute
$\commonsuper(A_1 \to A_2, B_1 \to B_2)$. By the subtyping rules, the supertype
of a function must also be a function.\george{Nah... only after normalization.
If not, it can also be $\inter$} Let $C_1 \to C_2$ be a common supertype
of $A_1 \to A_2$ and $B_1 \to B_2$. Then it must satisfy the following:
\begin{mathpar}
  \inferrule
    {C_1 \subtype A_1 \\ A_2 \subtype C_2}
    {A_1 \to A_2 \subtype C_1 \to C_2}

  \inferrule
    {C_1 \subtype B_1 \\ B_2 \subtype C_2}
    {B_1 \to B_2 \subtype C_1 \to C_2}
\end{mathpar}
From which we see that $C_1$ is a common subtype of $A_1$ and $B_1$ and that
$C_2$ is a common supertype of $A_2$ and $B_2$. Therefore, we can write:
\[ \commonsuper(A_1 \to A_2, B_1 \to B_2) \ = \ \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \]
By definition, $\commonsub(A_1,B_1) \to \commonsuper(A_2,B_2)$ is not empty if and only if both
$\commonsub(A_1,B_1)$ and $\commonsuper(A_2,B_2)$ is nonempty. However, note
that with intersection types, $\commonsub(A_1,B_1)$ is always nonempty because
$A_1 \inter B_1$ belongs to $\commonsub(A_1,B_1)$. Therefore, the problem of
determining if $\commonsuper(A_1 \to A_2, B_1 \to B_2)$ is empty reduces to the
problem of determining if $\commonsuper(B_1 \to B_2)$ is empty, which is, by
definition, if $B_1$ and $B_2$ are disjoint. Finally, we have derived a rule for
functions:
\begin{mathpar}
  \ruledisfun
\end{mathpar}

The analysis needed for determining if types with other constructors are
disjoint is similar. Below are the major results of the recursive definitions for
$\commonsuper$:
\begin{align*}
  \commonsuper(A_1 \to A_2, B_1 \to B_2) &= \commonsub(A_1,B_1) \to \commonsuper(A_2,B_2) \\
  \commonsuper({A_1 \inter A_2, B})      &= \commonsuper(A_1, B) \cup \commonsuper(A_1,B) \\
  \commonsuper({A, B_1 \inter B_2})      &= \commonsuper(A, B_1) \cup \commonsuper(A,B_2)
\end{align*}\george{Missing the forall case. But we're just going to
  drop the formulae.}
\end{comment}

\subsection{Algorithmic Rules for Disjointness}

\begin{figure}[!t]
  \begin{spacing}{0.5}
  \begin{mathpar}
    \formdis \\
    \ruledistop \and \ruledistopsym \and 
    \ruledisvar \and \ruledissym \and \ruledisforallext \and 
    \ruledisfun \and \ruledisinterl \and \ruledisinterr \and 
    \ruledisatomic
  \end{mathpar}
  \begin{mathpar}
    \formax \\
    \ruleaxintfun \and \ruleaxintforalldis \and \ruleaxfunforalldis \and \ruleaxsym
  \end{mathpar}
  \end{spacing}

  \caption{Algorithmic disjointness.}
  \label{fig:disjointness}
\end{figure}

The rules for the disjointness judgement are shown in
Figure~\ref{fig:disjointness}, which consists of two judgements.
 
\paragraph{Main judgement.} The judgement $\jdis \Gamma A B$ says
two types $A$ and $B$ are disjoint in a context $\Gamma$.
The top five rules are novel in relation to the algorithm described in \oldname.
\reflabel{\labeldistop} and \reflabel{\labeldistopsym} say that any type is disjoint to 
$\top$.
This is a major difference with \oldname, where the notion of disjointness explicitly forbids
the presence of $\top$ types in intersections.
It turns out that even though $\top$ overlaps with every other type,
it does not affect coherence in any way.
We will come back to this in Section~\ref{sec:disjoint}.
 
Type variables are dealt with two rules:
\reflabel{\labeldisvar} is the base rule; and \reflabel{\labeldissym}
is its twin symmetrical rule. 
Both rules state that a type variable is disjoint to some type $A$, if $\Gamma$ contains any
subtype of the corresponding disjointness constraint. 
This rule is a specialization of the more general lemma:

\begin{restatable}[Covariance of disjointness]{lemma}{disjointnesscovariance}
  \label{lemma:disjointness-covariance}

  If $\jwf \Gamma {A \disjoint B}$ and $B \subtype C$, then $\jwf \Gamma {A \disjoint C}$.
\end{restatable}
\begin{proof}
By double induction, first on the disjointness derivation and then on the subtyping derivation.
The first induction case for~\reflabel{\labeldisvar} does not need the second induction as it is 
a straightforward application of subtyping transitivity. 
\end{proof}

The lemma states that if a type $A$ is disjoint to $B$ under $\Gamma$, then it is also disjoint
to any supertype of $B$. 
Note how these two variable rules would allow one to prove $x \disjoint x$, for a given type 
variable $x$.
However, since we are assuming that all contexts are well-formed, it is not possible to make
such derivation as $x$ cannot occur free in $A$. 
The rule for disjoint quantification \reflabel{\labeldisforall} is the last novel rule. 
It adds a constraint composed of the intersection both constraints into $\Gamma$ and checks for 
disjointness in the bodies under that environment.
To illustrate this rule, consider the following two types:
\[ (\forall (\alpha * \tyint).~\tyint \& \alpha) \qquad 
(\forall (\alpha * \tychar). ~\tychar \& \alpha) \]
When are these two types disjoint?
In the first type $\alpha$ cannot be instantiated with $\tyint$ and in
the second case $\alpha$ cannot be instantiated with $\tychar$.
Therefore for both bodies to be disjoint, $\alpha$ cannot be instantiated with either $\tyint$ 
or $\tychar$. 
%The rule for disjoint quantification captures this fact by requiring the bodies of disjoint 
%quantification to be checked for disjointness under both constraints.
The reader might notice how this intersection does not necessarily need to be well-formed,
in the sense that the types that compose it might not be disjoint.
This is not problematic because the intersections present as constraints in the environment
do not contribute directly to the (coherent) coercions generated by the type-system.
The remaining rules are identical to the original rules. 
%The rule for functions \reflabel{\labeldisfun} says that two function
%types are disjoint if and only if their return types are disjoint. 
%The rules dealing with intersection types (\reflabel{\labeldisinterl}
%and \reflabel{\labeldisinterr}) say that an intersection is disjoint to some type $B$, whenever
%both of their components are also disjoint to $B$.
%We emphasize that the rule \reflabel{\labeldisax} says two different type constructs are disjoint 
%if the axiom rules (explained below) apply. 

\paragraph{Axioms.} Axiom rules take care of two types with different language constructs.
These rules capture the set of rules is that $A \disjointax B$ holds for all 
two types of different constructs unless any of them is an intersection type, a type variable,
or $\top$.
Note that disjointness with type variables is already captured by \reflabel{\labeldisvar} and 
\reflabel{\labeldissym}, and disjointness with the $\top$ type is captured by 
{\reflabel{\labeldistop}} and {\reflabel{\labeldistopsym}}.

\subsection{Stability under Substitution}
The combination of polymorphism and disjoint intersection types
invalidates various conventional substitution lemmas related to
well-formedness and typing.  
For example, as shown in Section~\ref{sec:overview}, in the type 
$\fordis A \tyint {(\tyint \inter A) \to \tyint}$, the type $A$ cannot be substituted by any type.
However, under certain conditions, weaker versions of substituion lemmas do hold. 
The conditions are guaranteed by the type-system by only
allowing instantiations of a type variable with types disjoint to the
variable's disjointness constraints.

\paragraph{Problematic substitutions.}
One rule of thumb in disjoint intersection types is that, if a type
$A$ is disjoint to a type $B$, then the intersection $A \inter B$ is
well-typed.  However, during type instantiation (i.e. when type
substitution should be stable), both types $A$ and $B$ can change.  It
should follow naturally that this instantiation will not produce an
ill-formed type $A \inter B$, or, more generally, disjointness should
be stable under substitution.  Let us illustrate this with an example,
showing why disjointness judgements are not invariant with respect to
free variable substitution.  In other words, why a careless
substitution can violate the disjoint constraint in the context.
Consider the following judgement, where in the context $\alpha
\disjoint \tyint$, $\alpha$ and $\tyint$ are disjoint:
\[ \jdis {\alpha \disjoint \tyint} \alpha \tyint \]
After the substitution of $\tyint$ for $\alpha$ on the two types, the sentence
\[ \jdis {\alpha \disjoint \tyint} \tyint \tyint \]
is no longer true since $\tyint$ is clearly not disjoint with itself.
This explains the need to ensure that during type-instantiation the target of the substitution  
is compatible with the disjointness constraint associated with the variable. 

\paragraph{Disjoint substitutions.}
While disjointness cannot be preserved for general substitutions,
if appropriate disjointness pre-conditions are met then disjointess can
be preserved. More formally, the following lemma holds: 

\begin{lemma}[Disjointness is stable under substitution]
  \label{lemma:orthosubst}

  If $(x \disjoint C) \in \Gamma$ and $\jdis \Gamma C D$, 
  then $\jdis {\subst C x \Gamma} {\subst C x A} {\subst C x B}$,
\end{lemma}

\begin{proof}
  By induction on the disjointness derivation of $C$ and $D$.
  Special attention is needed for the variable case, where it is necessary to prove stability
  of substitution for the subtyping relation.
  It is also needed to show that, if $C$ and $D$ do not contain any variable $x$, then it is
  safe to make a substitution in the co-domain of the environment.
\end{proof}

\paragraph{Well-formedness substitution stability.}
Typically polymorphic systems with explicit instantiation are required to show that their
types are stable under substitution, in order to avoid ill-formed types.
In the presence of disjoint quantification, we cannot prove such property.
However, a weaker version of that property -- but strong enough for our type-system's metatheory 
-- can be proven, namely:

\begin{lemma}[Types are stable under substitution]
  \label{lemma:wfsubst}

  If $\jwf \Gamma A$ and $\jwf \Gamma B$ and $(\alpha \disjoint C) \in \Gamma$ 
  and $\jdis \Gamma B C$, then $\jwf {\subst B \alpha \Gamma} {\subst B \alpha A}$.
\end{lemma}
%\begin{restatable}[Instantiation]{lemma}{instantiation}
%  \label{lemma:instantiation}
%
%  If $\jwf {\Gamma, \alpha \disjoint B} C$, $\jwf \Gamma A$, $\jdis \Gamma A B$
%  then $\jwf \Gamma {\subst A \alpha C}$.
%\end{restatable}

\begin{proof}
By induction on the well-formedness derivation of $A$.
The intersection case requires the use of Lemma~\ref{lemma:orthosubst}.
Also, the variable case required proving that if $\alpha$ does not occur free in $A$, and it is safe
to substitute it in the co-domain of $\Gamma$, then it is safe to perform the substitution.
\end{proof}

This lemma enables us to show that all types produced by the type-system are well-typed.
More formally, we have that:

\begin{restatable}[Well-formed typing]{lemma}{wellformedtyping}
  \label{lemma:wellformed-typing}

  If $\jcheck \Gamma e A$, then $\jwf \Gamma A$. 

  If $\jinfer \Gamma e A$, then $\jwf \Gamma A$.
\end{restatable}

\begin{proof}
  By induction on the derivation and applying
  Lemma~\ref{lemma:wfsubst} in the case of \reflabel{\labelttapp}.
\end{proof}

Even though the meta-theory is consistent with the expected results, we might still ask: 
what exactly are the bounds of disjoint quantification?
In other words, which type(s) might be used to allow unrestricted instantiation, and which
one(s) might be used to completely restrict instantiation?
As the reader might expect, the answer is tightely related to subtyping, as we will show next. 

\subsection{Bounds of Disjoint Quantification}
Substitution raises the question of what range of types can be instantiated for a given variable, 
under a given context.
To get a feeling about this, we ask the reader to recall 
Lemma~\ref{lemma:disjointness-covariance}, used to justify the rule for
disjointness of variables.
If one takes $A$ as some variable $\alpha$, then the lemma should read as:   
\[ \inferrule {\jwf \Gamma {\alpha \disjoint B} \\ B \subtype C }
              {\jwf \Gamma {\alpha \disjoint C}} \]
Now we may ask: how many suitable types are there to instantiate $\alpha$ with, depending on $B$?
Before we answer this, let us ask first how many options are there for $C$, depending on the 
shape of $B$?
Given that the cardinality of \name's types is infinite, for the sake of this example we will 
restrict the type universe to a finite number of 
primitive types (i.e. $\tyint$, $\tystring$, etc), disjoint intersections of these types,
$\top$ and $\bot$.
Having this in mind, we can answer the second question: the number of choices for $C$ is directly 
proportional to the number of intersections present in $B$.
For example, taking $B$ as $\tyint$ leads $C$ to be either $\top$ or $\tyint$; whereas $B$ as 
$\tyint \inter \tystring$ leaves $C$ as either $\top$, $\tyint$ or $\tystring$.
However, as the choices for $C$ grows, the less choices we are left to instantiate 
the variable $\alpha$, since $\alpha$ must be disjoint to all possible $C$'s. 
Thus, to answer the first question, the options for instantiating $\alpha$ are inversely proportional 
to the number of intersections present in $B$.
By analogy, one may think of a disjointness constraint as a set of (forbidden) types, where 
primitive types are the singleton set and each $\inter$ is the set union.

We can now turn our attention to the two extreme cases, namely $\top$ 
(i.e. the 0-ary intersection) and $\bot$ (i.e. the infinite intersection) 
\footnote{$\bot$ would not add anything to the hypothetical finite type 
system, however it can be seen as the infinite intersection in \name.}.
Following the same logic, we may conclude that having $\top$ as constraint leaves $\alpha$ with 
the most options for instantiation; whereas $\bot$ will deliver the least options.
This implies that $\top$ is the empty constraint, meaning that a variable associated to it
can be instantiated to any well-formed type.
It is a subtle but very important property, since \name is a generalization of System $F$. 
Any type variable present in a type signature of System $F$, can be represented in \name
equivalently by assigning it a $\top$ disjointness constraint
(as seen in Section~\ref{subsec:disjoint-quantification}).

\begin{comment}
We will briefly discuss the role of the former in our system. 
\joao{maybe we can just refer to the overview and delete the next
  paragraph?}
\bruno{That could be an idea, yes.}

\paragraph{The most liberal bound.}
It is easy to see that $\top$ is the most liberal type since it is disjoint to everything. 
This means that the $\top$ type actually plays an important role in our system, since the latter 
must be complete with respect to System $F$. 
In other words, any program accepted by System $F$ should also be accepted by \name.
Since System $F$ does not contain disjointness quantification, $\top$ comes in handy:
the System $F$'s type $\forall \alpha. {T_F}$ (where ${T_F}$ is some other type), is
equivalent to \name's type $\fordis \alpha \top {T_i}$, where ${T_i}$ is also an equivalent 
translation of $T_{F}$.
An example of such translation has been given in Section~\ref{sec:overview}.
\end{comment}
