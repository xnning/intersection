\section{Disjoint Intersection Types with $\top$}

So far we have discussed a system with intersection types, but we have (intentionally) left out $\top$.
The $\top$ type is not only a supertype of all types, but also the type for 0-ary intersection. 
Unfortunately, introducing $\top$ into our system leads to several drastic consequences:

\begin{itemize}
\item The definition of disjointness becomes useless:
since every type has now a common supertype, it does not exist any pair of two types for which the disjointness relation
holds. Thus, we can no longer build an intersection type.
\item The subtyping relation becomes incoherent: its rules allow us to derive both $\top \subtype \top \inter \top$ and 
$\top \inter \top \subtype \top$.
\end{itemize}

However, by adjusting the definition of disjointness, we can obtain more useful results, while still preserving the
coherence of the subtyping relation.
Even though these are desirable properties, a new definition of disjointess can be formulated in many different ways. 
\joao{expand}

We will first show how we can introduce $\top$ into our system.
Next, a new definition of disjointness will be presented, which we will refer to as $\top$-disjointness, and
we will briefly discuss how it can make the resulting system more useful, while maintaining the correctness
of all properties proven for the original system.
The definition of $\top$-disjointess will depend on a notion of a top-like type, for which at first we will just provide 
some intuition for it.
We will then formalise two different systems, based on two different definitions of a top-like type, while discussing their
usability and limitations.
The first top-like definition will solve the problem of incoherence, but it will still forbid the inclusion of
function types within intersection types.
To face this limitation, we proceed by extending the top-like definition, and showing how the resulting system will become 
more expressive.
We also show, for both systems, how to adjust the algorithmic rules, such that they are consistent with the 
respective disjointess specification.

\subsection{Introducing $\top$}

Introducing the $\top$ type in our system is a fairly straightforward process, as shown in Figure \ref{fig:fi-syntax-top}.

\begin{figure}[t]
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B, C & \Coloneqq & \ldots \mid \highlight{$\top$}  & \\

        \\
        \text{Terms}
        & e & \Coloneqq & \ldots \mid \highlight{$\top$} & \\
      \end{array}
    \end{array}
  \]

  \begin{mathpar}
    \formsub \\
    \rulesubtop 
  \end{mathpar}

  \begin{mathpar}
    \formwf \\
    \rulewftop
  \end{mathpar}

  \begin{mathpar}
    \formt \\
    \rulettop
  \end{mathpar}

  \caption{Extending \name with $\top$.}
  \label{fig:fi-syntax-top}
\end{figure}\bruno{rule form needs to be fixed in typing.}

We start by adding $\top$ to the existing types. 
Similarly, we add the only inhabitant of type $\top$: the term $\top$.
We extend the subtyping relation with \reflabel{\labelsubtop}, declaring that any type is a sub-type of $\top$.
The coercion in the target language, is a function that always returns the term $\top$, regardless of its argument.
We also add $\top$ to the set of well-formed types, by extending the well-formedness relation with \reflabel{\labelwftop}. 
Finally, the typing rule \reflabel{\labelttop} states that, under type inference, the term $\top$ has type $\top$ 
and generates the term \unit in the target language.

However, as discussed in Section \ref{sec:overview}, the definition of disjoitness used so far turns intersection types to
be useless within this new system.
Since every type now has at least one common supertype (namely, $\top$), it is impossible to create an intersection type.
Thus, we need to reformulate that definition, which will do next.

\subsection{Disjointness} 

As we have seen, a new definition of disjointess is needed in order to turn the system more useful.
..
We studied two different disjointness definitions...


Even though we will show two different definitions of $\top$-disjointness, they share the same top-level definition, 
presented next.
\begin{definition}[$\top$-Disjointness]
Given two types $A$ and $B$, 

%\[A * B \equiv \not \toplike{A} \and \not \toplike{A} \and A \subtype B\]
\[A \disjoint_{\top} B \equiv \neg \toplike{A} \; \wedge \; \neg \toplike{B} \; \wedge \; 
\forall_C \; ( A \subtype C \wedge B \subtype C ) \rightarrow \toplike{C}, \]

\end{definition}
where $\toplike{C}$ means that $C$ is a top-like type.
A top-like type is a unary relation at the type level, which we will further specialize into two different definitions. 
However, we can first provide an intuition about this general $\top$-disjointness definition.
Considering that a toplike-type is a type that resembles $\top$ in some way, we define $\top$-disjointness in two steps:
\begin{enumerate}
\item Since the concept of disjointness is inherently connected to the way we wish to form intersection types,
we explicitly state that both $A$ and $B$ cannot be top-like types, preventing types such as $T \inter T$ to be well-formed.
\item Additionaly, if there is any common supertype of $A$ and $B$, that is not top-like, then we want to forbid the 
intersection of these types, since there might be an overlap between them. 
\end{enumerate}

Next we will present two different top-like type definitions and discuss their consequences in the overall resulting system.
We will refer to the first resulting system as \emph{naive} and to the second as \emph{improved}. 

\subsection{A Naive Calculus with $\top$}

As a first definition of top-like, we aim to define it in such a way that it solves the aforementioned coherence problem of
the subtyping relation.
\joao{rephrase this}
Therefore, we first present the top-like definition, formalise the resulting system and  
show how the coherence problem is solved.
Then we will show how the original algorithmic disjointness rules can be modified to match the new $\top$-disjointness
definition.
Finally we will discuss the limitations of resulting system and motivate the need for a refined definition of the top-like 
relation. 

\paragraph{Top-Like Types}

A simple attempt to achieve coherence in the presented system with $\top$ is to forbid any intersection enclosing 
more than one $\top$.
This will ensure that types such as $\top \inter \top$ are not allowed and thus ending with the inconsistency of
$\top \subtype \top \inter \top$ and $\top \inter \top \subtype \top$.
In other words, our system contains only one \emph{syntactic} $\top$, thus ensuring coherence in our system.
\joao{explain this better?}
For a similar reasion, our system forbids types of the form $A \inter \top$, where $A \neq \top$.  
Should our system accept intersections as in $A \inter \top$, then both $A \subtype A \inter \top$ and 
$A \inter \top \subtype A$ would hold (by \reflabel{\labelsubinter} and \reflabel{\labelsubinterl}, respectively).
Therefore, we can introduce the notion of a top-like type that results in forbidding these kind of intersections.

\begin{figure}[h]
  \begin{mathpar}
    \formtoplike \\ %\framebox{$\jatomic A$} \\

    \ruletopltop \and \ruletoplinter

  \end{mathpar}
  \begin{mathpar}
    \formdis \\
    \ruledisinterl \and \ruledisinterr \\ 
    \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    %\ruledisaxintfun \and \ruledisaxtop \and \ruleaxsym
    \ruledisaxintfun \and \ruleaxsym
  \end{mathpar}

  \caption{Top-like types and Algorithmic Disjointness.}
  \label{fig:tltypesdis}
\end{figure}

\begin{definition}[Top-like types]
  Any type consisting of a $n$-ary intersection composed of $n$ $\top$, is a top-like type. 
\end{definition}

We may formalise the notion of top-like type as an unary relation on a type $A$, denoted as $\toplike{A}$, as show in 
Figure \ref{fig:tltypesdis}.
This definition resembles the previous description with two rules.
The ... states that $\top$ is a top-like type; the ... says that any n-ary intersection composed of just $\top$ is also a
top-like type.


%Let us consider a term $t$ with type $Char \inter Int$ and a function $f$ with type $\top \rightarrow Char$.
%The application of $f$ to $x$ could lead to a choice between $Char$ and $Int$ and $Char \inter Int$.
%However, since for any type $A$, $\top \rightarrow A$ is isomorphic to $A$, the choice of the argument should
%not influence coherence. 
%Indeed, our system translates 
%Now, lets change the type of $f$ to $String \rightarrow \top$, and consider a second function $\g$, with type 
%$String \rightarrow Int$.

%Here such definition is made a bit more precise, and
%well-suited to \name.


%since their supertypes are all types with the form $A \to \top$ 
%(where A \emph{contains} \code{Int}, i.e. $\code{Int}$, $\code{Int} \inter \code{Char}$) and $\top$.


%At last, take as an example ($\top \inter \top$).
%In a pure language (i.e. no side-effects), this type can be safely allowed since both components of the merge
%will evaluate to the same value. 
%However, in an effectful language, the evaluation of either the right or left component might lead to distinct results. 
%Following the same reasoning, we might want to allow or restrict, for instance $(String \to Int) \inter (String \to \top)$,  

\paragraph{Algorithmic disjointness rules}

Again, the newly presented definition of $\top$-disjointness does not lead to an implementation. 
Fortunately, the algorithmic disjoitness rules remain the same as described in Section \ref{sec:TODO} 
\joao{fill in section}, except for \reflabel{\labeldisfun}.
The intuition for this is becomes clear with an example.
Take the two function types used as an example in Section \ref{sec:overview}: 
$\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$. 
Should we have \reflabel{\labeldisfun} as a rule, then these two types would be disjoint. 
However, introducing $\top$ into into our system has the consequence of also introducing a new supertype for these 
two functions: $\code{String} \to \top$ (due to function type co-variance). 
This \emph{new} type is not a top-like type - according to the presented definitions - and thus violates one of the
conditions of $\top$-disjointness.

This is clearly a limitation imposed by our definition of $\top$-disjointness - or rather, definition of top-like type - 
for which we will present a solution in the next section.

\subsection{An Improved Calculus with $\top$}

As we have seen, the former definition of top-like types is, unfortunately, too restrictive.
Namely, function types are disallowed within intersection types, which is clearly a limitation from an expressivity
angle.
Let us consider, again, the two function types $\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$. 
According to the original system (i.e. without $\top$) these two types are disjoint since it does not exist
a common supertype of both types. 
%The intersection of these two types could be useful, for instance ... \joao{finish this example}
However, within the improved system, this relationship does not hold anymore since there is a common supertype of both
functions: $String \to \top$.
Therefore, we extend the definition of top-like type to include types of the form $A_k \to \top$.
This will introduce a new ambiguity in our subtyping rules, which will lead us to changing the coercions produced by some
rules.
Finally, we will re-adjust the algorithmic disjointness rules to match the extended $\top$-disjointness definition. 

\paragraph{Top-Like Types}

\begin{figure}[h]
  \begin{mathpar}
    \formtoplike \\ %\framebox{$\jatomic A$} \\

    \ruletopltop \and \ruletoplinter \and \ruletoplfun

  \end{mathpar}
  \begin{mathpar}
    \formdis \\
    \ruledisinterl \and \ruledisinterr \\ 
    \ruledisfun \and \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    %\ruledisaxintfun \and \ruledisaxtop \and \ruleaxsym
    \ruledisaxintfunext \and \ruleaxsym
  \end{mathpar}

  \caption{Top-like types and Algorithmic Disjointness for the improved calculus.}
  \label{fig:tltypesextdis}
\end{figure}

In relation to the previous definition of top-like, we extend it as follows:
\begin{definition}[Top-like types]
  
  A type $A$ is (also) a top-like type, if it has the form $A_k \to \top$, where $k \in {0,1,..}$.
  That is, any type with arity $k$ can be a top-like type, as long as $\top$ is the result type. 

\end{definition}

Now, according to our $\top$-disjointess definition,
$\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$ are disjoint, and thus, their intersection is a 
well-formed type.
The extended top-like definitions and resulting system are formalised in Figure \ref{fig:tltypesextdis}.
Note how we just added \reflabel{\labeltoplfun} to the top-like relation, by stating that a function is top-like whenever
its return type is also top-like.
The rest of the changes will be discussed in the following sections.

%\joao{do we want to allow this?
% f: String $\to$ Int \\ 
% g: String $\to$ T \\
% ($\lam$ h : String $\to$ T. h "") (f ,, g) }

\paragraph{Coercive Subtyping}

In this improved calculus, a new problem arises when generating coercions. \joao{add new rules to the figure}
As a consequence of introducing functions within intersection types, we introduce ambiguity between subtype contributors 
under intersection types.
In other words, Lemma ... no longer holds because, under some contexts, 
\reflabel{\labelsubinterl} and \reflabel{\labelsubinterr} now overlap. 
Let us demonstrate this using an example:
suppose that we want to build a derivation for  
$\code{Int} \to \code{Int} \inter \code{Char} \to \code{Char} \subtype (\code{Int} \inter \code{Char}) \to \top$
Then, we can either derive it to $\code{Int} \to \code{Int} \subtype (\code{Int} \inter \code{Char}) \to \top$ 
(using \reflabel{\labelsubinterl}), or to $\code{Char} \to \code{Char} \subtype (\code{Int} \inter \code{Char}) \to \top$
(using \reflabel{\labelsubinterr}), and thus introducing ambiguity in our system.

Facing this problem, we could solve it at least in two distinct ways:

\begin{itemize}
\item Forbid intersection types that include more than one function type; or
\item Add new rules to the subtyping relation that deal with this situation. 
\end{itemize}

However, a closer to the function rule \joao{reference rule and finish sentence}
Intuitively, generating a $\top$ term is done always the same way, regardless of the form of the argument(s).

Thus we opted to modify the existing rules, to reflect this observation.
Namely, \reflabel{\labelsubinterl} and \reflabel{\labelsubinterr}, since these can generate specialised coercions,
in case $A_3$ is of the form $A_k \to \top$. 
With this assumption over $A_3$, the coercion generated should be a nested number of $\lambda$ equal to $k+1$,
returning $\top$ as the result, regardless of the parameters.
The rules of the subtyping relation therefore only suffered slight changes and we managed to maintain coherence.
Next, we will modify the algorithmic disjointess rules, so that they match the improved top-like specification.

\paragraph{Algorithmic disjointness rules}

Fortunately, the algorithmic disjointness rules are, again, similar to the ones presented in the original system.
In relation to the previous system with $\top$, we placed back $\reflabel{\labeldisfun}$, since we lifted the restriction
of intersections with function types.
We also had to modify $\reflabel{\labeldisaxintfun}$ to include the premise $\neg \toplike{B}$.
This is due to the specification of $\top$-disjointness, which requires two types not to be top-like in order for them to 
be disjoint.

\joao{add a paragraph mentioning the possibility of using two different definitions of top-like in T-disjointness, so we can get a DisAx-Int-Fun with no premise?}

