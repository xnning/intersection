\section{Disjoint Intersection Types with $\top$}

This section shows how to add a $\top$ type to \name.
%So far we have discussed a system with intersection types, but we have (intentionally) left out $\top$.
%The $\top$ type is not only a supertype of all types, but also the type for 0-ary intersection. 
%Unfortunately, introducing $\top$ into our system leads to several
%drastic consequences:
Introducing $\top$ poses some important challenges. Most prominently,
the simple definition of disjointness is useless in the presence of
$\top$. Since all types now have a common supertype, it is impossible
for any two types to satisfy a simple notion of disjointness. To
address this problem a notion of $\top$-disjointess is proposed.  The
definition of $\top$-disjointess depends on a notion of a top-like
type. We formalise two different variants of \name, based on two different
definitions of a top-like type, while discussing their usability and
limitations. Both variants retain coherence, and all other key
properties of \name. 
Mechanized Coq proofs for both variants are available as part of the 
supplementary materials for the paper.


%\begin{itemize}
%\item The definition of disjointness becomes useless:
%since every type has now a common supertype, it does not exist any pair of two types for which the disjointness relation
%holds. Thus, we can no longer build an intersection type.
%\item The subtyping relation becomes incoherent: its rules allow us to derive, for example, both 
%$\top \subtype \top \inter \top$ and $\top \inter \top \subtype \top$.
%\end{itemize}

\begin{comment}
However, by adjusting the definition of disjointness, we can obtain more useful results, while still preserving the
coherence of the subtyping relation.
Even though these are desirable properties, a new definition of disjointess can be formulated in many different ways. 
\joao{expand}

We will first show how we can introduce $\top$ into our system.
Next, a new definition of disjointness will be presented - which we will refer to as $\top$-disjointness - and
we will briefly discuss how it can make the resulting system more useful, while maintaining the correctness
of all properties proven for the original system.
The definition of $\top$-disjointess will depend on a notion of a top-like type, for which at first we will just provide 
some intuition for it.
We will then formalise two different systems, based on two different definitions of a top-like type, while discussing their
usability and limitations.
The first top-like definition will solve the problem of incoherence, but it will still forbid the inclusion of
function types within intersection types.
To face this limitation, we proceed by extending the top-like definition, and showing how the resulting system will become 
more expressive.
We also show, for both systems, how to adjust the algorithmic disjointness rules such that they become consistent with the 
respective disjointess specification.
\end{comment}

\subsection{Introducing $\top$}

\begin{figure}[t]
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B, C & \Coloneqq & \ldots \mid \highlight{$\top$}  & \\

        \\
        \text{Terms}
        & e & \Coloneqq & \ldots \mid \highlight{$\top$} & \\
      \end{array}
    \end{array}
  \]

  \begin{mathpar}
    \formsub \\
    \rulesubtop 
  \end{mathpar}

  \begin{mathpar}
    \formwf \\
    \rulewftop
  \end{mathpar}

  \begin{mathpar}
    \formbi \\
    \rulettop
  \end{mathpar}

  \begin{mathpar}
    \framebox{$\im A = T$} \\
    \im \top = \unit \\
  \end{mathpar}

  \caption{Extending \name with $\top$.}
  \label{fig:fi-syntax-top}
\end{figure}

Introducing the $\top$ type in \name is a straightforward process, as shown in Figure \ref{fig:fi-syntax-top}.
We start by adding $\top$ to the existing types. 
Similarly, we add the only inhabitant of type $\top$: the term $\top$.
We extend the subtyping relation with \reflabel{\labelsubtop}, declaring that any type is a sub-type of $\top$.
The coercion in the target language, is a function that always returns the term $\top$, regardless of its argument.
We also add $\top$ to the set of well-formed types by extending the well-formedness relation with \reflabel{\labelwftop}. 
Finally, the typing rule \reflabel{\labelttop} states that, under type inference, the term $\top$ has type $\top$ 
and generates the term $\unit$ in the target language.

%However, as discussed in Section \ref{sec:overview}, the definition of disjointness used so far turns intersection types to
%be useless within this new system.
%Since every type now has at least one common supertype (namely, $\top$), it is impossible to create an intersection type.
%Thus, we need to reformulate that definition, as presented next. 

\subsection{Disjointness} 
As discussed in Section \ref{sec:overview}, the definition of
simple disjointness is useless when \name is extended with $\top$.
We opted to differentiate \emph{top-like} types from the rest of the types,
so that we may impose restrictions related to the former, since they are the 
root of the problems exposed.
For now, we will omit the formal definition of a \emph{top-like} type, and informally
define it as a type that resembles $\top$ in some way. 
Having this in mind, we defined $\top$-disjointness as follows:
%Even though we will show two different definitions of $\top$-disjointness, they share the same top-level definition, 
%presented next.
\begin{definition}[$\top$-Disjointness]
Given two types $A$ and $B$ we have that:

%\[A * B \equiv \not \toplike{A} \and \not \toplike{A} \and A \subtype B\]
\[A \disjoint_{\top} B \equiv \neg \toplike{A} \; \wedge \; \neg \toplike{B} \; \wedge \; 
\forall_C \; ( A \subtype C \wedge B \subtype C ) \rightarrow \toplike{C} \]

\end{definition}
\noindent where $\toplike{C}$ means that $C$ is a top-like type.
A top-like type is thus a unary relation at the type level, which we will further specialise into two different definitions. 
However, we can first provide an intuition about this general $\top$-disjointness definition, in two steps:
\begin{enumerate}
\item The concept of disjointness is inherently connected to the way we wish to form intersection types thus,
we explicitly state that both $A$ and $B$ cannot be top-like types (i.e. preventing types such as $T \inter T$ to be well-formed).
\item Additionaly, if there is any common supertype of $A$ and $B$, that is not top-like, then we want to forbid the 
intersection of these types, since there might be an overlap between them. 
\end{enumerate}

Next we will present a simple top-like type definition and show how resulting system
becomes more expressive while achieving coherence.
However, we still consider that system not to be expressive enough, 
so we will introduce later an extended definition of the top-like type relation.
We will refer to the first system as \emph{naive} and to the second as \emph{improved}. 

\subsection{A Naive Calculus with $\top$}

As a first definition of top-like, we aim to solve the aforementioned coherence problem of the subtyping relation.
With the original disjointness specification, we could prove that $\top \subtype \top \inter \top$ and $\top \inter \top \subtype \top$, leading to incoherence in our system. 
Also, this hints that the type system has more than one \emph{syntactical} $\top$,
meaning that any n-ary intersection composed by $\top$'s, is a super-type of all other
types.
This is obviously undesirable and we show how we could tackle this problem, using a
suitable top-like definition together with the $\top$-disjointness definition.

We first present the top-like definition, formalise the resulting system and  
show how the coherence problem is solved.
Then we will show how the original algorithmic disjointness rules can be modified to match the new $\top$-disjointness
definition.
Finally we will discuss the limitations of resulting system and motivate the need for a refined definition of the top-like 
relation. 

\paragraph{Top-Like Types}

A simple attempt to achieve coherence in the presented system with $\top$ is to forbid any intersection enclosing 
more than one $\top$.
This will ensure that types such as $\top \inter \top$ are not well-formed and thus ending with the inconsistency of
$\top \subtype \top \inter \top$ and $\top \inter \top \subtype \top$.
In other words, our system contains only one \emph{syntactic} $\top$. 
\joao{explain this better?}
For a similar reasion, our system forbids types of the form $A \inter \top$, where $A \neq \top$.  
Should our system accept these kind of intersections, then both $A \subtype A \inter \top$ and 
$A \inter \top \subtype A$ would hold (by \reflabel{\labelsubinter} and \reflabel{\labelsubinterl}, respectively).
Therefore, we can finally describe the notion top-like type, that results in forbidding these kind of intersections.

\begin{figure}[h]
  \begin{mathpar}
    \formtoplike \\ %\framebox{$\jatomic A$} \\

    \ruletopltop \and \ruletoplinter

  \end{mathpar}
  \begin{mathpar}
    \formdis \\
    \ruledisinterl \and \ruledisinterr \\ 
    \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    %\ruledisaxintfun \and \ruledisaxtop \and \ruleaxsym
    \ruledisaxintfun \and \ruleaxsym
  \end{mathpar}

  \caption{Top-like types and Algorithmic Disjointness.}
  \label{fig:tltypesdis}
\end{figure}

\begin{definition}[Top-like types]
  Any type consisting of a $n$-ary intersection composed of $n$ $\top$'s, is a top-like type. 
\end{definition}

We may formalise the notion of top-like type as an unary relation on a type $A$, denoted as $\toplike{A}$, as show in 
Figure \ref{fig:tltypesdis}.
This definition resembles the previous description with two rules.
The \reflabel{\labeltopltop} states that $\top$ is a top-like type; 
the \reflabel{\labeltoplinter} indicates that any n-ary intersection composed of just $\top$ is also a top-like type.


%Let us consider a term $t$ with type $Char \inter Int$ and a function $f$ with type $\top \rightarrow Char$.
%The application of $f$ to $x$ could lead to a choice between $Char$ and $Int$ and $Char \inter Int$.
%However, since for any type $A$, $\top \rightarrow A$ is isomorphic to $A$, the choice of the argument should
%not influence coherence. 
%Indeed, our system translates 
%Now, lets change the type of $f$ to $String \rightarrow \top$, and consider a second function $\g$, with type 
%$String \rightarrow Int$.

%Here such definition is made a bit more precise, and
%well-suited to \name.


%since their supertypes are all types with the form $A \to \top$ 
%(where A \emph{contains} \code{Int}, i.e. $\code{Int}$, $\code{Int} \inter \code{Char}$) and $\top$.


%At last, take as an example ($\top \inter \top$).
%In a pure language (i.e. no side-effects), this type can be safely allowed since both components of the merge
%will evaluate to the same value. 
%However, in an effectful language, the evaluation of either the right or left component might lead to distinct results. 
%Following the same reasoning, we might want to allow or restrict, for instance $(String \to Int) \inter (String \to \top)$,  

\paragraph{Algorithmic disjointness rules}

Again, the newly presented definition of $\top$-disjointness does not lead to an implementation. 
Fortunately, the algorithmic disjoitness rules remain the same as described in Section \ref{sec:TODO} 
\joao{fill in section}, except for \reflabel{\labeldisfun}.
The intuition for this becomes clear with an example.
Take the two function types used as an example in Section \ref{sec:overview}: 
$\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$. 
Should we have \reflabel{\labeldisfun} as a rule, then these two types would be disjoint. 
However, introducing $\top$ into into our system has the consequence of also introducing a new supertype for these 
two functions: $\code{String} \to \top$ (due to function type co-variance). 
This \emph{new} type is not a top-like type - according to the presented definitions - and thus violates one of the
conditions of $\top$-disjointness.

This is clearly a limitation imposed by our definition of $\top$-disjointness - or rather, definition of top-like type - 
for which we will present a solution in the next section.

\subsection{An Improved Calculus with $\top$}

The former definition of top-like types is, unfortunately, too restrictive.
Namely, function types are disallowed within intersection types, which is clearly a limitation from an expressivity
angle.
Let us consider, again, the two function types $\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$. 
In a system without $\top$, these two types would be disjoint.
However, according to our $\top$-disjointness definition, these two types are not disjoint in the naive system, since they have a 
common super-type which is not top-like:
%The intersection of these two types could be useful, for instance ... \joao{finish this example}
$\code{String} \to \top$.
This new supertype is a direct consequence of introducing $\top$ intro our system,
and we argue that it is acting also as a top-like type: it represents a function that produces
$\top$, no matter what argument it is given.
Therefore, we will extend the definition of top-like type to include types of the form $A_k \to \top$.
This will introduce a new ambiguity in our subtyping rules, which will lead us to changing the coercions produced by some
of them.
Similarly to the naive system, we will also need to re-adjust the algorithmic disjointness rules to match the 
extended $\top$-disjointness definition. 

\paragraph{Top-Like Types}

\begin{figure}[h]
  \begin{mathpar}
    \formtoplike \\ %\framebox{$\jatomic A$} \\

    \ruletopltop \and \ruletoplinter \and \ruletoplfun

  \end{mathpar}
  \begin{mathpar}
    \formdis \\
    \ruledisinterl \and \ruledisinterr \\ 
    \ruledisfun \and \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    %\ruledisaxintfun \and \ruledisaxtop \and \ruleaxsym
    \ruledisaxintfunext \and \ruleaxsym
  \end{mathpar}

  \caption{Top-like types and Algorithmic Disjointness for the improved calculus.}
  \label{fig:tltypesextdis}
\end{figure}

In relation to the previous definition of top-like, we extend it as follows:
\begin{definition}[Top-like types]
  
  A type $A$ is (also) a top-like type, if it has the form $A_k \to \top$, where $k \in {0,1,..}$.
  That is, any type with arity $k$ can be a top-like type, as long as $\top$ is the result type. 

\end{definition}

Now, according to our $\top$-disjointess definition,
$\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$ are disjoint and their intersection is a 
well-formed type.
The extended top-like definitions and resulting system are formalised in Figure \ref{fig:tltypesextdis}.
Note how we just added \reflabel{\labeltoplfun} to the top-like relation, by stating that a function is top-like whenever
its return type is also top-like.
The rest of the changes will be discussed in the following sections.

%\joao{do we want to allow this?
% f: String $\to$ Int \\ 
% g: String $\to$ T \\
% ($\lam$ h : String $\to$ T. h "") (f ,, g) }

\paragraph{Coercive Subtyping}

In this improved calculus, a new problem arises when generating coercions. \joao{add new rules to the figure}
As a consequence of introducing functions within intersection types, we introduce ambiguity between subtype contributors 
under intersection types.
In other words, Lemma ... no longer holds because, under some contexts, 
\reflabel{\labelsubinterl} and \reflabel{\labelsubinterr} now overlap. 
Let us demonstrate this using an example:
suppose that we want to build a derivation for  
$\code{Int} \to \code{Int} \inter \code{Char} \to \code{Char} \subtype (\code{Int} \inter \code{Char}) \to \top$
Then, we can either derive it to $\code{Int} \to \code{Int} \subtype (\code{Int} \inter \code{Char}) \to \top$ 
(using \reflabel{\labelsubinterl}), or to $\code{Char} \to \code{Char} \subtype (\code{Int} \inter \code{Char}) \to \top$
(using \reflabel{\labelsubinterr}), and thus introducing ambiguity in our system.

Facing this problem, we could solve it at least in two distinct ways:

\begin{itemize}
\item Forbid intersection types that include more than one function type; or
\item Add new rules to the subtyping relation that deal with this situation. 
\end{itemize}

We could opt for the easy way and go with the former option.
However, taking a closer look to \reflabel{\labeldisfun} (the next step in one of the two derivations), reveals that both coercions generated will $\beta$-reduce to the same term. 
To illustrate this, suppose we are deriving $(A_k \to A) \inter (B_k \to B) \subtype C_k \to \top$.
The coercions generated will be either $\lambda y. E_1 (proj_1 y)$ and $\lambda y. E_2 (proj_2 y)$, depending which intersection rule we choose.
However, $E_1$ and $E_2$ will both turnout to be of the form $\lambda f_1. \lambda x_1. ... (\lambda f_k. \lambda x_k (\lambda e. \unit)...) (...)$, which $\beta$-reduces to $\lambda f_1. \lambda x_1. ... \lambda x_k. ()$.
Performing substitution and one $\beta$ reduction step in either of the former 
coercions leaves us with 
$\lambda x. \lambda x_1... \lambda x_k. \unit$.
%This is $\beta$-equivalent to a coercion function that accepts the source type 
%plus $C_k$ as arguments and returns $\top$. 
Intuitively, this means there is only one way of generating a $\top$ term, regardless of the form of the argument(s).

So we opted to modify the existing rules to reflect this observation.
Namely, \reflabel{\labelsubinterl} and \reflabel{\labelsubinterr}, since these can generate specialised coercions,
in case $A_3$ is of the form $A_k \to \top$. 
\joao{show rules}
With this assumption over $A_3$, the coercion generated should be a nested number of $\lambda$ equal to $k+1$,
returning $\top$ as the result, regardless of the parameters.
The rules of the subtyping relation therefore only suffered slight changes and we managed to maintain coherence.
%Next, we will modify the algorithmic disjointess rules, so that they match the improved top-like specification.

\paragraph{Algorithmic disjointness rules}

Fortunately, the algorithmic disjointness rules are, again, similar to the ones presented in the original system.
In relation to the previous system with $\top$, we placed back $\reflabel{\labeldisfun}$, since we lifted the restriction
of intersections with function types.
We also had to modify $\reflabel{\labeldisaxintfun}$ to include the premise $\neg \toplike{B}$.
This is due to the specification of $\top$-disjointness, which requires two types not to be top-like in order for them to 
be disjoint.

\joao{add a paragraph mentioning the possibility of using two different definitions of top-like in T-disjointness, so we can get a DisAx-Int-Fun with no premise?}

\joao{mention that everything has been proved in Coq?}
