\section{Disjoint Intersection Types with $\top$}

This section shows how to add a $\top$ type to \name.
%So far we have discussed a system with intersection types, but we have (intentionally) left out $\top$.
%The $\top$ type is not only a supertype of all types, but also the type for 0-ary intersection. 
%Unfortunately, introducing $\top$ into our system leads to several
%drastic consequences:
Introducing $\top$ poses some important challenges. Most prominently,
the simple definition of disjointness is useless in the presence of
$\top$. Since all types now have a common supertype, it is impossible
for any two types to satisfy a simple notion of disjointness. To
address this problem a notion of $\top$-disjointess is proposed.  The
definition of $\top$-disjointess depends on a notion of a top-like
type. We formalise two different variants of \name, based on two different
definitions of a top-like type, while discussing their usability and
limitations. Both variants retain coherence, and all other key
properties of \name. 
Mechanized Coq proofs for both variants are available as part of the 
supplementary materials for the paper.


%\begin{itemize}
%\item The definition of disjointness becomes useless:
%since every type has now a common supertype, it does not exist any pair of two types for which the disjointness relation
%holds. Thus, we can no longer build an intersection type.
%\item The subtyping relation becomes incoherent: its rules allow us to derive, for example, both 
%$\top \subtype \top \inter \top$ and $\top \inter \top \subtype \top$.
%\end{itemize}

\begin{comment}
However, by adjusting the definition of disjointness, we can obtain more useful results, while still preserving the
coherence of the subtyping relation.
Even though these are desirable properties, a new definition of disjointess can be formulated in many different ways. 
\joao{expand}

We will first show how we can introduce $\top$ into our system.
Next, a new definition of disjointness will be presented - which we will refer to as $\top$-disjointness - and
we will briefly discuss how it can make the resulting system more useful, while maintaining the correctness
of all properties proven for the original system.
The definition of $\top$-disjointess will depend on a notion of a top-like type, for which at first we will just provide 
some intuition for it.
We will then formalise two different systems, based on two different definitions of a top-like type, while discussing their
usability and limitations.
The first top-like definition will solve the problem of incoherence, but it will still forbid the inclusion of
function types within intersection types.
To face this limitation, we proceed by extending the top-like definition, and showing how the resulting system will become 
more expressive.
We also show, for both systems, how to adjust the algorithmic disjointness rules such that they become consistent with the 
respective disjointess specification.
\end{comment}

\subsection{Introducing $\top$}

\begin{figure}[t]
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B, C & \Coloneqq & \ldots \mid \highlight{$\top$}  & \\

        \\
        \text{Terms}
        & e & \Coloneqq & \ldots \mid \highlight{$\top$} & \\
      \end{array}
    \end{array}
  \]

  \begin{mathpar}
    \formsub \\
    \rulesubtop 
  \end{mathpar}

  \begin{mathpar}
    \formwf \\
    \rulewftop
  \end{mathpar}

  \begin{mathpar}
    \formbi \\
    \brulettop
  \end{mathpar}

  \begin{mathpar}
    \framebox{$\im A = T$} \\
    \im \top = \unit \\
  \end{mathpar}

  \caption{Extending \name with $\top$.}
  \label{fig:fi-syntax-top}
\end{figure}

Introducing the $\top$ type in \name is a straightforward process, as shown in Figure \ref{fig:fi-syntax-top}.
We start by adding $\top$ to the existing types. 
Similarly, we add the only inhabitant of type $\top$: the term $\top$.
We extend the subtyping relation with \reflabel{\labelsubtop}, declaring that any type is a sub-type of $\top$.
The coercion in the target language, is a function that always returns the term $\top$, regardless of its argument.
We also add $\top$ to the set of well-formed types by extending the well-formedness relation with \reflabel{\labelwftop}. 
Finally, the typing rule \reflabel{\labelttop} states that, under type inference, the term $\top$ has type $\top$ 
and generates the term $\unit$ in the target language.

%However, as discussed in Section \ref{sec:overview}, the definition of disjointness used so far turns intersection types to
%be useless within this new system.
%Since every type now has at least one common supertype (namely, $\top$), it is impossible to create an intersection type.
%Thus, we need to reformulate that definition, as presented next. 

\subsection{Disjointness} 
As discussed in Section \ref{sec:overview}, the definition of
simple disjointness is useless when \name is extended with $\top$.
Not only we cannot build any more intersection types but also we have turned the system incoherent.
For instance, we can prove that $\top \subtype \top \inter \top$ and $\top \inter \top \subtype \top$. 
Also, this hints that the type system has more than one \emph{syntactical} $\top$.
Indeed any n-ary intersection composed by $\top$'s, is a super-type of all other
types.

For these reasons, we opted to differentiate \emph{top-like} types from the rest of the types,
so that we may impose restrictions related to the former.
For now, we will omit the formal definition of a \emph{top-like} type and informally
define it as a type that resembles $\top$ in some way. 
Having this in mind, we define $\top$-disjointness as follows:
%Even though we will show two different definitions of $\top$-disjointness, they share the same top-level definition, 
%presented next.
\begin{definition}[$\top$-Disjointness]
Given two types $A$ and $B$ we have that:

%\[A * B \equiv \not \toplike{A} \and \not \toplike{A} \and A \subtype B\]
\[A \disjoint_{\top} B \equiv \neg \toplike{A} \; \wedge \; \neg \toplike{B} \; \wedge \; 
\forall_C \; ( A \subtype C \wedge B \subtype C ) \rightarrow \toplike{C} \]

\end{definition}
\noindent where $\toplike{C}$ means that $C$ is a top-like type.
A top-like type is thus a unary relation at the type level, which we will further specialise into two different definitions. 
However, we can first provide an intuition about this general $\top$-disjointness definition, given two
types $A$ and $B$:
\begin{enumerate}
\item $A$ and $B$ cannot be top-like types (i.e. preventing types such as $T \inter T$ to be well-formed).
\item If there is any common supertype of $A$ and $B$, that is not top-like, then 
intersection of these types is forbidden, as there might be an overlap between them. 
\end{enumerate}

Next, we will discuss two suitable definitions of top-like and discuss their consequences in a system with
$\top$-disjointess.
%Next we will present a simple top-like type definition and show how resulting system
%becomes more expressive while achieving coherence.
%However, we still consider that system not expressive enough, 
%so an extended definition of the top-like type relation will be presented (also the resulting system).
We will refer to the first system as \emph{naive} and to the second as \emph{improved}. 

\subsection{A Naive Calculus with $\top$}

Initally we aim to solve the exposed problems in a simple manner,  
by forbidding all types consisting of an n-ary intersection of $\top$'s.
This will lift (most of) the restrictions imposed on building intersection types while retaining coherence,
since we are left with only one syntactical $\top$.
However, we are left with one restriction: it is still not possible to build an intersection out of two function types.
To illustrate this, take both function types used as an example in Section \ref{sec:overview}: 
$\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$. 
In a system without $\top$, these two would be disjoint. 
However, introducing $\top$ into the system leads to the existence of a new supertype for these 
two functions: $\code{String} \to \top$ (due to function type co-variance). 
This restriction will be lifted in the extended calculus.
For now, we will present the top-like definition and formalise the resulting system. 
We will also show how the original algorithmic disjointness rules can be modified to match the new $\top$-disjointness
definition.

%Finally we will discuss the limitations of resulting system and motivate the need for a refined definition of the top-like 
%relation. 

\paragraph{Top-Like Types}

We want to ensure that types such as $\top \inter \top$ are not well-formed so that both 
$\top \subtype \top \inter \top$ and $\top \inter \top \subtype \top$ no longer hold.
For a similar reason, the system should not allow types of the form $A \inter \top$, where $A \neq \top$.  
Should our system accept these, then both $A \subtype A \inter \top$ and 
$A \inter \top \subtype A$ would hold (by \reflabel{\labelsubinter} and \reflabel{\labelsubinterl}, respectively).
Therefore we can describe the notion of a top-like type as follows: 

\begin{figure}[h]
  \begin{mathpar}
    \formtoplike \\ %\framebox{$\jatomic A$} \\

    \ruletopltop \and \ruletoplinter

  \end{mathpar}
  \begin{mathpar}
    \formdis \\
    \ruledisinterl \and \ruledisinterr \\ 
    \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    %\ruledisaxintfun \and \ruledisaxtop \and \ruleaxsym
    \ruledisaxintfun \and \ruleaxsym
  \end{mathpar}

  \caption{Top-like types and Algorithmic Disjointness.}
  \label{fig:tltypesdis}
\end{figure}

\begin{definition}[Top-like types]
  Any type consisting of a $n$-ary intersection composed of $n$ $\top$'s, is a top-like type. 
\end{definition}

A top-like type can be formalised as an unary relation on a type $A$, denoted as $\toplike{A}$, as show in 
Figure \ref{fig:tltypesdis}.
This definition resembles the previous description with two rules.
The rule \reflabel{\labeltopltop} states that $\top$ is a top-like type; 
the rule \reflabel{\labeltoplinter} indicates that any n-ary intersection composed of just $\top$'s is also a top-like type.
This top-like definition, together with $\top$-disjointness, 
succeeds in excluding all types of the form $A \inter B$, where $A = \top$ or $B = \top$.
Thus, we are left with one only \emph{syntactical} $\top$ and consequently solved the coherence problem.
%However, the current system still has a substantial limitation: 
%we cannot construct an intersection out of two function types. 
%This will become evident while explaining the algorithmic disjointness rules, in the following section.
%Let us consider a term $t$ with type $Char \inter Int$ and a function $f$ with type $\top \rightarrow Char$.
%The application of $f$ to $x$ could lead to a choice between $Char$ and $Int$ and $Char \inter Int$.
%However, since for any type $A$, $\top \rightarrow A$ is isomorphic to $A$, the choice of the argument should
%not influence coherence. 
%Indeed, our system translates 
%Now, lets change the type of $f$ to $String \rightarrow \top$, and consider a second function $\g$, with type 
%$String \rightarrow Int$.

%Here such definition is made a bit more precise, and
%well-suited to \name.


%since their supertypes are all types with the form $A \to \top$ 
%(where A \emph{contains} \code{Int}, i.e. $\code{Int}$, $\code{Int} \inter \code{Char}$) and $\top$.


%At last, take as an example ($\top \inter \top$).
%In a pure language (i.e. no side-effects), this type can be safely allowed since both components of the merge
%will evaluate to the same value. 
%However, in an effectful language, the evaluation of either the right or left component might lead to distinct results. 
%Following the same reasoning, we might want to allow or restrict, for instance $(String \to Int) \inter (String \to \top)$,  

\paragraph{Algorithmic disjointness rules}

Similarly to the orginal system, the definition $\top$-disjointness does not lead to an implementation. 
Fortunately, the algorithmic disjoitness rules remain the same as described in Section \ref{sec:sec:alg-dis}, 
except for \reflabel{\labeldisfun}.
This is due to the problem previously exposed: two function types now always have a common supertype - which is not
toplike - so it is not possible that they are disjoint. 

%This is clearly a limitation imposed by our definition of $\top$-disjointness - or rather, definition of top-like type - 
%for which we will present a solution in the next section.

\subsection{An Improved Calculus with $\top$}

The former definition of top-like types is, unfortunately, too restrictive.
Namely, function types are disallowed within intersection types, which is clearly a limitation from an expressivity
angle.
As we have seen, both function types $\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$ have a new
supertype: 
$\code{String} \to \top$.
This new supertype is a direct consequence of introducing $\top$ intro our system,
and we argue that it is acting also as a top-like type: it represents a function that produces
$\top$, no matter what argument it is given.
More generally, any type of the form $A_k \to \top$ (with $k \in \mathbb{N}$), can be considered a top-like type.
We will extend the definition of top-like type to include types of that form. 
This will introduce a new ambiguity in our subtyping rules, which will lead us to changing the coercions produced by some of these.
Similarly to the naive system, we will show how to re-adjust the algorithmic disjointness rules to match the 
extended $\top$-disjointness definition. 

\paragraph{Top-Like Types}

\begin{figure}[h]
  \begin{mathpar}
    \formtoplike \\ %\framebox{$\jatomic A$} \\

    \ruletopltop \and \ruletoplinter \and \ruletoplfun
  \end{mathpar}

  \begin{mathpar}
    \formsub \\
    \rulesubinterlcoerce \and \rulesubinterrcoerce
  \end{mathpar}

  \begin{mathpar}
    \formdis \\
    \ruledisinterl \and \ruledisinterr \\ 
    \ruledisfun \and \ruledisatomic
  \end{mathpar}

  \begin{mathpar}
    \formax \\
    %\ruledisaxintfun \and \ruledisaxtop \and \ruleaxsym
    \ruledisaxintfunext \and \ruleaxsym
  \end{mathpar}

  \caption{Top-like types, Subtyping (changed rules only) and Algorithmic Disjointness for the improved calculus.}
  \label{fig:tltypesextdis}
\end{figure}

\begin{figure}[t]
  \framebox{$\andcoerce{A}_{C} = t$}
  \[
  \andcoerce{A}_{C} = 
  \begin{cases} 
        \toplike{A} & \andcoerce{A} \\ 
        %A = \top & \top \\
        %A = A_1 \to A_2 \; \wedge \; \toplike{A_2} & \lam x \andcoerce{A_2}_{C} \\
        \text{otherwise} & {C} 
  \end{cases}
  \]

  \framebox{$\andcoerce{A} = t$}
  \[
  \andcoerce{A} = 
  \begin{cases} 
        A = \top & \top \\
        A = A_1 \to A_2 & \lam x \andcoerce{A_2} \\
  \end{cases}
  \]


  %\begin{align*}
  %  \erase {i}                  &= i \\
  %  \erase {x}                  &= x \\
  %  \erase {\lam x E}           &= \lam x {\erase E} \\
  %  \erase {\app {e_1} {e_2}}   &= {\erase {e_1}} ({\erase {e_2}}) \\
  %  \erase {{x_1} ,, {x_2}}     &= {\erase {x_1}} \, ,, \, {\erase {x_2}} \\
  %  \erase {e : A}              &= {\erase e} \\
  %\end{align*}
  \caption{Coercion considering intersection of top-like types.}
  \label{fig:andcoercion}
\end{figure}

In relation to the previous definition of top-like, we extend it as follows:
\begin{definition}[Top-like types]
  
  A type $A$ is (also) a top-like type, if it has the form $A_k \to \top$, where $k \in \mathbb{N}$. 
  That is, any type with arity $k$ can be a top-like type, as long as $\top$ is the result type. 

\end{definition}

Now, according to our $\top$-disjointess definition,
$\code{String} \to \code{Int}$ and $\code{String} \to \code{String}$ are disjoint and their intersection is a 
well-formed type.
The extended top-like definitions and resulting system are formalised in Figure \ref{fig:tltypesextdis}.
Note how we just added \reflabel{\labeltoplfun} to the top-like relation, by stating that a function is top-like whenever
its return type is also top-like.
The rest of the changes will be discussed in the following sections.

%\joao{do we want to allow this?
% f: String $\to$ Int \\ 
% g: String $\to$ T \\
% ($\lam$ h : String $\to$ T. h "") (f ,, g) }

\paragraph{Coercive Subtyping}

In this improved calculus, a new problem arises when generating coercions. 
Introducing functions within intersection types leads to ambiguity between subtype contributors 
under intersection types.
In other words, Lemma ... no longer holds because, under some contexts, 
\reflabel{\labelsubinterl} and \reflabel{\labelsubinterr} now overlap. 
Let us demonstrate this using an example:
suppose that we want to build a derivation for  
$\code{Int} \to \code{Int} \inter \code{Char} \to \code{Char} \subtype (\code{Int} \inter \code{Char}) \to \top$
Then, we can either derive it to $\code{Int} \to \code{Int} \subtype (\code{Int} \inter \code{Char}) \to \top$ 
(using \reflabel{\labelsubinterl}), or to $\code{Char} \to \code{Char} \subtype (\code{Int} \inter \code{Char}) \to \top$
(using \reflabel{\labelsubinterr}), and thus introducing ambiguity in our system.
We could solve this problem at least in two distinct ways:

\begin{itemize}
\item Forbid intersection types that include more than one function type; or
\item Adjust the subtyping relation to relax its contraints. 
\end{itemize}

Certainly, the first option would be an easy way out, but the system would not be as expressive as desired.
However, the second option would require changing the existing rules.
Namely, \reflabel{\labelsubinterl} and \reflabel{\labelsubinterr} should be specialised into four rules, depending
whether $A_3$ is toplike or not.
We argue that this would not be very elegant, especially for formalizing the properties of the resulting system.
Instead, we observed that, in case $A_3$ is a top-like type, the same coercion could be generated regardless of 
the rule that is chosen.
%However, taking a closer look to \reflabel{\labeldisfun} (the next step in one of the two derivations), reveals that both coercions generated will $\beta$-reduce to the same term. 
%To illustrate this, suppose we are deriving $(A_k \to A) \inter (B_k \to B) \subtype C_k \to \top$.
%The coercions generated will be either $\lambda y. E_1 (proj_1 y)$ and $\lambda y. E_2 (proj_2 y)$, depending which intersection rule we choose.
%However, $E_1$ and $E_2$ will both be of the form $\lambda f_1. \lambda x_1. ... (\lambda f_k. \lambda x_k (\lambda e. \unit)...) (...)$ - a term that $\beta$-reduces to $\lambda f_1. \lambda x_1. ... \lambda x_k. ()$.
%Performing substitution and one $\beta$ reduction step in either of the former 
%coercions lead to the following term  
%$\lambda y. \lambda x_1... \lambda x_k. \unit$.
Indeed, there is only one way of generating a $\unit$ term, regardless of the form of the argument(s).

So we opted to modify existing rules to reflect this observation, as shown in Figure \ref{fig:tltypesextdis}.
%Namely, \reflabel{\labelsubinterl} and \reflabel{\labelsubinterr}, include a new premisse, ensuring that 
%the coercion can be produced the original way, as long as $A_3$ is not top-like. 
%On the other hand, in case that $A_3$ is top-like (and well-formed) then $A_3$ must be of the form $A_k \to \top$. 
%With this assumption over $A_3$, we know that the coercion generated should be a nested number of $\lambda$ equal to $k+1$,
%returning $\unit$ as the result, regardless of the parameters.
%These leads to two new rules, \reflabel{\labelsubintertopl} and \reflabel{\labelsubintertopr}.
Both \reflabel{\labelsubinterl} and \reflabel{\labelsubinterr} generate coercions that take the source term 
as argument produce either:
\begin{itemize}
\item in case $\toplike{A_3}$: a function with the same arity of $A_3$, returning $\unit$;  
\item otherwise: the same coercion as in the previous systems.
\end{itemize}
This behaviour is formalised with a function at the type-level, denoted as $\andcoerce{A}_{C}$, as described in
Figure~\ref{fig:andcoercion}.

Finally, the reader might notice how the modified rules still overlap, in case $\toplike{A_3}$. 
In this case both rules can be used interchangeably as they both lead to the same coercion.
The rules of the subtyping relation therefore only suffered slight changes while retaining coherence.
%Next, we will modify the algorithmic disjointess rules, so that they match the improved top-like specification.

\paragraph{Algorithmic disjointness rules}

Fortunately, the algorithmic disjointness rules are, again, similar to the ones presented in the original system.
In relation to the naive system with $\top$ we placed back $\reflabel{\labeldisfun}$, since we lifted the restriction
of intersections with function types.
We also had to modify $\reflabel{\labeldisaxintfun}$ to include the premise $\neg \toplike{B}$.
This is due to the specification of $\top$-disjointness, which requires two types not to be top-like in order for them to be disjoint.

\joao{add a paragraph mentioning the possibility of using two different definitions of top-like in T-disjointness, so we can get a DisAx-Int-Fun with no premise?}
