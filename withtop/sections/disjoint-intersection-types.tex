\section{Semantics, Disjointness and Coherence}
\label{sec:disjoint}
% \bruno{This section still needs to be cleaned up to remove stuff
%   related to polymorphism.}
%The previous section introduced the type system of \name. However it 
%did not discuss the semantics or how the calculus ensures coherence. 
This section discusses the semantics of \name, and shows a modified
type system that
guarantees coherence and type soundness, and is sound and complete
with respect to the type system presented in Section~\ref{}. The key 
aspect to ensuring coherence is the notion of disjoint intersection.

\bruno{How to pitch this section:}
Three things to ensure coherence:

1) Ordinary + Well-formedness ensure that coercions produced by
subtyping relation are unique; 

2) Bi-directional type-system ensures that unambiguous types: the 
additional type annotations are enough to remove ambiguity, and ensure
that the calculus always elaborates every program to a unique
expression in the target language.

%From the theoretical point-of-view, the end goal of this section is to show that the resulting system has
%a coherent (or unique) elaboration semantics:
%\begin{restatable}[Unique elaboration]{theorem}{uniqueelaboration}
%  \label{theorem:unique-elaboration}
%
%  If $\jtype \Gamma e {A_1} \yields {E_1}$ and $\jtype \Gamma e {A_2} \yields
%  {E_2}$, then $E_1 \equiv E_2$. (``$\equiv$'' means syntactical equality, up to
%  $\alpha$-equality.)
%
%\end{restatable}
%
%\noindent In other words, given a source term $e$, elaboration always produces
%the same target term $E$. The most important hurdle we need to overcome is that
%if $A \inter B \subtype C$, then either $A$ or $B$ contributes to that subtyping
%relation, resulting in two possible coercions.

\subsection{Disjointness} Throughout the paper we already presented an intuitive
definition for disjointness. 
Before we discuss that definition, let us introduce first the notion of a top-like type 

%Here such definition is made a bit more precise, and
%well-suited to \name.
\begin{figure}[t]
  \begin{mathpar}
    \formtoplike \\ %\framebox{$\jatomic A$} \\

    \ruletopltop \and \ruletoplfun \and \ruletoplinterl \and \ruletoplinterr

  \end{mathpar}
  \caption{Top-like types.}
  \label{fig:fi-toplike}
\end{figure}

\begin{definition}[Top-like types]
  
  One type $A$ is a top-like type, denoted as $\toplike{A}$, if it has the form $A_k \to \top$, where $k \in {0,1,..}$.
  That is, any type with arity $k$ can be a top-like type, as long as $\top$ is the result type. 

\end{definition}
Thus a top-like type is a unary relation at the type level, which can be formalized according to \ref{fig:fi-toplike}.
% \bruno{This definition is wrong and too complicated. Since there is no
% polymorphism, we do not need $\Gamma$.}
Now, we recall the definition of disjoint types

\begin{definition}[Disjoint types]

  Two types $A$ and $B$ are said to be disjoint (written $\jdis \Gamma A B$) if
  they do not share a common supertype - excluding top-like types. 
  That is, for all type $C$ such that $A \subtype C$ and $B \subtype C$, then $\toplike{C}$ must hold.

  \[\jdis \Gamma A B \equiv \forall C.~A \subtype C \wedge B \subtype C \Rightarrow \toplike{C}\]

\end{definition}

For example, $\code{Int}$ and $\code{Char}$ are disjoint,
if their only common supertype is $\top$. On the other hand, $\code{Int}$ is not
disjoint with itself, because $\code{Int} \subtype \code{Int}$. This implies that
disjointness is not reflexive as subtyping is. Two types with different ``shapes''
are always disjoint, unless one of them is an intersection type.
For example, a function type and an intersection
type may not be disjoint. Consider:
\[ \code{Int} \to \code{Int} \quad \text{and} \quad (\code{Int} \to \code{Int}) \inter (\code{String} \to \code{String}) \]
Those two types are not disjoint since $\code{Int} \to \code{Int}$ is their common supertype.
Also, $\code{Int} \to \code{Char}$ and $\code{Int} \to \code{String}$ are disjoint, 
since their supertypes are all types with the form $A \to \top$ 
(where A \emph{contains} \code{Int}, i.e. $\code{Int}$, $\code{Int} \inter \code{Char}$) and $\top$.

%TODO move this part somewhere else
\joao{do we want to allow this?
 f: String $\to$ Int \\ 
 g: String $\to$ T \\
 ($\lam$ h : String $\to$ T. h "") (f ,, g) }

At last, take as an example ($\top \inter \top$).
In a pure language (i.e. no side-effects), this type can be safely allowed since both components of the merge
will evaluate to the same value. 
However, in an effectful language, the evaluation of either the right or left component might lead to distinct results. 
Following the same reasoning, we might want to allow or restrict, for instance $String \to Int \inter String \to \top$,  

% \bruno{There are no changes in syntax, right? So the whole section
%   (and figure) can be dropped! Also, without polymorphism, we don't
%   need a bottom type.}
% \subsection{Syntax}
%
% \begin{figure}
%   \[
%     \begin{array}{l}
%       \begin{array}{llrll}
%         \text{Types}
%         & A, B & \Coloneqq & A \to B                 & \\
%         &      & \mid & A \inter B                   & \\
%
%         \\
%         \text{Terms}
%         & e & \Coloneqq & x                        & \\
%         &   & \mid & \lam {(x \oftype A)} e          & \\
%         &   & \mid & \app {e_1} {e_2}              & \\
%         &   & \mid & e_1 \mergeop e_2              & \\
%
%         \\
%         \text{Contexts}
%         & \Gamma & \Coloneqq & \cdot
%                    \mid \Gamma, x \oftype A  & \\
%       \end{array}
%     \end{array}
%   \]
%
%   \caption{Amendments of the rules.}
%   \label{fig:fi-syntax-dis}
% \end{figure}

% \george{May also note on the scoping of type variables inside contexts.}

% Figure~\ref{fig:fi-syntax-dis} shows the updated syntax with the
% changes highlighted.

% First, type
% variables are now always associated with their disjointness
% constraints (like $\alpha \disjoint A$) in types, terms, and
% contexts. Second, the bottom type ($\bot$) is introduced so that
% universal quantification becomes a special case of disjoint
% quantification: $\blam \alpha e$ is really a syntactic sugar for
% $\blamdis \alpha \bot e$. The underlying idea is that any type is
% disjoint with the bottom type.  Note the analogy with bounded
% quantification, where the top type is the trivial upper bound in
% bounded quantification, while the bottom type is the trivial
% disjointness constraint in disjoint quantification.

%Indeed, \bruno{unfinidhed sentence}\george{Mabe show a diagram here to contrast
%with bounded polymorphism.}

\subsection{Bidirectional Type System}

Introduce the bi-directional type system here?

Two motivations for the bidirectional type system. 
Firstly the presence of a subsumption rule makes the declarative type 
system not syntax directed; bidirectional type-checking provides an 
easy way to recover syntax-directed typing. Secondly, bidirectional 
type-checking removes type-ambiguity. This makes it easier to talk
about coherence. 

The syntax need to be extended with one additional construct: type 
annotations.

\begin{figure}
  \begin{mathpar}
    \formt \\
    \bruletvar \and \bruletint \and
    \bruletlam \and \bruletapp \and
    \bruletmergedis \and \bruletsub \and \brulettop \and \bruletann
  \end{mathpar}
  \caption{Bidirectional type system of \name.}
  \label{fig:fi-typebd}
\end{figure}

\paragraph{Uniqueness of type-inference} An important property of the
bidirectional type-checking is that, given an expression $e$, if it is
possible to infer a type for $e$, then $e$ has a unique type.

\begin{theorem}[Uniqueness of type-inference]
%  If $e$ is a well-typed \name term, then $e$ evaluates to some $\lambda$-calculus
%  value $v$.
\bruno{statement missing.}
\end{theorem}

In contrast, in the declarative type system the uniqueness of types
property does not hold. 

\paragraph{Soundness and Compleness} The declarative type system presented in
Figure~\ref{} is closely related to the bidirectional type system 
in Figure~\ref{}. We can prove that the bidirectional type system 
is sound and complete with respect to the declarative specification, 
modulo some additional type-annotations.

\begin{theorem}[Soundness of bidirectional type-checking]
%  If $e$ is a well-typed \name term, then $e$ evaluates to some $\lambda$-calculus
%  value $v$.
\bruno{statement missing.}
\end{theorem}

\begin{theorem}[Completeness of bidirectional type-checking]
%  If $e$ is a well-typed \name term, then $e$ evaluates to some $\lambda$-calculus
%  value $v$.
\bruno{statement missing.}
\end{theorem}

\subsection{Semantics}

We define the dynamic semantics of the call-by-value \name by means of
a type-directed translation to an extension of $\lambda$-calculus with pairs.
%The type-directed translation is also shown in
%Figure~\ref{}, where the resulting System F terms are highlighted in
%gray.


\paragraph{Target Language.}
The syntax and typing of our target language is unsurprising. The syntax of the
target language is shown in Figure~\ref{fig:f-syntax}. The highlighted part
shows its difference with the $\lambda$-calculus. The typing rules can be found
in the extended version of the paper.

% \bruno{Does the target language does need unit? Any rules generating units? I
% don't think so, so it can be dropped.}

\paragraph{Key Idea of the Translation.}
This translation turns merges into usual pairs, similar to Dunfield's
elaboration approach~\cite{dunfield2014elaborating}.
For example, \[ 1 \mergeop \code{"one"} \] becomes \pair 1
{\code{"one"}}. In usage, the pair will be coerced according to type
information. For example, consider the function application: \[ \app {(\lamty x
{\code{String}} x)} {(1 \mergeop \code{"one"})} \] This expression will be translated to \[ \app
{(\lamty x {\code{String}} x)} {(\app {(\lamty x {\pair {\code{Int}} {\code{String}}} {\proj 2 x})}
{\pair 1 {\code{"one"}}})} \] The coercion in this case is $(\lamty x {\pair
{\code{Int}} {\code{String}}} {\proj 2 x})$. It extracts the second item from the pair, since
the function expects a $\code{String}$ but the translated argument is of type $\pair
{\code{Int}} {\code{String}}$.


\begin{figure}[t]
  \[
    \begin{array}{llrl}
      \text{Types}    & T & \Coloneqq & \code{Int} \\
                      &   & \mid      & \unit \\
                      &   & \mid      & {T_1} \to {T_2} \\
                      &   & \mid      & \highlight {$ \pair {T_1} {T_2} $} \\
      \text{Terms}    & E & \Coloneqq & x \\
                      &   & \mid      & i \\
                      &   & \mid      & \unit \\
                      &   & \mid      & \lamty x T E \\
                      &   & \mid      & \app {E_1} {E_2} \\
                      &   & \mid      & \highlight {$ \pair {E_1} {E_2} $} \\
                      &   & \mid      & \highlight {$ \proj k E $} \quad k \in \{ 1, 2 \} \\
      \text{Contexts} & G & \Coloneqq & \cdot \mid G, x \oftype T \\
    \end{array}
  \]
  \caption{Target language syntax.}
  \label{fig:f-syntax}
\end{figure}

\paragraph{Type and Context Translation.}

Figure~\ref{fig:type-and-context-translation} defines the type translation
function $\im \cdot$ from \name types $A$ to target language types $T$. The
notation $\im \cdot$ is also overloaded for context translation from \name
contexts $\Gamma$ to target language contexts $G$.

\begin{figure}[t]
  \framebox{$\im A = T$}

  \begin{align*}
    \im {\code{Int}}     &= \code{Int} \\
    \im {A_1 \to A_2}    &= \im {A_1} \to \im {A_2} \\
    \im {A_1 \inter A_2} &= \pair {\im {A_1}} {\im {A_2}} \\
    \im \top             &= \unit \\
  \end{align*}

  \framebox{$\im \Gamma = G$}

  \begin{align*}
    \im \cdot                      &= \cdot \\
    \im {\Gamma, \alpha \oftype A} &= \im \Gamma, \alpha \oftype \im A
  \end{align*}

  \caption{Type and context translation.}
  \label{fig:type-and-context-translation}
\end{figure}

% The rules given in this section are identical with those in
% Section~\ref{sec:fi}, except for the light blue part. The translation consists
% of four sets of rules, which are explained below:

\paragraph{Coercive subtyping.}

The judgment
\[
A_1 \subtype A_2 \yields E
\]
extends the subtyping judgment in Figure~\ref{fig:fi-type} with a coercion
on the right hand side of $ \yields {} $. A coercion $ E $ is just an term
in the target language and is ensured to have type
$ \im {A_1} \to \im {A_2} $ (by Lemma~\ref{lemma:sub}). For example,
\[
\code{Int} \inter \code{Bool} \subtype \code{Bool} \yields {\lamty x {\im {\code{Int} \inter \code{Bool}}} {\proj 2 x}}
\]
generates a coercion function with type: $\code{Int} \inter \code{Bool} \to \code{Bool}$.

In \reflabel{\labelsubfun}, we elaborate the subtyping of
parameter and return types by $\eta$-expanding $f$ to $\lamty x {\im {A_3}}
{\app f x}$, applying $E_1$ to the argument and $E_2$ to the result. Rules
\reflabel{\labelsubinterl}, \reflabel{\labelsubinterr}, and
\reflabel{\labelsubinter} elaborate intersection types.
\reflabel{\labelsubinter} uses both coercions to form a pair. Rules
\reflabel{\labelsubinterl} and \reflabel{\labelsubinterr} reuse the coercion
from the premises and create new ones that cater to the changes of the argument
type in the conclusions. Note that the two rules are overlapping and
hence a program can be elaborated differently, depending on which rule
is used. Finally, all rules produce type-correct coercions:

%But in the implementation one usually applies the rules sequentially with
%pattern matching, essentially defining a deterministic order of lookup.

% if we know $A_1$ is a subtype of $A_3$ and $C$ is a coercion from $A_1$
% to $A_3$, then we can conclude that $A_1 \inter A_2$ is also a subtype
% of $A_3$ and the new coercion is a function that takes a value $ x $ of type
% $A_1\inter A_2$, project $x$ on the first item, and apply $ C $ to it.

\begin{restatable}[Subtyping rules produce type-correct coercions]{lemma}{lemmasub}
  \label{lemma:sub}
  If $ A_1 \subtype A_2 \yields E $, then $ \jtype \cdot E {\im {A_1} \to \im {A_2}} $.
\end{restatable}

\begin{proof}
  By a straightforward induction on the derivation\footnote{The proofs of major lemmata and theorems can be found in the full version of the paper.\bruno{where??}}.
\end{proof}

\paragraph{The translation judgment.} The translation judgment $\jtype \Gamma e
A \yields E$ extends the typing judgment with an elaborated term on the right
hand side of $\yields {}$. The translation ensures that $E$ has type $\im A$. In
\name, one may pass more information to a function than what is required; but
not in ordinary $\lambda$-calculus. To account for this difference, in \reflabel{\labeltapp}, the
coercion $E$ from the subtyping relation is applied to the argument.
\reflabel{\labeltmerge} straightforwardly translates merges into pairs.

The type-directed translation is type-safe. This property is captured
by the following two theorems.

\begin{restatable}[Type preservation]{theorem}{typepreservation}
  \label{theorem:type-preservation}

  If $ \jtype \Gamma e A \yields E $,
  then $ \jtype {\im \Gamma} E {\im A} $.
\end{restatable}

\begin{proof}
  (Sketch) By structural induction on the term and the corresponding
  inference rule.
\end{proof}

\begin{theorem}[Type safety]
  If $e$ is a well-typed \name term, then $e$ evaluates to some $\lambda$-calculus
  value $v$.
\end{theorem}

\begin{proof}
  Since we define the dynamic semantics of \name in terms of the composition of
  the type-directed translation and the dynamic semantics of $\lambda$-calculus, type safety follows immediately.
\end{proof}

\begin{comment}
\subsection{Typing}

Figure~\ref{fig:fi-type-patch} shows modifications to Figure~\ref{fig:fi-type}
in order to support disjoint intersection types.
Only new rules or rules that different are shown. Importantly, the disjointness
judgment appears in the well-formedness rule for intersection types and the
typing rule for merges.

\begin{figure}[t]
  \begin{mathpar}
    \framebox{$\jatomic A$} \\

    \inferrule*
    {}
    {\jatomic {A \to B}}

    \inferrule*
    {}
    {\jatomic {\code{Int}}}

    \inferrule*
    {}
    {\jatomic \top}
  \end{mathpar}

  \begin{mathpar}
    \formsub \\ \rulesubinterldis \and \rulesubinterrdis
  \end{mathpar}

  \begin{mathpar}
    \formwf \\ \rulewfinterdis
  \end{mathpar}

  \begin{mathpar}
    \formt \\ \ruletmergedis
  \end{mathpar}

  \caption{Affected rules.}
  \label{fig:fi-type-patch}
\end{figure}

%\paragraph{Atomic Types.} The new system introduces atomic types. Essentially a type
%is atomic if it is any type, which is not an intersection type.
%The notion of atomic
%type will be helpful

\paragraph{Well-formedness.}
We require that the two types of an intersection must be disjoint. Under the new rules, intersection types such as $\code{Int} \inter \code{Int}$
are no longer well-formed because the two types are not disjoint.

\paragraph{Metatheory.}
Since in this section we only restrict the type system
in the previous section, it is easy to see that type preservation and
type-safety still holds.

% Additionally, we can see that typing always produces a
% well-formed type. \bruno{Revise text below, as I uncommented it.}

%%\begin{restatable}[Instantiation]{lemma}{instantiation}
%%  \label{lemma:instantiation}

%%   If $\jwf {\Gamma, \alpha \disjoint B} C$, $\jwf \Gamma A$, $\jdis \Gamma A B$
%%   then $\jwf \Gamma {\subst A \alpha C}$.
%% \end{restatable}

% \begin{restatable}[Well-formed typing]{lemma}{wellformedtyping}
%    \label{lemma:wellformed-typing}
%
%    If $\jtype \Gamma e A$, then $\jwf \Gamma A$.
% \end{restatable}

% \begin{proof}
%   By induction on the derivation that leads to $\jtype \Gamma e A$ and applying
%   Lemma~\ref{lemma:instantiation} in the case of \reflabel{\labelttapp}.
% \end{proof}

% This lemma will play an important role in the proof of coherence.
%
% \bruno{Tell the reader why the typing produces a well-formed type is important.
% Probably you want to say something like: ``it will be important to prove coherence''.}

% With our new definition of well-formed types, this result is nontrivial.

% In general, disjointness judgments are not invariant with respect to
% free-variable substitution. In other words, a careless substitution can violate
% the disjoint constraint in the context. For example, in the context $\alpha
% \disjoint \code{Int}$, $\alpha$ and $\code{Int}$ are disjoint:
% \[ \jdis {\alpha \disjoint \code{Int}} \alpha \code{Int} \]
% But after the substitution of $\code{Int}$ for $\alpha$ on the two types, the sentence
% \[ \jdis {\alpha \disjoint \code{Int}} \code{Int} \code{Int} \]
% is longer true since $\code{Int}$ is clearly not disjoint with itself.
\end{comment}

\subsection{Subtyping}

% \george{Explain \reflabel{\labelsubforall} and distinction of kernel and all version.}

The subtyping rules need some adjustment. An important problem with the
subtyping rules in Figure~\ref{fig:fi-type} is that all three rules dealing
with intersection types (\reflabel{\labelsubinterl} and
\reflabel{\labelsubinterr} and \reflabel{\labelsubinter}) overlap.
Unfortunately, this means that different coercions may be given when checking
the subtyping between two types, depending on which derivation is chosen. This
is the ultimate reason for incoherence. There are two important types of
overlap:

\begin{enumerate}

\item The left decomposition rules for intersections (\reflabel{\labelsubinterl}
and \reflabel{\labelsubinterr}) overlap with each other.

\item The left decomposition rules for intersections (\reflabel{\labelsubinterl}
and \reflabel{\labelsubinterr}) overlap with the right decomposition rules for
intersections \reflabel{\labelsubinter}.

\end{enumerate}

\noindent Fortunately, disjoint intersections (which are enforced by
well-formedness) deal with problem 1): only one of the two left decomposition
rules can be chosen for a disjoint intersection type. Since the two types in the
intersection are disjoint, it is impossible that both of the preconditions of
the left decompositions are satisfied at the same time. More formally, with
disjoint intersections, we have the following theorem:

\begin{lemma}[Unique subtype contributor]
  \label{lemma:unique-subtype-contributor}

  If $A_1 \inter A_2 \subtype B$, where $A_1 \inter A_2$ and $B$ are well-formed types,
  then it is not possible that the following holds at the same time:
  \begin{enumerate}
    \item $A_1 \subtype B$
    \item $A_2 \subtype B$
  \end{enumerate}
\end{lemma}

Unfortunately, disjoint intersections alone are insufficient to deal with
problem 2). In order to deal with problem 2), we introduce a distinction between
types, and atomic types.

\paragraph{Atomic Types.} Atomic types are just those which are not intersection
types, and are asserted by the judgment \[ \jatomic A \]

Since types in \name are simple, the only atomic types are the
function type and integers.
But in richer systems, it can also include, for example, record types.
In the left decomposition rules for intersections we introduce a requirement
that $A_3$ is atomic. The consequence of this requirement is that when $A_3$ is
an intersection type, then the only rule that can be applied is
\reflabel{\labelsubinter}. With the atomic constraint, one can guarantee that at
any moment during the derivation of a subtyping relation, at most one rule can
be used. Consequently, the coercion of a subtyping relation $A \subtype B$ is
uniquely determined. This fact is captured by the following lemma:

\begin{restatable}[Unique coercion]{lemma}{uniquecoercion}
  \label{lemma:unique-coercion}

  If $A \subtype B \yields {E_1}$ and $A \subtype B \yields {E_2}$, where $A$
  and $B$ are well-formed types, then $E_1 \equiv E_2$.
\end{restatable}

\paragraph{No Loss of Expressiveness.}
Interestingly, our restrictions on subtyping do not sacrifice the expressiveness of
subtyping since we have the following two theorems:
\begin{theorem}
  If $A_1 \subtype A_3$, then $A_1 \inter A_2 \subtype A_3$.
\end{theorem}
\begin{theorem}
If $A_2 \subtype A_3$, then $A_1 \inter A_2 \subtype A_3$.
\end{theorem}

\noindent The interpretation of the two theorems is that: even though the
premise is made stricter by the atomic condition, we can still derive every
subtyping relation which is valid in the unrestricted system.

% Note that $A$ \emph{exclusive} or $B$ is true if and only if their truth value
% differ. Next, we are going to investigate the minimal requirement (necessary and
% sufficient conditions) such that the theorem holds.
%
% If $A_1$ and $A_2$ in this setting are the same, for example,
% $\code{Int} \inter \code{Int} \subtype \code{Int}$, obviously the theorem will
% not hold since both the left $\code{Int}$ and the right $\code{Int}$ are a
% subtype of $\code{Int}$.
%
% We can try to rule out such possibilities by making the requirement of
% well-formedness stronger. This suggests that the two types on the sides of
% $\inter$ should not ``overlap''. In other words, they should be ``disjoint''. It
% is easy to determine if two base types are disjoint. For example, $\code{Int}$
% and $\code{Int}$ are not disjoint. Neither do $\code{Int}$ and $\code{Nat}$.
% Also, types built with different constructors are disjoint. For example,
% $\code{Int}$ and $\code{Int} \to \code{Int}$. For function types, disjointness
% is harder to visualize. But bear in the mind that disjointness can defined by
% the very requirement that the theorem holds.
%
%
% This result is captured more formally by the following lemma:

% \george{Note that $\bot$ does not participate in subtyping and why (because the
% empty set intersecting the empty set is still empty).}

% \george{What's the variance of the disjoint constraint? C.f. bounded
% polymorphism.}

% \george{Two points are being made here: 1) nondisjoint intersections, 2) atomic
% types. Show an offending example for each?}

\subsection{Coherence of the Elaboration}
Combining the previous results, we are able to show the central theorem:

\begin{restatable}[Unique elaboration]{theorem}{uniqueelaboration}
  \label{theorem:unique-elaboration}

  If $\jtype \Gamma e {A_1} \yields {E_1}$ and $\jtype \Gamma e {A_2} \yields
  {E_2}$, then $E_1 \equiv E_2$. (``$\equiv$'' means syntactical equality, up to
  $\alpha$-equality.)

\end{restatable}

\begin{proof}
  Note that the typing rules are already syntax-directed but the case of
  \reflabel{\labeltapp} (copied below) still needs special attention since we
  need to show that the generated coercion $E$ is unique.
  \begin{mathpar}
    \ruletapp
  \end{mathpar}
  Luckily we know that typing
  judgments give well-formed types, and thus $\jwf \Gamma {A_1}$ and $\jwf
  \Gamma {A_3}$. Therefore we are able to apply
  Lemma~\ref{lemma:unique-coercion} and conclude that $E$ is unique.

\end{proof}
