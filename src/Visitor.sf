let (++) (s: String) (t: String) = s.concat(t);

type ExpVisitor[E] = {lit: Int -> E, add: E -> E -> E};
type Exp = {accept: forall E. ExpVisitor[E] -> E};

let evalVisitor: ExpVisitor[Int] = {
  lit = \(x: Int) -> x,
  add = \(x: Int) (y: Int) -> x + y
};

-- Define "constructors"
let lit (n: Int): Exp = {
  accept = /\E -> \(f: ExpVisitor[E]) -> f.lit n
};
let add (e1: Exp) (e2: Exp): Exp = {
  accept = /\E -> \(f: ExpVisitor[E]) -> f.add (e1.accept[E] f) (e2.accept[E] f)
};

type SubExpVisitor[E] = ExpVisitor[E] & {sub: E -> E -> E};
type SubExp = {accept: forall E. SubExpVisitor[E] -> E};

-- Check SubExp :> Exp

let sub (e1: SubExp) (e2: SubExp): SubExp = {
  accept = /\E -> \(f: SubExpVisitor[E]) -> f.sub (e1.accept[E] f) (e2.accept[E] f)
};

let printVisitor: SubExpVisitor[String] = {
  lit = \(x: Int) -> x.toString(),
  add = \(x: String) (y: String) -> x ++ " + " ++ y,
  sub = \(x: String) (y: String) -> x ++ " - " ++ y
};

let e1 = add (lit 2) (lit 3);
let e2 = sub (lit 2) (lit 3);

-- Client code
-- e1.accept[Int] evalVisitor
e2.accept[String] printVisitor 
