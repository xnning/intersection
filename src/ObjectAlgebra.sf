let (++) (s: String) (t: String) = s.concat(t);

type IEval = {eval : Int};
type ExpAlg[E] = {lit : Int -> E, add : E -> E -> E};
let evalAlg: ExpAlg[IEval] = {
  lit = \(x: Int) -> {eval = x},
  add = \(x: IEval) (y: IEval) -> {eval = x.eval + y.eval}
};

type SubExpAlg[E] = ExpAlg[E] & {sub: E -> E -> E};
let subEvalAlg = evalAlg ,, {sub = \(x: IEval) (y: IEval) -> {eval = x.eval - y.eval}};

type IPrint = {print: String};
let printAlg = {
  lit = \(x: Int) -> {print = x.toString()},
  add = \(x: IPrint) (y: IPrint) -> {print = x.print ++ " + " ++ y.print},
  sub = \(x: IPrint) (y: IPrint) -> {print = x.print ++ " - " ++ y.print}
};

let e1 [E] (f: ExpAlg [E])    = f.add (f.lit 6) (f.lit 6);
let e2 [E] (f: SubExpAlg [E]) = f.sub (e1 [E] f) (f.lit 2);
let merge [A, B] (f: ExpAlg[A]) (g: ExpAlg[B]): ExpAlg[A&B] = {
  lit = \(x: Int) -> f.lit x ,, g.lit x,
  add = \(x: A & B) (y: A & B) -> f.add x y ,, g.add x y
};
let newAlg = merge [IEval, IPrint] subEvalAlg printAlg;
-- (e1 [IEval&IPrint] newAlg).print
let o = e1 [IEval&IPrint] newAlg;
o.print ++ " = " ++ o.eval.toString()
