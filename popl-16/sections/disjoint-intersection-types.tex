\section{Disjoint Intersection Types and Disjoint Quantification}
\label{sec:disjoint}

Although the system shown in the previous section is type-safe, it is not
coherent. This section shows how to patch the system presented before so that it
supports coherence as well as type soundness. The keys aspects are the notion of
disjoint intersections, and disjoint quantification for polymorphic types.

Formally, the goal of this section is to tweak the system so that elaboration is deterministic, expressed by this theorem:
\begin{restatable}[Unique elaboration]{theorem}{uniqueelaboration}
  \label{theorem:unique-elaboration}

  If $\jtype \Gamma e {A_1} \yields {E_1}$ and $\jtype \Gamma e {A_2} \yields
  {E_2}$, then $E_1 \equiv E_2$. (``$\equiv$'' means syntactical equality, up to
  $\alpha$-equality.)

\end{restatable}

\noindent In other words, given a source term $e$, elaboration always produces
the same target term $E$. The most important hurdle we need to overcome is that
if $A \inter B \subtype C$, then either $A$ or $B$ contributes to that subtyping
relation, resulting in two possible coercions. The sufficient condition to rule
out that case is that $A$ and $B$ are said to be disjoint:

\begin{definition}[Disjoint types]
  Two types $A$ and $B$ are \emph{disjoint} if they do not share a common
  supertype, that is, there does not exist a type $C$ such that $A \subtype C$
  and that $B \subtype C$. \footnote{
  The definition of disjointness can also be adapted to type systems with a top
  type (such as \lstinline@Object@ in many OO languages): Two types $A$ and $B$
  are \emph{disjoint} if: the fact that $C$ is a commmon supertype of theirs
  implies $C$ is the top type.
  }
\end{definition}

Related to the definition is the disjoint judgement. We write
\[ \jdis \Gamma A B \]
if two types $A$ and $B$ are disjoint in the context $\Gamma$.

To see this definition in action, $\tyint$ and $\tystring$ are, because there is
no type that is a supertype of the both. On the other hand, $\tyint$ is not
disjoint with itself, because $\tyint \subtype \tyint$. This implies that
disjointness is not reflexive as subtyping is. Two types with different shapes
are disjoint unless one of them is an intersection type. For example, a function
type and a forall type must be disjoint. But a function type and an intersection
type may not be. Consider:
\[ \tyint \to \tyint \quad \text{and} \quad (\tyint \to \tyint) \inter (\tystring \to \tystring) \]
They are not disjoint since $\tyint \to \tyint$ is their common supertype.

Now that we have obtained a specification for disjointness, but the definition
involves an existence problem. How can we implement it? One possibility is
bidirectional subtyping, that is, we say two types, $A$ and $B$, are disjoint if
neither $A \subtype B$ nor $B \subtype A$. However, this implementation is
wrong. For example, $\tyint \inter \tystring$ and $\tystring \inter \tychar$ are
not disjoint by specification since $\tystring$ is their common supertype. Yet
by the implementation they are, since neither of them is a subtype of
the other. \bruno{You need a concrete code example to make this point.}
Hence the algorithmic rules are more nuanced. For now, it is enough to treat the
disjoint judgement $\jdis \Gamma A B$ as oracle and we will coome back to
this topic in the next section.

\subsection{Syntax}

\begin{figure}[h]
  \[
    \begin{array}{l}
      \begin{array}{llrll}
        \text{Types}
        & A, B & \Coloneqq & \alpha                  & \\
        &      & \mid & \highlight {$\bot$}          & \\
        &      & \mid & A \to B                      & \\
        &      & \mid & \for {(\alpha \highlight {$\disjoint A$})} B  & \\
        &      & \mid & A \inter B                   & \\

        \\
        \text{Terms}
        & e & \Coloneqq & x                        & \\
        &   & \mid & \lam {(x \oftype A)} e          & \\
        &   & \mid & \app {e_1} {e_2}              & \\
        &   & \mid & \blam {(\alpha \highlight {$\disjoint A$})} e  & \\
        &   & \mid & \tapp e A                     & \\
        &   & \mid & e_1 \mergeop e_2              & \\

        \\
        \text{Contexts}
        & \Gamma & \Coloneqq & \cdot
                   \mid \Gamma, \alpha \highlight {$\disjoint A$}
                   \mid \Gamma, x \oftype A  & \\

        \text{Syntactic sugar} & \blam \alpha e & \equiv & \blamdis \alpha \bot e & \\
      \end{array}
    \end{array}
  \]

  \caption{Amendments of the rules.}
  \label{fig:fi-syntax-dis}
\end{figure}

Figure~\ref{fig:fi-syntax-dis} shows the updated syntax with the changes highlighted.
Note how similar the changes are to those needed to extend System $F$ with
bounded quantification. First, type variables are now always associated with
their disjointness constraints (like $\alpha \disjoint A$) in types, terms, and
contexts. Second, the bottom type is introduced so that universal quantification
quantification be integrated and become a special case of disjoint
quantification: $\blam \alpha e$ is really a syntactic sugar for $\blamdis
\alpha \bot e$. The underlying idea is that any type is disjoint
with the bottom type.

As a comparison, the top type is the trivial upper bound in bounded
quantification, while the bottom type is the trivial disjointness constraint in
disjoint quantification. Indeed, \george{Mabe show a diagram here to contrast
with bounded polymorphism.}

\subsection{Typing}

The disjointness judgement appears in the well-formedness rule for intersection
types and the typing rule for merges.

\begin{figure*}
  \begin{mathpar}
    \framebox{$\jatomic A$} \\

    \inferrule*
    {}
    {\jatomic \bot}

    \inferrule*
    {}
    {\jatomic {A \to B}}

    \inferrule*
    {}
    {\jatomic {\fordis \alpha B A}}
  \end{mathpar}

  \begin{mathpar}
    \formsub \\ \rulesubinterldis \and \rulesubinterrdis
  \end{mathpar}

  \begin{mathpar}
    \formwf \\ \rulewfforalldis \and \rulewfinterdis
  \end{mathpar}

  \begin{mathpar}
    \formt \\ \ruletblamdis \and \rulettappdis \and \ruletmergedis
  \end{mathpar}

  \caption{Affected rules.}
  \label{fig:fi-type-patch}
\end{figure*}

\paragraph{Formation of disjoint intersection types}

We require that the two types of an intersection must be disjoint in their
context, and that the disjointness constraint in a forall type is well-formed.
Under the new rules, intersection types such as $\tyint \inter \tyint$ are no
longer well-formed because the two types are not disjoint.

\paragraph{Disjoint quantification} A disjoint quantification is introduced by
the big lambda $\blamdis \alpha A e$ and eliminated by the usual type
application $\tapp e A$. The constraint is added to the context with this rule.
During a type application, the type system makes sure that the type argument
satisfies the disjointness constraint.

\paragraph{Metatheory} Since in this section we only restrict the system in the
previous section, it is easy to see that type preservation and type-safety still
holds. Additionally, we can show that typing always produces a well-formed type.
With our new definition of well-formed types, this result is nontrivial.

In general, disjointness judgements are not invariant with respect to
free-variable substitution. In other words, a careless substitution can violate
the disjoint constraint in the context. For example, in the context $\alpha
\disjoint \tyint$, $\alpha$ and $\tyint$ are disjoint:
\[ \jdis {\alpha \disjoint \tyint} \alpha \tyint \]
But after the substitution of $\tyint$ for $\alpha$ on the two types, the sentence
\[ \jdis {\alpha \disjoint \tyint} \tyint \tyint \]
is longer true since $\tyint$ is clearly not disjoint with itself.

\begin{restatable}[Instantiation]{lemma}{instantiation}
  \label{lemma:instantiation}

  If $\jwf {\Gamma, \alpha \disjoint B} C$, $\jwf \Gamma A$, $\jdis \Gamma A B$
  then $\jwf \Gamma {\subst A \alpha C}$.
\end{restatable}

\begin{proof}
  By induction.
\end{proof}

\begin{restatable}[Well-formed typing]{lemma}{wellformedtyping}
  \label{lemma:wellformed-typing}

  If $\jtype \Gamma e A$, then $\jwf \Gamma A$.
\end{restatable}

\begin{proof}
  By induction on the derivation that leads to $\jtype \Gamma e A$ and applying
  Lemma~\ref{lemma:instantiation} in the case of \reflabel{\labelttapp}.
\end{proof}

\subsection{Subtyping}

The coercion of a subtyping relation $A \subtype B$ is uniquely determined.
\begin{restatable}[Unique coercion]{lemma}{uniquecoercion}
  \label{lemma:unique-coercion}

  If $A \subtype B \yields {E_1}$ and $A \subtype B \yields {E_2}$, where $A$
  and $B$ are well-formed types, then $E_1 \equiv E_2$.
\end{restatable}

\george{Two points are being made here: 1) nondisjoint intersections, 2) atomic
types. Show an offending example for each?}

\paragraph{Atomic types} Atomic types are just those which are not intersection
types, and are asserted by the judgement \[ \jatomic A \]

The subtyping rules, without the atomic condition are overlapping. If we would
like to have a deterministic elaboration result, the overarching idea is to
tweak the rules so that given a term, it is no longer possible that both of the
twin rules can be used. For example, if $A_1 \inter A_2 \subtype A_3$, we would
like to be certain that either $A_1 \subtype A_3$ holds or $A_2 \subtype A_3$
holds, but not both.

\begin{lemma}[Unique subtype contributor]
  \label{lemma:unique-subtype-contributor}

  If $A_1 \inter A_2 \subtype B$, where $A_1 \inter A_2$ and $B$ are well-formed types,
  then it is not possible that the following hold at the same time:
  \begin{enumerate}
    \item $A_1 \subtype B$
    \item $A_2 \subtype B$
  \end{enumerate}
\end{lemma}

With the atomic constraint, one can guarantee that at any moment during the
derivation of a subtyping relation, at most one rule can be used. Yet
remarkably, our restrictions on subtyping do not sacrifice the expressiveness of
subtyping since we have the following theorem:
\begin{theorem}
  If $A_1 \subtype A_3$, then $A_1 \inter A_2 \subtype A_3$.
\end{theorem}
The interpretation of the theorem is that: even though the premise is made more
strict by the atomic condition, we can still derive the every judgement in the
old systems. \george{Explain why the proof shows this.}

Note that $A$ \emph{exclusive} or $B$ is true if and only if their truth value
differ. Next, we are going to investigate the minimal requirement (necessary and
sufficient conditions) such that the theorem holds.

If $A_1$ and $A_2$ in this setting are the same, for example,
$\tyint \inter \tyint \subtype \tyint$, obviously the theorem will
not hold since both the left $\tyint$ and the right $\tyint$ are a
subtype of $\tyint$.

We can try to rule out such possibilities by making the requirement of
well-formedness stronger. This suggests that the two types on the sides of
$\inter$ should not ``overlap''. In other words, they should be ``disjoint''. It
is easy to determine if two base types are disjoint. For example, $\tyint$
and $\tyint$ are not disjoint. Neither do $\tyint$ and $\code{Nat}$.
Also, types built with different constructors are disjoint. For example,
$\tyint$ and $\tyint \to \tyint$. For function types, disjointness
is harder to visualise. But bear in the mind that disjointness can defined by
the very requirement that the theorem holds.

Combining the previous results, we are able to show the central theorem:
\uniqueelaboration*

\begin{proof}
  Note that the typing rules are already syntax-directed but the case of
  \reflabel{\labeltapp} (copied below) still needs special attention since we
  need to show that the generated coercion $E$ is unique.
  \begin{mathpar}
    \ruletapp
  \end{mathpar}
  Luckily, by Lemma~\ref{lemma:wellformed-typing}, we know that typing
  judgements give well-formed types, and thus $\jwf \Gamma {A_1}$ and $\jwf
  \Gamma {A_3}$. Therefore we are able to apply
  Lemma~\ref{lemma:unique-coercion} and conclude that $E$ is unique.

\end{proof}
